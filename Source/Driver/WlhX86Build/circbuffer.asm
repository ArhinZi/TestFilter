; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	b:\programm\wntsys\testfilter\release\1_1\source\driver\circbuffer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CN@GKLFJEPI@CB?5?9?5CBAllocateBlock?5?9?5Bytes?5rem@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	?CBMovePtrForward@@YGJPAU_CIRCULAR_BUFFER@@PAPADK@Z ; CBMovePtrForward
PUBLIC	??_C@_0FJ@FNHANJDH@CB?5?9?5CBAllocateBlock?5?9?5Allocatin@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	?CBFreeOldestDataBlock@@YGXPAU_CIRCULAR_BUFFER@@@Z ; CBFreeOldestDataBlock
PUBLIC	?CBAllocateBlock@@YGJPAU_CIRCULAR_BUFFER@@K@Z	; CBAllocateBlock
EXTRN	__imp__DbgPrintEx:PROC
;	COMDAT ??_C@_0CN@GKLFJEPI@CB?5?9?5CBAllocateBlock?5?9?5Bytes?5rem@FNODOBFM@
; File b:\programm\wntsys\testfilter\release\1_1\source\driver\circbuffer.cpp
text$s	SEGMENT
??_C@_0CN@GKLFJEPI@CB?5?9?5CBAllocateBlock?5?9?5Bytes?5rem@FNODOBFM@ DB 'C'
	DB	'B - CBAllocateBlock - Bytes remaining: %#x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0FJ@FNHANJDH@CB?5?9?5CBAllocateBlock?5?9?5Allocatin@FNODOBFM@
text$s	SEGMENT
??_C@_0FJ@FNHANJDH@CB?5?9?5CBAllocateBlock?5?9?5Allocatin@FNODOBFM@ DB 'C'
	DB	'B - CBAllocateBlock - Allocating block: start %#p, length (no'
	DB	't counting hdr) %#x bytes', 0aH, 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?CBAllocateBlock@@YGJPAU_CIRCULAR_BUFFER@@K@Z
_TEXT	SEGMENT
_i$27641 = -24						; size = 4
_status$ = -20						; size = 4
_blockHdr$ = -16					; size = 4
_pBlockStart$ = -12					; size = 4
_cbBytesNeeded$ = -8					; size = 4
_pHdr$ = -4						; size = 4
_pBufCtl$ = 8						; size = 4
_cbBlockSize$ = 12					; size = 4
?CBAllocateBlock@@YGJPAU_CIRCULAR_BUFFER@@K@Z PROC	; CBAllocateBlock, COMDAT

; 46   : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 47   : 	SIZE_T cbBytesNeeded = cbBlockSize + sizeof(CB_BLOCK_HEADER);

	mov	eax, DWORD PTR _cbBlockSize$[ebp]
	add	eax, 4
	mov	DWORD PTR _cbBytesNeeded$[ebp], eax

; 48   : 
; 49   : 	// Ensure that the block can fit into the buffer.
; 50   : 	//
; 51   : 	if (cbBytesNeeded > pBufCtl->cbBufSize) {

	mov	ecx, DWORD PTR _pBufCtl$[ebp]
	mov	edx, DWORD PTR _cbBytesNeeded$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jbe	SHORT $LN6@CBAllocate

; 52   : 		return STATUS_NO_MEMORY;

	mov	eax, -1073741801			; c0000017H
	jmp	$LN7@CBAllocate
$LN6@CBAllocate:

; 53   : 	}
; 54   : 	NTSTATUS status = STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0
$LN5@CBAllocate:

; 55   : 
; 56   : 	// Discard data if the available space is not enough.
; 57   : 	//
; 58   : 	while (pBufCtl->cbAvailable < cbBytesNeeded) {

	mov	eax, DWORD PTR _pBufCtl$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	cmp	ecx, DWORD PTR _cbBytesNeeded$[ebp]
	jae	SHORT $LN4@CBAllocate

; 59   : 		CBFreeOldestDataBlock(pBufCtl);

	mov	edx, DWORD PTR _pBufCtl$[ebp]
	push	edx
	call	?CBFreeOldestDataBlock@@YGXPAU_CIRCULAR_BUFFER@@@Z ; CBFreeOldestDataBlock

; 60   : 		status = CB_STATUS_WARN_DATA_LOST;

	mov	DWORD PTR _status$[ebp], -1610612735	; a0000001H

; 61   : 	}

	jmp	SHORT $LN5@CBAllocate
$LN4@CBAllocate:

; 62   : 	PCHAR pBlockStart = pBufCtl->pDataEnd;

	mov	eax, DWORD PTR _pBufCtl$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	DWORD PTR _pBlockStart$[ebp], ecx

; 63   : 
; 64   : 	// Note on pDataStart (buffer ctl structure): if the buffer is not 
; 65   : 	// empty, the new block is not the beginning of the data.
; 66   : 	// pDataStart already points to the beginning of the data and needs 
; 67   : 	// not to be updated.
; 68   : 	//
; 69   : 	// If the buffer is empty, the new block is also the beginning
; 70   : 	// of the data and pDataStart must point to it, however, given that 
; 71   : 	// for an empty buffer pDataStart = pDataEnd, it already has the 
; 72   : 	// correct address.
; 73   : 	//
; 74   : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 75   : 		"CB - CBAllocateBlock - Allocating block: start %#p, length "
; 76   : 		"(not counting hdr) %#x bytes\n", pBlockStart, cbBlockSize);

	mov	edx, DWORD PTR _cbBlockSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _pBlockStart$[ebp]
	push	eax
	push	OFFSET ??_C@_0FJ@FNHANJDH@CB?5?9?5CBAllocateBlock?5?9?5Allocatin@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 20					; 00000014H

; 77   : 
; 78   : 	CBMovePtrForward(pBufCtl, &pBufCtl->pDataEnd, cbBytesNeeded);

	mov	ecx, DWORD PTR _cbBytesNeeded$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pBufCtl$[ebp]
	add	edx, 16					; 00000010H
	push	edx
	mov	eax, DWORD PTR _pBufCtl$[ebp]
	push	eax
	call	?CBMovePtrForward@@YGJPAU_CIRCULAR_BUFFER@@PAPADK@Z ; CBMovePtrForward

; 79   : 	pBufCtl->cbAvailable -= cbBytesNeeded;

	mov	ecx, DWORD PTR _pBufCtl$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	sub	edx, DWORD PTR _cbBytesNeeded$[ebp]
	mov	eax, DWORD PTR _pBufCtl$[ebp]
	mov	DWORD PTR [eax+24], edx

; 80   : 	pBufCtl->pCurrentBlock = pBlockStart;

	mov	ecx, DWORD PTR _pBufCtl$[ebp]
	mov	edx, DWORD PTR _pBlockStart$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 81   : 
; 82   : 	// Write the data block header at the block starting address
; 83   : 	//
; 84   : 	CB_BLOCK_HEADER blockHdr = {0};

	mov	DWORD PTR _blockHdr$[ebp], 0

; 85   : 	blockHdr.cbSize = cbBlockSize;

	mov	eax, DWORD PTR _cbBlockSize$[ebp]
	mov	DWORD PTR _blockHdr$[ebp], eax

; 86   : 	PCHAR pHdr = (PCHAR) &blockHdr;

	lea	ecx, DWORD PTR _blockHdr$[ebp]
	mov	DWORD PTR _pHdr$[ebp], ecx

; 87   : 	for (INT i = 0; i < sizeof blockHdr; i++) {

	mov	DWORD PTR _i$27641[ebp], 0
	jmp	SHORT $LN3@CBAllocate
$LN2@CBAllocate:
	mov	edx, DWORD PTR _i$27641[ebp]
	add	edx, 1
	mov	DWORD PTR _i$27641[ebp], edx
$LN3@CBAllocate:
	cmp	DWORD PTR _i$27641[ebp], 4
	jae	SHORT $LN1@CBAllocate

; 88   : 		*pBlockStart = *(pHdr + i);

	mov	eax, DWORD PTR _pHdr$[ebp]
	add	eax, DWORD PTR _i$27641[ebp]
	mov	ecx, DWORD PTR _pBlockStart$[ebp]
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [ecx], dl

; 89   : 		CBMovePtrForward(pBufCtl, &pBlockStart, 1);

	push	1
	lea	eax, DWORD PTR _pBlockStart$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBufCtl$[ebp]
	push	ecx
	call	?CBMovePtrForward@@YGJPAU_CIRCULAR_BUFFER@@PAPADK@Z ; CBMovePtrForward

; 90   : 	}

	jmp	SHORT $LN2@CBAllocate
$LN1@CBAllocate:

; 91   : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 92   : 		"CB - CBAllocateBlock - Bytes remaining: %#x\n",
; 93   : 		pBufCtl->cbAvailable);

	mov	edx, DWORD PTR _pBufCtl$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	push	OFFSET ??_C@_0CN@GKLFJEPI@CB?5?9?5CBAllocateBlock?5?9?5Bytes?5rem@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 16					; 00000010H

; 94   : 
; 95   : 	return status;

	mov	eax, DWORD PTR _status$[ebp]
$LN7@CBAllocate:

; 96   : }

	mov	esp, ebp
	pop	ebp
	ret	8
?CBAllocateBlock@@YGJPAU_CIRCULAR_BUFFER@@K@Z ENDP	; CBAllocateBlock
_TEXT	ENDS
PUBLIC	?CBDataBufferEmpty@@YGEPAU_CIRCULAR_BUFFER@@@Z	; CBDataBufferEmpty
; Function compile flags: /Odtp
;	COMDAT ?CBDataBufferEmpty@@YGEPAU_CIRCULAR_BUFFER@@@Z
_TEXT	SEGMENT
_pBufCtl$ = 8						; size = 4
?CBDataBufferEmpty@@YGEPAU_CIRCULAR_BUFFER@@@Z PROC	; CBDataBufferEmpty, COMDAT

; 102  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 103  : 	return (pBufCtl->pDataStart == pBufCtl->pDataEnd);

	mov	eax, DWORD PTR _pBufCtl$[ebp]
	mov	ecx, DWORD PTR _pBufCtl$[ebp]
	mov	edx, DWORD PTR [eax+12]
	cmp	edx, DWORD PTR [ecx+16]
	sete	al

; 104  : }

	pop	ebp
	ret	4
?CBDataBufferEmpty@@YGEPAU_CIRCULAR_BUFFER@@@Z ENDP	; CBDataBufferEmpty
_TEXT	ENDS
PUBLIC	??_C@_0DG@LDFCLJFD@CB?5?9?5CBFreeOldestDataBlock?5?9?5Ava@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0FP@GOPFBPAP@CB?5?9?5CBFreeOldestDataBlock?5?9?5Dis@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DG@NHBGMIEE@CB?5?9?5CBFreeOldestDataBlock?5?9?5Ava@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0DG@LDFCLJFD@CB?5?9?5CBFreeOldestDataBlock?5?9?5Ava@FNODOBFM@
text$s	SEGMENT
??_C@_0DG@LDFCLJFD@CB?5?9?5CBFreeOldestDataBlock?5?9?5Ava@FNODOBFM@ DB 'C'
	DB	'B - CBFreeOldestDataBlock - Avail bytes after:  %#x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0FP@GOPFBPAP@CB?5?9?5CBFreeOldestDataBlock?5?9?5Dis@FNODOBFM@
text$s	SEGMENT
??_C@_0FP@GOPFBPAP@CB?5?9?5CBFreeOldestDataBlock?5?9?5Dis@FNODOBFM@ DB 'C'
	DB	'B - CBFreeOldestDataBlock - Discarding block: start %#p, leng'
	DB	'th (not counting hdr) %#x bytes', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DG@NHBGMIEE@CB?5?9?5CBFreeOldestDataBlock?5?9?5Ava@FNODOBFM@
text$s	SEGMENT
??_C@_0DG@NHBGMIEE@CB?5?9?5CBFreeOldestDataBlock?5?9?5Ava@FNODOBFM@ DB 'C'
	DB	'B - CBFreeOldestDataBlock - Avail bytes before: %#x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?CBFreeOldestDataBlock@@YGXPAU_CIRCULAR_BUFFER@@@Z
_TEXT	SEGMENT
_i$27657 = -20						; size = 4
_pHdrVar$ = -16						; size = 4
_OldestHdr$ = -12					; size = 4
_cbBytesFreed$ = -8					; size = 4
_pHdr$ = -4						; size = 4
_pBufCtl$ = 8						; size = 4
?CBFreeOldestDataBlock@@YGXPAU_CIRCULAR_BUFFER@@@Z PROC	; CBFreeOldestDataBlock, COMDAT

; 110  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 111  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 112  : 		"CB - CBFreeOldestDataBlock - Avail bytes before: %#x\n",
; 113  : 		pBufCtl->cbAvailable);

	mov	eax, DWORD PTR _pBufCtl$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	OFFSET ??_C@_0DG@NHBGMIEE@CB?5?9?5CBFreeOldestDataBlock?5?9?5Ava@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 16					; 00000010H

; 114  : 	CB_BLOCK_HEADER OldestHdr;
; 115  : 
; 116  : 	// Extract the block header. Keep in mind that it can wrap
; 117  : 	// around the end.
; 118  : 	//
; 119  : 	PCHAR pHdrVar = (PCHAR) &OldestHdr;

	lea	edx, DWORD PTR _OldestHdr$[ebp]
	mov	DWORD PTR _pHdrVar$[ebp], edx

; 120  : 	PCHAR pHdr = pBufCtl->pDataStart;

	mov	eax, DWORD PTR _pBufCtl$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _pHdr$[ebp], ecx

; 121  : 	for (INT i = 0; i < sizeof OldestHdr; i++) {

	mov	DWORD PTR _i$27657[ebp], 0
	jmp	SHORT $LN3@CBFreeOlde
$LN2@CBFreeOlde:
	mov	edx, DWORD PTR _i$27657[ebp]
	add	edx, 1
	mov	DWORD PTR _i$27657[ebp], edx
$LN3@CBFreeOlde:
	cmp	DWORD PTR _i$27657[ebp], 4
	jae	SHORT $LN1@CBFreeOlde

; 122  : 		*(pHdrVar + i) = *pHdr;

	mov	eax, DWORD PTR _pHdrVar$[ebp]
	add	eax, DWORD PTR _i$27657[ebp]
	mov	ecx, DWORD PTR _pHdr$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 123  : 		CBMovePtrForward(pBufCtl, &pHdr, 1);

	push	1
	lea	eax, DWORD PTR _pHdr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBufCtl$[ebp]
	push	ecx
	call	?CBMovePtrForward@@YGJPAU_CIRCULAR_BUFFER@@PAPADK@Z ; CBMovePtrForward

; 124  : 	}

	jmp	SHORT $LN2@CBFreeOlde
$LN1@CBFreeOlde:

; 125  : 
; 126  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 127  : 		"CB - CBFreeOldestDataBlock - Discarding block: start %#p, "
; 128  : 		"length (not counting "
; 129  : 		"hdr) %#x bytes\n", pBufCtl->pDataStart, OldestHdr.cbSize);

	mov	edx, DWORD PTR _OldestHdr$[ebp]
	push	edx
	mov	eax, DWORD PTR _pBufCtl$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	push	OFFSET ??_C@_0FP@GOPFBPAP@CB?5?9?5CBFreeOldestDataBlock?5?9?5Dis@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 20					; 00000014H

; 130  : 
; 131  : 	SIZE_T cbBytesFreed = OldestHdr.cbSize + sizeof (CB_BLOCK_HEADER);

	mov	edx, DWORD PTR _OldestHdr$[ebp]
	add	edx, 4
	mov	DWORD PTR _cbBytesFreed$[ebp], edx

; 132  : 	CBMovePtrForward(pBufCtl, &pBufCtl->pDataStart, cbBytesFreed);

	mov	eax, DWORD PTR _cbBytesFreed$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBufCtl$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	edx, DWORD PTR _pBufCtl$[ebp]
	push	edx
	call	?CBMovePtrForward@@YGJPAU_CIRCULAR_BUFFER@@PAPADK@Z ; CBMovePtrForward

; 133  : 	pBufCtl->cbAvailable += cbBytesFreed;

	mov	eax, DWORD PTR _pBufCtl$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, DWORD PTR _cbBytesFreed$[ebp]
	mov	edx, DWORD PTR _pBufCtl$[ebp]
	mov	DWORD PTR [edx+24], ecx

; 134  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 135  : 		"CB - CBFreeOldestDataBlock - Avail bytes after:  %#x\n",
; 136  : 		pBufCtl->cbAvailable);

	mov	eax, DWORD PTR _pBufCtl$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	push	OFFSET ??_C@_0DG@LDFCLJFD@CB?5?9?5CBFreeOldestDataBlock?5?9?5Ava@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 16					; 00000010H

; 137  : 	return;
; 138  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CBFreeOldestDataBlock@@YGXPAU_CIRCULAR_BUFFER@@@Z ENDP	; CBFreeOldestDataBlock
_TEXT	ENDS
PUBLIC	??_C@_0BD@EPPMMNOE@?5?5?5?5size?3?5?5?5?5?5?$CF?$CDx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BD@OONIOHJ@?5?5?5?5end?3?5?5?5?5?5?5?$CF?$CDp?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BD@PFLOOKJ@?5?5?5?5start?3?5?5?5?5?$CF?$CDp?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CO@PDHPHBOO@CB?5?9?5CBInitBufferCtlVar?5?9?5Buffer@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	?CBInitBufferCtlVar@@YGXPAU_CIRCULAR_BUFFER@@PAXK@Z ; CBInitBufferCtlVar
;	COMDAT ??_C@_0BD@EPPMMNOE@?5?5?5?5size?3?5?5?5?5?5?$CF?$CDx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BD@EPPMMNOE@?5?5?5?5size?3?5?5?5?5?5?$CF?$CDx?6?$AA@FNODOBFM@ DB ' '
	DB	'   size:     %#x', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BD@OONIOHJ@?5?5?5?5end?3?5?5?5?5?5?5?$CF?$CDp?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BD@OONIOHJ@?5?5?5?5end?3?5?5?5?5?5?5?$CF?$CDp?6?$AA@FNODOBFM@ DB ' '
	DB	'   end:      %#p', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BD@PFLOOKJ@?5?5?5?5start?3?5?5?5?5?$CF?$CDp?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BD@PFLOOKJ@?5?5?5?5start?3?5?5?5?5?$CF?$CDp?6?$AA@FNODOBFM@ DB '  '
	DB	'  start:    %#p', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CO@PDHPHBOO@CB?5?9?5CBInitBufferCtlVar?5?9?5Buffer@FNODOBFM@
text$s	SEGMENT
??_C@_0CO@PDHPHBOO@CB?5?9?5CBInitBufferCtlVar?5?9?5Buffer@FNODOBFM@ DB 'C'
	DB	'B - CBInitBufferCtlVar - Buffer initialized', 0aH, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?CBInitBufferCtlVar@@YGXPAU_CIRCULAR_BUFFER@@PAXK@Z
_TEXT	SEGMENT
_pBufCtl$ = 8						; size = 4
_pBufAddr$ = 12						; size = 4
_cbBufSize$ = 16					; size = 4
?CBInitBufferCtlVar@@YGXPAU_CIRCULAR_BUFFER@@PAXK@Z PROC ; CBInitBufferCtlVar, COMDAT

; 147  : {

	npad	2
	push	ebp
	mov	ebp, esp

; 148  : 	pBufCtl->pBufStartAddr = (PCHAR) pBufAddr;

	mov	eax, DWORD PTR _pBufCtl$[ebp]
	mov	ecx, DWORD PTR _pBufAddr$[ebp]
	mov	DWORD PTR [eax], ecx

; 149  : 	pBufCtl->pBufEndAddr = ((PCHAR) pBufAddr) + cbBufSize;

	mov	edx, DWORD PTR _pBufAddr$[ebp]
	add	edx, DWORD PTR _cbBufSize$[ebp]
	mov	eax, DWORD PTR _pBufCtl$[ebp]
	mov	DWORD PTR [eax+4], edx

; 150  : 	pBufCtl->cbBufSize = cbBufSize;

	mov	ecx, DWORD PTR _pBufCtl$[ebp]
	mov	edx, DWORD PTR _cbBufSize$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 151  : 	pBufCtl->pDataStart = (PCHAR) pBufAddr;

	mov	eax, DWORD PTR _pBufCtl$[ebp]
	mov	ecx, DWORD PTR _pBufAddr$[ebp]
	mov	DWORD PTR [eax+12], ecx

; 152  : 	pBufCtl->pDataEnd = (PCHAR) pBufAddr;

	mov	edx, DWORD PTR _pBufCtl$[ebp]
	mov	eax, DWORD PTR _pBufAddr$[ebp]
	mov	DWORD PTR [edx+16], eax

; 153  : 	pBufCtl->cbAvailable = cbBufSize;

	mov	ecx, DWORD PTR _pBufCtl$[ebp]
	mov	edx, DWORD PTR _cbBufSize$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 154  : 
; 155  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 156  : 		"CB - CBInitBufferCtlVar - Buffer initialized\n");

	push	OFFSET ??_C@_0CO@PDHPHBOO@CB?5?9?5CBInitBufferCtlVar?5?9?5Buffer@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 12					; 0000000cH

; 157  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 158  : 		"    start:    %#p\n", pBufCtl->pBufStartAddr);

	mov	eax, DWORD PTR _pBufCtl$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	push	OFFSET ??_C@_0BD@PFLOOKJ@?5?5?5?5start?3?5?5?5?5?$CF?$CDp?6?$AA@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 16					; 00000010H

; 159  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 160  : 		"    end:      %#p\n", pBufCtl->pBufEndAddr);

	mov	edx, DWORD PTR _pBufCtl$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	OFFSET ??_C@_0BD@OONIOHJ@?5?5?5?5end?3?5?5?5?5?5?5?$CF?$CDp?6?$AA@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 16					; 00000010H

; 161  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 162  : 		"    size:     %#x\n", pBufCtl->cbBufSize);

	mov	ecx, DWORD PTR _pBufCtl$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	OFFSET ??_C@_0BD@EPPMMNOE@?5?5?5?5size?3?5?5?5?5?5?$CF?$CDx?6?$AA@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 16					; 00000010H

; 163  : 
; 164  : }

	pop	ebp
	ret	12					; 0000000cH
?CBInitBufferCtlVar@@YGXPAU_CIRCULAR_BUFFER@@PAXK@Z ENDP ; CBInitBufferCtlVar
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?CBMovePtrForward@@YGJPAU_CIRCULAR_BUFFER@@PAPADK@Z
_TEXT	SEGMENT
_cbOverflow$27689 = -4					; size = 4
_pBufCtl$ = 8						; size = 4
_ppAddress$ = 12					; size = 4
_cbBytes$ = 16						; size = 4
?CBMovePtrForward@@YGJPAU_CIRCULAR_BUFFER@@PAPADK@Z PROC ; CBMovePtrForward, COMDAT

; 172  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 173  : 	if (ppAddress == NULL) return STATUS_INVALID_PARAMETER;

	cmp	DWORD PTR _ppAddress$[ebp], 0
	jne	SHORT $LN4@CBMovePtrF
	mov	eax, -1073741811			; c000000dH
	jmp	SHORT $LN5@CBMovePtrF
$LN4@CBMovePtrF:

; 174  : 
; 175  : 	if ((*ppAddress < pBufCtl->pBufStartAddr) ||
; 176  : 		(*ppAddress >= pBufCtl->pBufEndAddr)) 

	mov	eax, DWORD PTR _ppAddress$[ebp]
	mov	ecx, DWORD PTR _pBufCtl$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jb	SHORT $LN2@CBMovePtrF
	mov	eax, DWORD PTR _ppAddress$[ebp]
	mov	ecx, DWORD PTR _pBufCtl$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+4]
	jb	SHORT $LN3@CBMovePtrF
$LN2@CBMovePtrF:

; 177  : 		return STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; c000000dH
	jmp	SHORT $LN5@CBMovePtrF
$LN3@CBMovePtrF:

; 178  : 
; 179  : 	*ppAddress += cbBytes;

	mov	eax, DWORD PTR _ppAddress$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _cbBytes$[ebp]
	mov	edx, DWORD PTR _ppAddress$[ebp]
	mov	DWORD PTR [edx], ecx

; 180  : 	if (*ppAddress >= pBufCtl->pBufEndAddr) {

	mov	eax, DWORD PTR _ppAddress$[ebp]
	mov	ecx, DWORD PTR _pBufCtl$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx+4]
	jb	SHORT $LN1@CBMovePtrF

; 181  : 		SIZE_T cbOverflow = *ppAddress - 
; 182  : 			pBufCtl->pBufEndAddr;

	mov	eax, DWORD PTR _ppAddress$[ebp]
	mov	ecx, DWORD PTR _pBufCtl$[ebp]
	mov	edx, DWORD PTR [eax]
	sub	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _cbOverflow$27689[ebp], edx

; 183  : 		// cbOverflow is the number of bytes that would fall past the 
; 184  : 		// end of the buffer.
; 185  : 
; 186  : 		*ppAddress = pBufCtl->pBufStartAddr + cbOverflow;

	mov	eax, DWORD PTR _pBufCtl$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _cbOverflow$27689[ebp]
	mov	edx, DWORD PTR _ppAddress$[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@CBMovePtrF:

; 187  : 	}
; 188  : 	return STATUS_SUCCESS;

	xor	eax, eax
$LN5@CBMovePtrF:

; 189  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?CBMovePtrForward@@YGJPAU_CIRCULAR_BUFFER@@PAPADK@Z ENDP ; CBMovePtrForward
_TEXT	ENDS
PUBLIC	??_C@_0MI@BMMJCGO@CB?5?9?5CBStore?5?9?5Storing?4?6?5?5?5?5Curr@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	?CBStore@@YGJPAU_CIRCULAR_BUFFER@@PAPADPAK22@Z	; CBStore
EXTRN	_memcpy:PROC
;	COMDAT ??_C@_0MI@BMMJCGO@CB?5?9?5CBStore?5?9?5Storing?4?6?5?5?5?5Curr@FNODOBFM@
text$s	SEGMENT
??_C@_0MI@BMMJCGO@CB?5?9?5CBStore?5?9?5Storing?4?6?5?5?5?5Curr@FNODOBFM@ DB 'C'
	DB	'B - CBStore - Storing.', 0aH, '    Current block start:      '
	DB	' %#p', 0aH, '    length (not counting hdr): %#x', 0aH, '    s'
	DB	'tore addr:                %#p', 0aH, '    store length:      '
	DB	'        %#x', 0aH, '    src addr:                  %#p', 0aH, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?CBStore@@YGJPAU_CIRCULAR_BUFFER@@PAPADPAK22@Z
_TEXT	SEGMENT
tv83 = -40						; size = 4
_i$27704 = -36						; size = 4
_cbContiguous$ = -32					; size = 4
_pHdrVar$ = -28						; size = 4
_pStoreAddr$ = -24					; size = 4
_cbStoreLen$ = -20					; size = 4
_block2ndChunkLen$ = -16				; size = 4
_curBlockHdr$ = -12					; size = 4
_pHdr$ = -8						; size = 4
_cbMaxStoreLen$ = -4					; size = 4
_pBuf$ = 8						; size = 4
_ppData$ = 12						; size = 4
_pcbLen$ = 16						; size = 4
_pcbOffset$ = 20					; size = 4
_pcbBytesStored$ = 24					; size = 4
?CBStore@@YGJPAU_CIRCULAR_BUFFER@@PAPADPAK22@Z PROC	; CBStore, COMDAT

; 200  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 201  : 	if (CBDataBufferEmpty(pBuf)) return STATUS_NO_MEMORY;

	mov	eax, DWORD PTR _pBuf$[ebp]
	push	eax
	call	?CBDataBufferEmpty@@YGEPAU_CIRCULAR_BUFFER@@@Z ; CBDataBufferEmpty
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@CBStore
	mov	eax, -1073741801			; c0000017H
	jmp	$LN10@CBStore
$LN9@CBStore:

; 202  : 
; 203  : 	CB_BLOCK_HEADER curBlockHdr;
; 204  : 
; 205  : 	// Extract the current block header. Advance a pointer into
; 206  : 	// the buffer with CBMovePtrForward, because the header can cross
; 207  : 	// the buffer end.
; 208  : 	//
; 209  : 	PCHAR pHdrVar = (PCHAR) &curBlockHdr;

	lea	edx, DWORD PTR _curBlockHdr$[ebp]
	mov	DWORD PTR _pHdrVar$[ebp], edx

; 210  : 	PCHAR pHdr = pBuf->pCurrentBlock;

	mov	eax, DWORD PTR _pBuf$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR _pHdr$[ebp], ecx

; 211  : 	for (INT i = 0; i < sizeof curBlockHdr; i++) {

	mov	DWORD PTR _i$27704[ebp], 0
	jmp	SHORT $LN8@CBStore
$LN7@CBStore:
	mov	edx, DWORD PTR _i$27704[ebp]
	add	edx, 1
	mov	DWORD PTR _i$27704[ebp], edx
$LN8@CBStore:
	cmp	DWORD PTR _i$27704[ebp], 4
	jae	SHORT $LN6@CBStore

; 212  : 		*(pHdrVar + i) = *pHdr;

	mov	eax, DWORD PTR _pHdrVar$[ebp]
	add	eax, DWORD PTR _i$27704[ebp]
	mov	ecx, DWORD PTR _pHdr$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 213  : 		CBMovePtrForward(pBuf, &pHdr, 1);

	push	1
	lea	eax, DWORD PTR _pHdr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	call	?CBMovePtrForward@@YGJPAU_CIRCULAR_BUFFER@@PAPADK@Z ; CBMovePtrForward

; 214  : 	}

	jmp	SHORT $LN7@CBStore
$LN6@CBStore:

; 215  : 
; 216  : 	if (*pcbOffset >= curBlockHdr.cbSize) 

	mov	edx, DWORD PTR _pcbOffset$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _curBlockHdr$[ebp]
	jb	SHORT $LN5@CBStore

; 217  : 		return STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; c000000dH
	jmp	$LN10@CBStore
$LN5@CBStore:

; 218  : 	// Compute the store address skipping the header and accounting for
; 219  : 	// the offset. Use CBMovePtrForward because we might be crossing
; 220  : 	// the buffer end.
; 221  : 	//
; 222  : 	PCHAR pStoreAddr = pBuf->pCurrentBlock;

	mov	ecx, DWORD PTR _pBuf$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR _pStoreAddr$[ebp], edx

; 223  : 	CBMovePtrForward(pBuf, &pStoreAddr, sizeof (CB_BLOCK_HEADER) +
; 224  : 		*pcbOffset);

	mov	eax, DWORD PTR _pcbOffset$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	push	ecx
	lea	edx, DWORD PTR _pStoreAddr$[ebp]
	push	edx
	mov	eax, DWORD PTR _pBuf$[ebp]
	push	eax
	call	?CBMovePtrForward@@YGJPAU_CIRCULAR_BUFFER@@PAPADK@Z ; CBMovePtrForward

; 225  : 	SIZE_T cbMaxStoreLen = curBlockHdr.cbSize - *pcbOffset;

	mov	ecx, DWORD PTR _pcbOffset$[ebp]
	mov	edx, DWORD PTR _curBlockHdr$[ebp]
	sub	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cbMaxStoreLen$[ebp], edx

; 226  : 	SIZE_T cbStoreLen = 
; 227  : 		*pcbLen < cbMaxStoreLen ? *pcbLen : cbMaxStoreLen ;

	mov	eax, DWORD PTR _pcbLen$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _cbMaxStoreLen$[ebp]
	jae	SHORT $LN12@CBStore
	mov	edx, DWORD PTR _pcbLen$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv83[ebp], eax
	jmp	SHORT $LN13@CBStore
$LN12@CBStore:
	mov	ecx, DWORD PTR _cbMaxStoreLen$[ebp]
	mov	DWORD PTR tv83[ebp], ecx
$LN13@CBStore:
	mov	edx, DWORD PTR tv83[ebp]
	mov	DWORD PTR _cbStoreLen$[ebp], edx

; 228  : 
; 229  : 
; 230  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 231  : 		     "CB - CBStore - Storing.\n"
; 232  : 	         "    Current block start:       %#p\n"
; 233  : 			 "    length (not counting hdr): %#x\n"
; 234  : 			 "    store addr:                %#p\n"
; 235  : 			 "    store length:              %#x\n"
; 236  : 			 "    src addr:                  %#p\n",
; 237  : 		pBuf->pCurrentBlock,
; 238  : 		curBlockHdr.cbSize, 
; 239  : 		pStoreAddr, 
; 240  : 		cbStoreLen, 
; 241  : 		*ppData);

	mov	eax, DWORD PTR _ppData$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _cbStoreLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _pStoreAddr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _curBlockHdr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pBuf$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	push	OFFSET ??_C@_0MI@BMMJCGO@CB?5?9?5CBStore?5?9?5Storing?4?6?5?5?5?5Curr@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 32					; 00000020H

; 242  : 
; 243  : 	// Store the data, accounting for the fact that it may wrap around
; 244  : 	// the buffer end.
; 245  : 	//
; 246  : 	// cbContiguous = length of the contiguous data area from pStoreAddr
; 247  : 	// up to the buffer end.
; 248  : 	//
; 249  : 	SIZE_T cbContiguous = pBuf->pBufEndAddr - pStoreAddr;

	mov	ecx, DWORD PTR _pBuf$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, DWORD PTR _pStoreAddr$[ebp]
	mov	DWORD PTR _cbContiguous$[ebp], edx

; 250  : 	SSIZE_T block2ndChunkLen = cbStoreLen - cbContiguous;

	mov	eax, DWORD PTR _cbStoreLen$[ebp]
	sub	eax, DWORD PTR _cbContiguous$[ebp]
	mov	DWORD PTR _block2ndChunkLen$[ebp], eax

; 251  : 
; 252  : 	// Note: if there are other data blocks before the buffer end 
; 253  : 	// address, cbContiguous > cbStoreLen for sure, because we have 
; 254  : 	// already limited cbStoreLen inside the current block.
; 255  : 
; 256  : 	if (block2ndChunkLen > 0) {

	cmp	DWORD PTR _block2ndChunkLen$[ebp], 0
	jle	SHORT $LN4@CBStore

; 257  : 
; 258  : 		// The data wraps around => two data tansfers.
; 259  : 		//
; 260  : 		RtlCopyMemory(pStoreAddr, *ppData, cbContiguous);

	mov	ecx, DWORD PTR _cbContiguous$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppData$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pStoreAddr$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 261  : 		RtlCopyMemory(pBuf->pBufStartAddr, (*ppData) + cbContiguous,
; 262  : 			block2ndChunkLen);

	mov	edx, DWORD PTR _block2ndChunkLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _ppData$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _cbContiguous$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pBuf$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 263  : 	} else {

	jmp	SHORT $LN3@CBStore
$LN4@CBStore:

; 264  : 		RtlCopyMemory(pStoreAddr, *ppData, cbStoreLen);

	mov	ecx, DWORD PTR _cbStoreLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _ppData$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _pStoreAddr$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@CBStore:

; 265  : 	}
; 266  : 	*ppData += cbStoreLen;

	mov	edx, DWORD PTR _ppData$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR _cbStoreLen$[ebp]
	mov	ecx, DWORD PTR _ppData$[ebp]
	mov	DWORD PTR [ecx], eax

; 267  : 	*pcbLen -= cbStoreLen;

	mov	edx, DWORD PTR _pcbLen$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, DWORD PTR _cbStoreLen$[ebp]
	mov	ecx, DWORD PTR _pcbLen$[ebp]
	mov	DWORD PTR [ecx], eax

; 268  : 	*pcbOffset += cbStoreLen;

	mov	edx, DWORD PTR _pcbOffset$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR _cbStoreLen$[ebp]
	mov	ecx, DWORD PTR _pcbOffset$[ebp]
	mov	DWORD PTR [ecx], eax

; 269  : 	if (pcbBytesStored != NULL) *pcbBytesStored = cbStoreLen;

	cmp	DWORD PTR _pcbBytesStored$[ebp], 0
	je	SHORT $LN2@CBStore
	mov	edx, DWORD PTR _pcbBytesStored$[ebp]
	mov	eax, DWORD PTR _cbStoreLen$[ebp]
	mov	DWORD PTR [edx], eax
$LN2@CBStore:

; 270  : 
; 271  : 	if (cbStoreLen < *pcbLen) return CB_STATUS_WARN_DATA_LOST;

	mov	ecx, DWORD PTR _pcbLen$[ebp]
	mov	edx, DWORD PTR _cbStoreLen$[ebp]
	cmp	edx, DWORD PTR [ecx]
	jae	SHORT $LN1@CBStore
	mov	eax, -1610612735			; a0000001H
	jmp	SHORT $LN10@CBStore
$LN1@CBStore:

; 272  : 
; 273  : 	return STATUS_SUCCESS;

	xor	eax, eax
$LN10@CBStore:

; 274  : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?CBStore@@YGJPAU_CIRCULAR_BUFFER@@PAPADPAK22@Z ENDP	; CBStore
_TEXT	ENDS
PUBLIC	??_C@_0NE@DJKLCAIL@CB?5?9?5CBXtractFromStart?5?9?5Xtracti@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	?CBXtractFromStart@@YGJPAU_CIRCULAR_BUFFER@@PAKPAPAD111@Z ; CBXtractFromStart
;	COMDAT ??_C@_0NE@DJKLCAIL@CB?5?9?5CBXtractFromStart?5?9?5Xtracti@FNODOBFM@
text$s	SEGMENT
??_C@_0NE@DJKLCAIL@CB?5?9?5CBXtractFromStart?5?9?5Xtracti@FNODOBFM@ DB 'C'
	DB	'B - CBXtractFromStart - Xtracting.', 0aH, '    current block '
	DB	'start:       %#p', 0aH, '    length (not counting hdr): %#x', 0aH
	DB	'    source:                    %#p', 0aH, '    dest:         '
	DB	'             %#p', 0aH, '    len:                       %#x', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?CBXtractFromStart@@YGJPAU_CIRCULAR_BUFFER@@PAKPAPAD111@Z
_TEXT	SEGMENT
tv80 = -40						; size = 4
_i$27736 = -36						; size = 4
_cbContiguous$ = -32					; size = 4
_pHdrVar$ = -28						; size = 4
_blkHdr$ = -24						; size = 4
_cbXLen$ = -20						; size = 4
_pXStart$ = -16						; size = 4
_block2ndChunkLen$ = -12				; size = 4
_cbAvailLen$ = -8					; size = 4
_pHdr$ = -4						; size = 4
_pBufCtl$ = 8						; size = 4
_pcbXtractOffset$ = 12					; size = 4
_ppDest$ = 16						; size = 4
_pcbDestFree$ = 20					; size = 4
_pcbBytesToRead$ = 24					; size = 4
_pcbBytesRead$ = 28					; size = 4
?CBXtractFromStart@@YGJPAU_CIRCULAR_BUFFER@@PAKPAPAD111@Z PROC ; CBXtractFromStart, COMDAT

; 285  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 286  : 	if (CBDataBufferEmpty(pBufCtl)) {

	mov	eax, DWORD PTR _pBufCtl$[ebp]
	push	eax
	call	?CBDataBufferEmpty@@YGEPAU_CIRCULAR_BUFFER@@@Z ; CBDataBufferEmpty
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN13@CBXtractFr

; 287  : 		return STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; c000000dH
	jmp	$LN14@CBXtractFr
$LN13@CBXtractFr:

; 288  : 	}
; 289  : 
; 290  : 	// Check that the offset is valid.
; 291  : 	//
; 292  : 	CB_BLOCK_HEADER blkHdr;
; 293  : 
; 294  : 	// Extract the block header. The pointer into the buffer is
; 295  : 	// advanced calling CBMovePtrForward to account for the fact that 
; 296  : 	// the header could wrap around the buffer end.
; 297  : 	//
; 298  : 	PCHAR pHdrVar = (PCHAR) &blkHdr;

	lea	edx, DWORD PTR _blkHdr$[ebp]
	mov	DWORD PTR _pHdrVar$[ebp], edx

; 299  : 	PCHAR pHdr = pBufCtl->pDataStart;

	mov	eax, DWORD PTR _pBufCtl$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _pHdr$[ebp], ecx

; 300  : 	for (INT i = 0; i < sizeof blkHdr; i++) {

	mov	DWORD PTR _i$27736[ebp], 0
	jmp	SHORT $LN12@CBXtractFr
$LN11@CBXtractFr:
	mov	edx, DWORD PTR _i$27736[ebp]
	add	edx, 1
	mov	DWORD PTR _i$27736[ebp], edx
$LN12@CBXtractFr:
	cmp	DWORD PTR _i$27736[ebp], 4
	jae	SHORT $LN10@CBXtractFr

; 301  : 		*(pHdrVar + i) = *pHdr;

	mov	eax, DWORD PTR _pHdrVar$[ebp]
	add	eax, DWORD PTR _i$27736[ebp]
	mov	ecx, DWORD PTR _pHdr$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR [eax], dl

; 302  : 		CBMovePtrForward(pBufCtl, &pHdr, 1);

	push	1
	lea	eax, DWORD PTR _pHdr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBufCtl$[ebp]
	push	ecx
	call	?CBMovePtrForward@@YGJPAU_CIRCULAR_BUFFER@@PAPADK@Z ; CBMovePtrForward

; 303  : 	}

	jmp	SHORT $LN11@CBXtractFr
$LN10@CBXtractFr:

; 304  : 
; 305  : 	if (*pcbXtractOffset >= blkHdr.cbSize) 

	mov	edx, DWORD PTR _pcbXtractOffset$[ebp]
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR _blkHdr$[ebp]
	jb	SHORT $LN9@CBXtractFr

; 306  : 		return STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; c000000dH
	jmp	$LN14@CBXtractFr
$LN9@CBXtractFr:

; 307  : 	// Compute the amount of data requested. cbXLen will be the 
; 308  : 	// extraction length, cbAvailLen the available bytes from
; 309  : 	// the offset to the block end.
; 310  : 	//
; 311  : 	SIZE_T cbXLen;
; 312  : 	SIZE_T cbAvailLen = blkHdr.cbSize - *pcbXtractOffset;

	mov	ecx, DWORD PTR _pcbXtractOffset$[ebp]
	mov	edx, DWORD PTR _blkHdr$[ebp]
	sub	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cbAvailLen$[ebp], edx

; 313  : 	if (pcbBytesToRead == NULL) {

	cmp	DWORD PTR _pcbBytesToRead$[ebp], 0
	jne	SHORT $LN8@CBXtractFr

; 314  : 
; 315  : 		// NULL means up to the end of the block.
; 316  : 		//
; 317  : 		cbXLen = cbAvailLen;

	mov	eax, DWORD PTR _cbAvailLen$[ebp]
	mov	DWORD PTR _cbXLen$[ebp], eax
	jmp	SHORT $LN7@CBXtractFr
$LN8@CBXtractFr:

; 318  : 	} else if (*pcbBytesToRead > cbAvailLen) {

	mov	ecx, DWORD PTR _pcbBytesToRead$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _cbAvailLen$[ebp]
	jbe	SHORT $LN6@CBXtractFr

; 319  : 		cbXLen = cbAvailLen;

	mov	eax, DWORD PTR _cbAvailLen$[ebp]
	mov	DWORD PTR _cbXLen$[ebp], eax

; 320  : 	} else {

	jmp	SHORT $LN7@CBXtractFr
$LN6@CBXtractFr:

; 321  : 		cbXLen = *pcbBytesToRead;

	mov	ecx, DWORD PTR _pcbBytesToRead$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR _cbXLen$[ebp], edx
$LN7@CBXtractFr:

; 322  : 	}
; 323  : 
; 324  : 	// Limit the amount of data based on *pcbDestFree.
; 325  : 	//
; 326  : 	cbXLen = (cbXLen < *pcbDestFree ? cbXLen : *pcbDestFree);

	mov	eax, DWORD PTR _pcbDestFree$[ebp]
	mov	ecx, DWORD PTR _cbXLen$[ebp]
	cmp	ecx, DWORD PTR [eax]
	jae	SHORT $LN16@CBXtractFr
	mov	edx, DWORD PTR _cbXLen$[ebp]
	mov	DWORD PTR tv80[ebp], edx
	jmp	SHORT $LN17@CBXtractFr
$LN16@CBXtractFr:
	mov	eax, DWORD PTR _pcbDestFree$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv80[ebp], ecx
$LN17@CBXtractFr:
	mov	edx, DWORD PTR tv80[ebp]
	mov	DWORD PTR _cbXLen$[ebp], edx

; 327  : 
; 328  : 	// Compute the start address skipping the header and taking the
; 329  : 	// offset into account. Use CBMovePtrForward(), because we might
; 330  : 	// be crossing the end of the buffer.
; 331  : 	//
; 332  : 	PCHAR pXStart = pBufCtl->pDataStart;

	mov	eax, DWORD PTR _pBufCtl$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _pXStart$[ebp], ecx

; 333  : 	CBMovePtrForward(pBufCtl, &pXStart, sizeof (CB_BLOCK_HEADER) +
; 334  : 		*pcbXtractOffset);

	mov	edx, DWORD PTR _pcbXtractOffset$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 4
	push	eax
	lea	ecx, DWORD PTR _pXStart$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pBufCtl$[ebp]
	push	edx
	call	?CBMovePtrForward@@YGJPAU_CIRCULAR_BUFFER@@PAPADK@Z ; CBMovePtrForward

; 335  : 
; 336  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 337  : 		"CB - CBXtractFromStart - Xtracting.\n"
; 338  : 		"    current block start:       %#p\n"
; 339  : 		"    length (not counting hdr): %#x\n"
; 340  : 		"    source:                    %#p\n"
; 341  : 		"    dest:                      %#p\n"
; 342  : 		"    len:                       %#x\n", 
; 343  : 		pBufCtl->pDataStart, 
; 344  : 		blkHdr.cbSize,
; 345  : 		pXStart,
; 346  : 		*ppDest,
; 347  : 		cbXLen);

	mov	eax, DWORD PTR _cbXLen$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ppDest$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _pXStart$[ebp]
	push	eax
	mov	ecx, DWORD PTR _blkHdr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pBufCtl$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	push	OFFSET ??_C@_0NE@DJKLCAIL@CB?5?9?5CBXtractFromStart?5?9?5Xtracti@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 32					; 00000020H

; 348  : 
; 349  : 	// Return the data, accounting for the fact that it may wrap around
; 350  : 	// the buffer end.
; 351  : 	//
; 352  : 	// cbContiguous = length of the contiguous data area from pXStart up
; 353  : 	// to the buffer end.
; 354  : 	//
; 355  : 	SIZE_T cbContiguous = pBufCtl->pBufEndAddr - pXStart;

	mov	ecx, DWORD PTR _pBufCtl$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, DWORD PTR _pXStart$[ebp]
	mov	DWORD PTR _cbContiguous$[ebp], edx

; 356  : 	SSIZE_T block2ndChunkLen = cbXLen - cbContiguous;

	mov	eax, DWORD PTR _cbXLen$[ebp]
	sub	eax, DWORD PTR _cbContiguous$[ebp]
	mov	DWORD PTR _block2ndChunkLen$[ebp], eax

; 357  : 
; 358  : 	// Note: if there are other data blocks before the buffer end 
; 359  : 	// address, cbContiguous > cbXLen for sure, because we have already
; 360  : 	// limited cbXLen inside the current block.
; 361  : 
; 362  : 	if (block2ndChunkLen > 0) {

	cmp	DWORD PTR _block2ndChunkLen$[ebp], 0
	jle	SHORT $LN4@CBXtractFr

; 363  : 
; 364  : 		// The data wraps around => two data tansfers.
; 365  : 		//
; 366  : 		RtlCopyMemory(*ppDest, pXStart, cbContiguous);

	mov	ecx, DWORD PTR _cbContiguous$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pXStart$[ebp]
	push	edx
	mov	eax, DWORD PTR _ppDest$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 367  : 		RtlCopyMemory((*ppDest) + cbContiguous, pBufCtl->pBufStartAddr,
; 368  : 			block2ndChunkLen);

	mov	edx, DWORD PTR _block2ndChunkLen$[ebp]
	push	edx
	mov	eax, DWORD PTR _pBufCtl$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _ppDest$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR _cbContiguous$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 369  : 	} else {

	jmp	SHORT $LN3@CBXtractFr
$LN4@CBXtractFr:

; 370  : 		RtlCopyMemory(*ppDest, pXStart, cbXLen);

	mov	ecx, DWORD PTR _cbXLen$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pXStart$[ebp]
	push	edx
	mov	eax, DWORD PTR _ppDest$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN3@CBXtractFr:

; 371  : 	}
; 372  : 	*pcbXtractOffset += cbXLen;

	mov	edx, DWORD PTR _pcbXtractOffset$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR _cbXLen$[ebp]
	mov	ecx, DWORD PTR _pcbXtractOffset$[ebp]
	mov	DWORD PTR [ecx], eax

; 373  : 	*ppDest += cbXLen;

	mov	edx, DWORD PTR _ppDest$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR _cbXLen$[ebp]
	mov	ecx, DWORD PTR _ppDest$[ebp]
	mov	DWORD PTR [ecx], eax

; 374  : 	*pcbDestFree -= cbXLen;

	mov	edx, DWORD PTR _pcbDestFree$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, DWORD PTR _cbXLen$[ebp]
	mov	ecx, DWORD PTR _pcbDestFree$[ebp]
	mov	DWORD PTR [ecx], eax

; 375  : 	if (pcbBytesToRead != NULL) *pcbBytesToRead -= cbXLen;

	cmp	DWORD PTR _pcbBytesToRead$[ebp], 0
	je	SHORT $LN2@CBXtractFr
	mov	edx, DWORD PTR _pcbBytesToRead$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, DWORD PTR _cbXLen$[ebp]
	mov	ecx, DWORD PTR _pcbBytesToRead$[ebp]
	mov	DWORD PTR [ecx], eax
$LN2@CBXtractFr:

; 376  : 	if (pcbBytesRead != NULL) *pcbBytesRead = cbXLen;

	cmp	DWORD PTR _pcbBytesRead$[ebp], 0
	je	SHORT $LN1@CBXtractFr
	mov	edx, DWORD PTR _pcbBytesRead$[ebp]
	mov	eax, DWORD PTR _cbXLen$[ebp]
	mov	DWORD PTR [edx], eax
$LN1@CBXtractFr:

; 377  : 	return STATUS_SUCCESS;

	xor	eax, eax
$LN14@CBXtractFr:

; 378  : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?CBXtractFromStart@@YGJPAU_CIRCULAR_BUFFER@@PAKPAPAD111@Z ENDP ; CBXtractFromStart
_TEXT	ENDS
END
