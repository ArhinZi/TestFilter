; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@NCBACJCG@IRP_MN_QUERY_POWER?$AA@	; `string'
PUBLIC	??_C@_0BB@MOFGLKAE@IRP_MN_SET_POWER?$AA@	; `string'
PUBLIC	??_C@_0BG@HJCHODFP@IRP_MN_POWER_SEQUENCE?$AA@	; `string'
PUBLIC	??_C@_0BB@KEEBPEDL@IRP_MN_WAIT_WAKE?$AA@	; `string'
PUBLIC	??_C@_0BI@JJMGKCHF@IRP_MN_SURPRISE_REMOVAL?$AA@	; `string'
PUBLIC	??_C@_0CB@EEGIBKLH@IRP_MN_DEVICE_USAGE_NOTIFICATION@ ; `string'
PUBLIC	??_C@_0BN@FKLLPNEA@IRP_MN_QUERY_BUS_INFORMATION?$AA@ ; `string'
PUBLIC	??_C@_0BO@CLJGNPDL@IRP_MN_QUERY_PNP_DEVICE_STATE?$AA@ ; `string'
PUBLIC	??_C@_0BA@MPOLLMHD@IRP_MN_QUERY_ID?$AA@		; `string'
PUBLIC	??_C@_0BA@JCIHPHAO@IRP_MN_SET_LOCK?$AA@		; `string'
PUBLIC	??_C@_0N@KBDCJDGM@IRP_MN_EJECT?$AA@		; `string'
PUBLIC	??_C@_0BE@MNGKLJHO@IRP_MN_WRITE_CONFIG?$AA@	; `string'
PUBLIC	??_C@_0BD@KCLCONNF@IRP_MN_READ_CONFIG?$AA@	; `string'
PUBLIC	??_C@_07CIFAGBMG@unknown?$AA@			; `string'
PUBLIC	??_C@_0CE@FFGNIHMK@IRP_MN_FILTER_RESOURCE_REQUIREME@ ; `string'
PUBLIC	??_C@_0BJ@KBKMPMKH@IRP_MN_QUERY_DEVICE_TEXT?$AA@ ; `string'
PUBLIC	??_C@_0CD@MPPOHAEF@IRP_MN_QUERY_RESOURCE_REQUIREMEN@ ; `string'
PUBLIC	??_C@_0BH@BAILDNEP@IRP_MN_QUERY_RESOURCES?$AA@	; `string'
PUBLIC	??_C@_0BK@FNPJPCCF@IRP_MN_QUERY_CAPABILITIES?$AA@ ; `string'
PUBLIC	??_C@_0BH@NJFMIPMO@IRP_MN_QUERY_INTERFACE?$AA@	; `string'
PUBLIC	??_C@_0BO@EDNJKJCF@IRP_MN_QUERY_DEVICE_RELATIONS?$AA@ ; `string'
PUBLIC	??_C@_0BK@IHBBLJPI@IRP_MN_CANCEL_STOP_DEVICE?$AA@ ; `string'
PUBLIC	??_C@_0BJ@DBBODAKD@IRP_MN_QUERY_STOP_DEVICE?$AA@ ; `string'
PUBLIC	??_C@_0BD@OKOEKPNG@IRP_MN_STOP_DEVICE?$AA@	; `string'
PUBLIC	??_C@_0BM@NHOBKHFC@IRP_MN_CANCEL_REMOVE_DEVICE?$AA@ ; `string'
PUBLIC	??_C@_0BF@CIDCHGNK@IRP_MN_REMOVE_DEVICE?$AA@	; `string'
PUBLIC	??_C@_0BL@BKMKKOEG@IRP_MN_QUERY_REMOVE_DEVICE?$AA@ ; `string'
PUBLIC	??_C@_0BE@LNOGIHJB@IRP_MN_START_DEVICE?$AA@	; `string'
PUBLIC	??_C@_0L@EACGAIIF@IRP_MJ_PNP?$AA@		; `string'
PUBLIC	??_C@_0BB@MFPKCKFI@IRP_MJ_SET_QUOTA?$AA@	; `string'
PUBLIC	??_C@_0BD@MDBGANBO@IRP_MJ_QUERY_QUOTA?$AA@	; `string'
PUBLIC	??_C@_0BF@HOMHCDN@IRP_MJ_DEVICE_CHANGE?$AA@	; `string'
PUBLIC	??_C@_0BG@JHIMGJML@IRP_MJ_SYSTEM_CONTROL?$AA@	; `string'
PUBLIC	??_C@_0N@BGEEMFOO@IRP_MJ_POWER?$AA@		; `string'
PUBLIC	??_C@_0BE@MPINJCAP@IRP_MJ_SET_SECURITY?$AA@	; `string'
PUBLIC	??_C@_0BG@MIODHPEN@IRP_MJ_QUERY_SECURITY?$AA@	; `string'
PUBLIC	??_C@_0BH@CKPKPKHL@IRP_MJ_CREATE_MAILSLOT?$AA@	; `string'
PUBLIC	??_C@_0P@JJLCIODE@IRP_MJ_CLEANUP?$AA@		; `string'
PUBLIC	??_C@_0BE@LODBBEFP@IRP_MJ_LOCK_CONTROL?$AA@	; `string'
PUBLIC	??_C@_0BA@CDMDNOAC@IRP_MJ_SHUTDOWN?$AA@		; `string'
PUBLIC	??_C@_0BP@ODEFGAEK@IRP_MJ_INTERNAL_DEVICE_CONTROL?$AA@ ; `string'
PUBLIC	??_C@_0BG@HAFCIBGJ@IRP_MJ_DEVICE_CONTROL?$AA@	; `string'
PUBLIC	??_C@_0BL@MFHGBIDL@IRP_MJ_FILE_SYSTEM_CONTROL?$AA@ ; `string'
PUBLIC	??_C@_0BJ@NCGIANAN@IRP_MJ_DIRECTORY_CONTROL?$AA@ ; `string'
PUBLIC	??_C@_0BO@CJJMMMF@IRP_MJ_SET_VOLUME_INFORMATION?$AA@ ; `string'
PUBLIC	??_C@_0CA@FDGJPBOD@IRP_MJ_QUERY_VOLUME_INFORMATION?$AA@ ; `string'
PUBLIC	??_C@_0BF@CBDAKCPM@IRP_MJ_FLUSH_BUFFERS?$AA@	; `string'
PUBLIC	??_C@_0O@FPNILENL@IRP_MJ_SET_EA?$AA@		; `string'
PUBLIC	??_C@_0BA@LFPMCNA@IRP_MJ_QUERY_EA?$AA@		; `string'
PUBLIC	??_C@_0BH@GNAPBNMO@IRP_MJ_SET_INFORMATION?$AA@	; `string'
PUBLIC	??_C@_0BJ@FPMLIFJJ@IRP_MJ_QUERY_INFORMATION?$AA@ ; `string'
PUBLIC	??_C@_0N@DLJAMLBI@IRP_MJ_WRITE?$AA@		; `string'
PUBLIC	??_C@_0M@LJKCMGIA@IRP_MJ_READ?$AA@		; `string'
PUBLIC	??_C@_0N@FMCDOLCP@IRP_MJ_CLOSE?$AA@		; `string'
PUBLIC	??_C@_0BJ@MMKIHFHH@IRP_MJ_CREATE_NAMED_PIPE?$AA@ ; `string'
PUBLIC	??_C@_0O@LCBLIIOL@IRP_MJ_CREATE?$AA@		; `string'
PUBLIC	InitializeListHead
PUBLIC	KeInitializeSpinLock
PUBLIC	RtlUnicodeStringPrintf
PUBLIC	RemoveEntryList
PUBLIC	IoSetCompletionRoutine
PUBLIC	IoGetNextIrpStackLocation
PUBLIC	IoCopyCurrentIrpStackLocationToNext
PUBLIC	IoSkipCurrentIrpStackLocation
PUBLIC	IoMarkIrpPending
PUBLIC	IsListEmpty
PUBLIC	RemoveHeadList
PUBLIC	InsertTailList
PUBLIC	RtlStringCbCopyA
PUBLIC	RtlStringCbPrintfA
PUBLIC	IoGetCurrentIrpStackLocation
PUBLIC	??_C@_0CJ@NOBCDHO@c?3?2apps?2pw7hp?2devpgm?2msddk?2inc?2d@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0FK@JAEDPCKJ@?$CIInvokeOnSuccess?5?$HM?$HM?5InvokeOnErro@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CI@HDMHMCGD@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	?pszMajorFunctionV@@3PAPEADA			; pszMajorFunctionV
PUBLIC	?pszPnpMinorFunctionV@@3PAPEADA			; pszPnpMinorFunctionV
PUBLIC	?pszPowerMinorFunctionV@@3PAPEADA		; pszPowerMinorFunctionV
PUBLIC	??_C@_08EEFIHIAN@11?308?319?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0M@DJNHNKNB@May?5?51?52013?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DL@ENFACENM@?6?6FLT?5?9?5DriverEntry?5?9?5Test?5filte@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DM@IFCHACPO@FLT?5?9?5DriverEntry?5?9?5Test?5filter?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CL@NAJACAOE@FLT?5?9?5AddDevice?5?9?5Entering?0?5pTar@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BG@DCLHEFJL@?$AAT?$AAe?$AAs?$AAt?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0ED@EDCCOAPN@FLT?5?9?5AddDevice?5?9?5Failed?5to?5crea@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DJ@MNLFKKDM@FLT?5?9?5AddDevice?5?9?5Failed?5to?5atta@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0GI@HKPAOEPB@FLT?5?9?5AddDevice?5?9?5Attached?5filte@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DG@MKCCCIDK@FLT?5?9?5AddDevice?5?9?5Failed?5to?5allo@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BG@BNCJKNLL@?$AAF?$AAi?$AAl?$AAt?$AAA?$AAc?$AAc?$AAe?$AAs?$AAs?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EK@HBPFAIIB@FLT?5?9?5AddDevice?5?9?5Failed?5to?5crea@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0ED@PAJPNGE@FLT?5?9?5AddDevice?5?9?5Filter?5access?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DF@CEGKGNGA@FLT?5?9?5AddDevice?5?9?5failed?$DL?5return@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0FG@NEABJAHD@FLT?5?9?5CheckMAReadPArams?5?9?5Client@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0GD@DEPIDMO@FLT?5?9?5CheckMAReadPArams?5?9?5Client@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BK@BKIFJHAA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AA?$CF?$AAs?$AA?$CF?$AAd?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BG@EDLFNGEH@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BC@MDHMAKOA@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$CF?$AAs?$AA?$CF?$AAd?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1O@PAJNNBDG@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EC@EDKPLCPO@FLT?5?9?5CreateDevice?5?9?5?5IoCreateDe@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EH@MBIPFAHB@FLT?5?9?5CreateDevice?5?9?5IoCreateSym@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DG@KJMBDFMO@FLT?5?9?5CreateDevice?5?9?5Failed?4?5Ret@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CG@DPMCLGJD@?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAM?$AAa?$AAs?$AAt?$AAe?$AAr?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CL@JPBGFCLD@FLT?5?9?5Failed?5to?5create?5the?5maste@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EI@HJAINLCB@FLT?5?9?5Master?5device?5created?4?5Dev@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_03JELKHEKI@?$CF?$CDx?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DN@OOMCMHGN@FLT?5?9?5FADispatchRead?5?9?5Client?5IR@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BF@DHECNBIC@DispatchFilteredRead?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CA@HIAJLNEM@?7offset?5?$DN?5?$CF?$CDI64x?6?7length?5?$DN?5?$CF?$CDx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BG@EAJEGOIB@DispatchFilteredWrite?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BE@LDBPDEFD@?7data?5length?5?$DN?5?$CF?$CDx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DG@FLIENFEL@FLT?5?9?5DpcCltIrpCompletion?5?9?5Clie@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CE@KKGIALML@FLT?5?9?5FACancel?5?9?5Entering?0?5IRP?5?$CF@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CL@DMKAKDEG@FLT?5?9?5FACancel?5?9?5Client?5IRP?5?$CF?$CDp?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CM@CDEFGHPM@FLT?5?9?5FADispatchDioc?5?9?5IOCTL?5cod@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EE@ODKHGKNO@FLT?5?9?5FAMainDispatch?5?9?5Client?5IR@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0N@NLMLMCJE@GenericTrace?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DJ@OOGMKJA@FLT?5?9?5GetReadData?5?9?5Read?5data?5ad@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EF@BMIAKKGE@FLT?5?9?5GetRWIrpBuffer?5?9?5MmGetSyst@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DO@BAPDNIJJ@FLT?5?9?5GetTargDevInfo?5?9?5Filter?3?5?$CF@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DL@GMEEJJEE@FLT?5?9?5GetWriteData?5?9?5Write?5data?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0N@IHJEBEEH@GTCompletion?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CF@GHKHGNKG@?7Status?5?$DN?5?$CF?$CD010x?6?7Information?5?$DN?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EK@OJJBHMCK@FLT?5?9?5InterceptIrpAndData?5?9?5Buff@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DN@KNINDNNC@FLT?5?9?5InterceptIrpAndData?5?9?5Stor@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0FA@GIHNANGK@FLT?5?9?5InterceptIrpAndData?5?9?5Stor@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EO@KNKPAAK@FLT?5?9?5InterceptIrpAndData?5?9?5Stor@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CL@KFEIBEJF@FLT?5?9?5MADispatchRead?5?9?5Entered?4?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EE@FCHCFMEI@FLT?5?9?5MAMainDispatch?5?9?5Client?5IR@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EC@MMEJNLGB@FLT?5?9?5MoveIrpDataToCltIrp?5?9?5Clie@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EB@GMMKCGII@FLT?5?9?5MoveIrpDataToCltIrp?5?9?5Pass@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EH@FIHPDACL@FLT?5?9?5QueueCltIrpForCompletion?5?9@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0P@HGOAEHOJ@ReadCompletion?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DC@JPOPAAME@FLT?5?9?5SendIrpDataToClt?5?9?5Client?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0IJ@HMLMAHPH@FLT?5?9?5?$CFs?5?9?5Tracing?5IRP?5?$CF?$CDp?6?7Majo@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_KeInitializeDpc:PROC
EXTRN	__imp_ExAllocatePoolWithTag:PROC
EXTRN	__imp_IoAttachDeviceToDeviceStack:PROC
EXTRN	__imp_IoDetachDevice:PROC
EXTRN	__imp_KeInitializeEvent:PROC
EXTRN	__imp_ExFreePoolWithTag:PROC
EXTRN	__imp_IoAllocateIrp:PROC
EXTRN	__imp_IoFreeIrp:PROC
EXTRN	__imp_IoReuseIrp:PROC
EXTRN	__imp_KeClearEvent:PROC
EXTRN	__imp_KeWaitForSingleObject:PROC
EXTRN	__imp_KeSetEvent:PROC
EXTRN	__imp_IoCreateDevice:PROC
EXTRN	__imp_IoCreateSymbolicLink:PROC
EXTRN	__imp_IoDeleteDevice:PROC
EXTRN	__imp__vsnwprintf:PROC
EXTRN	__imp_IoReleaseCancelSpinLock:PROC
EXTRN	__imp_PoCallDriver:PROC
EXTRN	__imp_IofCallDriver:PROC
EXTRN	__imp_KeAcquireInStackQueuedSpinLock:PROC
EXTRN	__imp_KeReleaseInStackQueuedSpinLock:PROC
EXTRN	__imp_PoStartNextPowerIrp:PROC
EXTRN	__imp_KeInsertQueueDpc:PROC
EXTRN	__imp__vsnprintf:PROC
EXTRN	__imp_IofCompleteRequest:PROC
EXTRN	__imp_RtlAssert:PROC
EXTRN	__imp_DbgPrintEx:PROC
EXTRN	__imp_MmMapLockedPagesSpecifyCache:PROC
DevNumber DD	01H DUP (?)
	ALIGN	8

pMastDevExt DQ	01H DUP (?)
;	COMDAT ??_C@_0IJ@HMLMAHPH@FLT?5?9?5?$CFs?5?9?5Tracing?5IRP?5?$CF?$CDp?6?7Majo@FNODOBFM@
text$s	SEGMENT
??_C@_0IJ@HMLMAHPH@FLT?5?9?5?$CFs?5?9?5Tracing?5IRP?5?$CF?$CDp?6?7Majo@FNODOBFM@ DB 'F'
	DB	'LT - %s - Tracing IRP %#p', 0aH, 09H, 'MajorFunction = %s', 0aH
	DB	09H, 'MinorFunction = %s', 0aH, 09H, 'Filter %#p', 0aH, 09H, 't'
	DB	'arget text    %S', 0aH, 09H, 'target HW ID   %S', 0aH, 09H, 't'
	DB	'arget inst ID %S', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DC@JPOPAAME@FLT?5?9?5SendIrpDataToClt?5?9?5Client?5@FNODOBFM@
text$s	SEGMENT
??_C@_0DC@JPOPAAME@FLT?5?9?5SendIrpDataToClt?5?9?5Client?5@FNODOBFM@ DB 'F'
	DB	'LT - SendIrpDataToClt - Client IRP %#p dequeued', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0P@HGOAEHOJ@ReadCompletion?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0P@HGOAEHOJ@ReadCompletion?$AA@FNODOBFM@ DB 'ReadCompletion', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EH@FIHPDACL@FLT?5?9?5QueueCltIrpForCompletion?5?9@FNODOBFM@
text$s	SEGMENT
??_C@_0EH@FIHPDACL@FLT?5?9?5QueueCltIrpForCompletion?5?9@FNODOBFM@ DB 'FL'
	DB	'T - QueueCltIrpForCompletion - Client IRP %#p queued for comp'
	DB	'letion', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EB@GMMKCGII@FLT?5?9?5MoveIrpDataToCltIrp?5?9?5Pass@FNODOBFM@
text$s	SEGMENT
??_C@_0EB@GMMKCGII@FLT?5?9?5MoveIrpDataToCltIrp?5?9?5Pass@FNODOBFM@ DB 'F'
	DB	'LT - MoveIrpDataToCltIrp - Passed %#x bytes of data to IRP %#'
	DB	'p', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EC@MMEJNLGB@FLT?5?9?5MoveIrpDataToCltIrp?5?9?5Clie@FNODOBFM@
text$s	SEGMENT
??_C@_0EC@MMEJNLGB@FLT?5?9?5MoveIrpDataToCltIrp?5?9?5Clie@FNODOBFM@ DB 'F'
	DB	'LT - MoveIrpDataToCltIrp - Client IRP %#p: buffer %#p, len: %'
	DB	'#x', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EE@FCHCFMEI@FLT?5?9?5MAMainDispatch?5?9?5Client?5IR@FNODOBFM@
text$s	SEGMENT
??_C@_0EE@FCHCFMEI@FLT?5?9?5MAMainDispatch?5?9?5Client?5IR@FNODOBFM@ DB 'F'
	DB	'LT - MAMainDispatch - Client IRP %#p completed with status %#'
	DB	'010x', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CL@KFEIBEJF@FLT?5?9?5MADispatchRead?5?9?5Entered?4?5@FNODOBFM@
text$s	SEGMENT
??_C@_0CL@KFEIBEJF@FLT?5?9?5MADispatchRead?5?9?5Entered?4?5@FNODOBFM@ DB 'F'
	DB	'LT - MADispatchRead - Entered. pIrp = %#p', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EO@KNKPAAK@FLT?5?9?5InterceptIrpAndData?5?9?5Stor@FNODOBFM@
text$s	SEGMENT
??_C@_0EO@KNKPAAK@FLT?5?9?5InterceptIrpAndData?5?9?5Stor@FNODOBFM@ DB 'FL'
	DB	'T - InterceptIrpAndData - Storing %#x bytes of data at %#p in'
	DB	'to the buffer', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0FA@GIHNANGK@FLT?5?9?5InterceptIrpAndData?5?9?5Stor@FNODOBFM@
text$s	SEGMENT
??_C@_0FA@GIHNANGK@FLT?5?9?5InterceptIrpAndData?5?9?5Stor@FNODOBFM@ DB 'F'
	DB	'LT - InterceptIrpAndData - Storing current stack location %#p'
	DB	' into the buffer', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DN@KNINDNNC@FLT?5?9?5InterceptIrpAndData?5?9?5Stor@FNODOBFM@
text$s	SEGMENT
??_C@_0DN@KNINDNNC@FLT?5?9?5InterceptIrpAndData?5?9?5Stor@FNODOBFM@ DB 'F'
	DB	'LT - InterceptIrpAndData - Storing IRP %#p into the buffer', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EK@OJJBHMCK@FLT?5?9?5InterceptIrpAndData?5?9?5Buff@FNODOBFM@
text$s	SEGMENT
??_C@_0EK@OJJBHMCK@FLT?5?9?5InterceptIrpAndData?5?9?5Buff@FNODOBFM@ DB 'F'
	DB	'LT - InterceptIrpAndData - Buffer allocation failed with stat'
	DB	'us: %#010x', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CF@GHKHGNKG@?7Status?5?$DN?5?$CF?$CD010x?6?7Information?5?$DN?5@FNODOBFM@
text$s	SEGMENT
??_C@_0CF@GHKHGNKG@?7Status?5?$DN?5?$CF?$CD010x?6?7Information?5?$DN?5@FNODOBFM@ DB 09H
	DB	'Status = %#010x', 0aH, 09H, 'Information = %#x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0N@IHJEBEEH@GTCompletion?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0N@IHJEBEEH@GTCompletion?$AA@FNODOBFM@ DB 'GTCompletion', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DL@GMEEJJEE@FLT?5?9?5GetWriteData?5?9?5Write?5data?5@FNODOBFM@
text$s	SEGMENT
??_C@_0DL@GMEEJJEE@FLT?5?9?5GetWriteData?5?9?5Write?5data?5@FNODOBFM@ DB 'F'
	DB	'LT - GetWriteData - Write data address: %#p, length: %#x', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DO@BAPDNIJJ@FLT?5?9?5GetTargDevInfo?5?9?5Filter?3?5?$CF@FNODOBFM@
text$s	SEGMENT
??_C@_0DO@BAPDNIJJ@FLT?5?9?5GetTargDevInfo?5?9?5Filter?3?5?$CF@FNODOBFM@ DB 'F'
	DB	'LT - GetTargDevInfo - Filter: %#x, FA: %#x, device text: %S', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EF@BMIAKKGE@FLT?5?9?5GetRWIrpBuffer?5?9?5MmGetSyst@FNODOBFM@
text$s	SEGMENT
??_C@_0EF@BMIAKKGE@FLT?5?9?5GetRWIrpBuffer?5?9?5MmGetSyst@FNODOBFM@ DB 'F'
	DB	'LT - GetRWIrpBuffer - MmGetSystemAddressForMdlSafe() returned'
	DB	' NULL', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DJ@OOGMKJA@FLT?5?9?5GetReadData?5?9?5Read?5data?5ad@FNODOBFM@
text$s	SEGMENT
??_C@_0DJ@OOGMKJA@FLT?5?9?5GetReadData?5?9?5Read?5data?5ad@FNODOBFM@ DB 'F'
	DB	'LT - GetReadData - Read data address: %#p, length: %#x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0N@NLMLMCJE@GenericTrace?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0N@NLMLMCJE@GenericTrace?$AA@FNODOBFM@ DB 'GenericTrace', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EE@ODKHGKNO@FLT?5?9?5FAMainDispatch?5?9?5Client?5IR@FNODOBFM@
text$s	SEGMENT
??_C@_0EE@ODKHGKNO@FLT?5?9?5FAMainDispatch?5?9?5Client?5IR@FNODOBFM@ DB 'F'
	DB	'LT - FAMainDispatch - Client IRP %#p completed with status %#'
	DB	'010x', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CM@CDEFGHPM@FLT?5?9?5FADispatchDioc?5?9?5IOCTL?5cod@FNODOBFM@
text$s	SEGMENT
??_C@_0CM@CDEFGHPM@FLT?5?9?5FADispatchDioc?5?9?5IOCTL?5cod@FNODOBFM@ DB 'F'
	DB	'LT - FADispatchDioc - IOCTL code = %#010x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CL@DMKAKDEG@FLT?5?9?5FACancel?5?9?5Client?5IRP?5?$CF?$CDp?5@FNODOBFM@
text$s	SEGMENT
??_C@_0CL@DMKAKDEG@FLT?5?9?5FACancel?5?9?5Client?5IRP?5?$CF?$CDp?5@FNODOBFM@ DB 'F'
	DB	'LT - FACancel - Client IRP %#p cancelled', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CE@KKGIALML@FLT?5?9?5FACancel?5?9?5Entering?0?5IRP?5?$CF@FNODOBFM@
text$s	SEGMENT
??_C@_0CE@KKGIALML@FLT?5?9?5FACancel?5?9?5Entering?0?5IRP?5?$CF@FNODOBFM@ DB 'F'
	DB	'LT - FACancel - Entering, IRP %#p', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DG@FLIENFEL@FLT?5?9?5DpcCltIrpCompletion?5?9?5Clie@FNODOBFM@
text$s	SEGMENT
??_C@_0DG@FLIENFEL@FLT?5?9?5DpcCltIrpCompletion?5?9?5Clie@FNODOBFM@ DB 'F'
	DB	'LT - DpcCltIrpCompletion - Client Irp %#p completed', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BE@LDBPDEFD@?7data?5length?5?$DN?5?$CF?$CDx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BE@LDBPDEFD@?7data?5length?5?$DN?5?$CF?$CDx?6?$AA@FNODOBFM@ DB 09H
	DB	'data length = %#x', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BG@EAJEGOIB@DispatchFilteredWrite?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BG@EAJEGOIB@DispatchFilteredWrite?$AA@FNODOBFM@ DB 'DispatchFilter'
	DB	'edWrite', 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CA@HIAJLNEM@?7offset?5?$DN?5?$CF?$CDI64x?6?7length?5?$DN?5?$CF?$CDx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0CA@HIAJLNEM@?7offset?5?$DN?5?$CF?$CDI64x?6?7length?5?$DN?5?$CF?$CDx?6?$AA@FNODOBFM@ DB 09H
	DB	'offset = %#I64x', 0aH, 09H, 'length = %#x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BF@DHECNBIC@DispatchFilteredRead?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BF@DHECNBIC@DispatchFilteredRead?$AA@FNODOBFM@ DB 'DispatchFiltere'
	DB	'dRead', 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DN@OOMCMHGN@FLT?5?9?5FADispatchRead?5?9?5Client?5IR@FNODOBFM@
text$s	SEGMENT
??_C@_0DN@OOMCMHGN@FLT?5?9?5FADispatchRead?5?9?5Client?5IR@FNODOBFM@ DB 'F'
	DB	'LT - FADispatchRead - Client IRP %#p queued for processing', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_03JELKHEKI@?$CF?$CDx?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_03JELKHEKI@?$CF?$CDx?$AA@FNODOBFM@ DB '%#x', 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EI@HJAINLCB@FLT?5?9?5Master?5device?5created?4?5Dev@FNODOBFM@
text$s	SEGMENT
??_C@_0EI@HJAINLCB@FLT?5?9?5Master?5device?5created?4?5Dev@FNODOBFM@ DB 'F'
	DB	'LT - Master device created. Device object: %#p, device extens'
	DB	'ion: %#x', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CL@JPBGFCLD@FLT?5?9?5Failed?5to?5create?5the?5maste@FNODOBFM@
text$s	SEGMENT
??_C@_0CL@JPBGFCLD@FLT?5?9?5Failed?5to?5create?5the?5maste@FNODOBFM@ DB 'F'
	DB	'LT - Failed to create the master device.', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CG@DPMCLGJD@?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAM?$AAa?$AAs?$AAt?$AAe?$AAr?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CG@DPMCLGJD@?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAM?$AAa?$AAs?$AAt?$AAe?$AAr?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@ DB 'F'
	DB	00H, 'i', 00H, 'l', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'M', 00H
	DB	'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'D', 00H, 'e'
	DB	00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DG@KJMBDFMO@FLT?5?9?5CreateDevice?5?9?5Failed?4?5Ret@FNODOBFM@
text$s	SEGMENT
??_C@_0DG@KJMBDFMO@FLT?5?9?5CreateDevice?5?9?5Failed?4?5Ret@FNODOBFM@ DB 'F'
	DB	'LT - CreateDevice - Failed. Returning status %#010x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EH@MBIPFAHB@FLT?5?9?5CreateDevice?5?9?5IoCreateSym@FNODOBFM@
text$s	SEGMENT
??_C@_0EH@MBIPFAHB@FLT?5?9?5CreateDevice?5?9?5IoCreateSym@FNODOBFM@ DB 'F'
	DB	'LT - CreateDevice - IoCreateSymbolicLink() failed with status'
	DB	' %#010x', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EC@EDKPLCPO@FLT?5?9?5CreateDevice?5?9?5?5IoCreateDe@FNODOBFM@
text$s	SEGMENT
??_C@_0EC@EDKPLCPO@FLT?5?9?5CreateDevice?5?9?5?5IoCreateDe@FNODOBFM@ DB 'F'
	DB	'LT - CreateDevice -  IoCreateDevice() failed with status %#01'
	DB	'0x', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1O@PAJNNBDG@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1O@PAJNNBDG@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, '?', 00H, '?', 00H, '\', 00H, '%', 00H, 's', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BC@MDHMAKOA@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$CF?$AAs?$AA?$CF?$AAd?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BC@MDHMAKOA@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$CF?$AAs?$AA?$CF?$AAd?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, '?', 00H, '?', 00H, '\', 00H, '%', 00H, 's', 00H, '%', 00H
	DB	'd', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BG@EDLFNGEH@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BG@EDLFNGEH@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, '%', 00H, 's', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BK@BKIFJHAA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AA?$CF?$AAs?$AA?$CF?$AAd?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BK@BKIFJHAA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AA?$CF?$AAs?$AA?$CF?$AAd?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, '%', 00H, 's', 00H, '%', 00H, 'd', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0GD@DEPIDMO@FLT?5?9?5CheckMAReadPArams?5?9?5Client@FNODOBFM@
text$s	SEGMENT
??_C@_0GD@DEPIDMO@FLT?5?9?5CheckMAReadPArams?5?9?5Client@FNODOBFM@ DB 'FL'
	DB	'T - CheckMAReadPArams - Client buffer not aligned; required a'
	DB	'lignment: %#x, buffer address: %#p', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0FG@NEABJAHD@FLT?5?9?5CheckMAReadPArams?5?9?5Client@FNODOBFM@
text$s	SEGMENT
??_C@_0FG@NEABJAHD@FLT?5?9?5CheckMAReadPArams?5?9?5Client@FNODOBFM@ DB 'F'
	DB	'LT - CheckMAReadPArams - Client buffer too small; minimum req'
	DB	'uired: %d, current: %d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DF@CEGKGNGA@FLT?5?9?5AddDevice?5?9?5failed?$DL?5return@FNODOBFM@
text$s	SEGMENT
??_C@_0DF@CEGKGNGA@FLT?5?9?5AddDevice?5?9?5failed?$DL?5return@FNODOBFM@ DB 'F'
	DB	'LT - AddDevice - failed; returning status = %#010x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0ED@PAJPNGE@FLT?5?9?5AddDevice?5?9?5Filter?5access?5@FNODOBFM@
text$s	SEGMENT
??_C@_0ED@PAJPNGE@FLT?5?9?5AddDevice?5?9?5Filter?5access?5@FNODOBFM@ DB 'F'
	DB	'LT - AddDevice - Filter access device created: %#p; dev ext: '
	DB	'%#p', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EK@HBPFAIIB@FLT?5?9?5AddDevice?5?9?5Failed?5to?5crea@FNODOBFM@
text$s	SEGMENT
??_C@_0EK@HBPFAIIB@FLT?5?9?5AddDevice?5?9?5Failed?5to?5crea@FNODOBFM@ DB 'F'
	DB	'LT - AddDevice - Failed to create filter access dev with stat'
	DB	'us: %#010x', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BG@BNCJKNLL@?$AAF?$AAi?$AAl?$AAt?$AAA?$AAc?$AAc?$AAe?$AAs?$AAs?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BG@BNCJKNLL@?$AAF?$AAi?$AAl?$AAt?$AAA?$AAc?$AAc?$AAe?$AAs?$AAs?$AA?$AA@FNODOBFM@ DB 'F'
	DB	00H, 'i', 00H, 'l', 00H, 't', 00H, 'A', 00H, 'c', 00H, 'c', 00H
	DB	'e', 00H, 's', 00H, 's', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DG@MKCCCIDK@FLT?5?9?5AddDevice?5?9?5Failed?5to?5allo@FNODOBFM@
text$s	SEGMENT
??_C@_0DG@MKCCCIDK@FLT?5?9?5AddDevice?5?9?5Failed?5to?5allo@FNODOBFM@ DB 'F'
	DB	'LT - AddDevice - Failed to allocate the data buffer', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0GI@HKPAOEPB@FLT?5?9?5AddDevice?5?9?5Attached?5filte@FNODOBFM@
text$s	SEGMENT
??_C@_0GI@HKPAOEPB@FLT?5?9?5AddDevice?5?9?5Attached?5filte@FNODOBFM@ DB 'F'
	DB	'LT - AddDevice - Attached filter', 0aH, '    filter:        %'
	DB	'#p', 0aH, '    target device: %#p', 0aH, '    target stack:  '
	DB	'%#p', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DJ@MNLFKKDM@FLT?5?9?5AddDevice?5?9?5Failed?5to?5atta@FNODOBFM@
text$s	SEGMENT
??_C@_0DJ@MNLFKKDM@FLT?5?9?5AddDevice?5?9?5Failed?5to?5atta@FNODOBFM@ DB 'F'
	DB	'LT - AddDevice - Failed to attach filter to device %#p', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0ED@EDCCOAPN@FLT?5?9?5AddDevice?5?9?5Failed?5to?5crea@FNODOBFM@
text$s	SEGMENT
??_C@_0ED@EDCCOAPN@FLT?5?9?5AddDevice?5?9?5Failed?5to?5crea@FNODOBFM@ DB 'F'
	DB	'LT - AddDevice - Failed to create filter dev with status: %#0'
	DB	'10x', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BG@DCLHEFJL@?$AAT?$AAe?$AAs?$AAt?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BG@DCLHEFJL@?$AAT?$AAe?$AAs?$AAt?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'e', 00H, 's', 00H, 't', 00H, 'F', 00H, 'i', 00H, 'l', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CL@NAJACAOE@FLT?5?9?5AddDevice?5?9?5Entering?0?5pTar@FNODOBFM@
text$s	SEGMENT
??_C@_0CL@NAJACAOE@FLT?5?9?5AddDevice?5?9?5Entering?0?5pTar@FNODOBFM@ DB 'F'
	DB	'LT - AddDevice - Entering, pTargDev: %#p', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DM@IFCHACPO@FLT?5?9?5DriverEntry?5?9?5Test?5filter?5@FNODOBFM@
text$s	SEGMENT
??_C@_0DM@IFCHACPO@FLT?5?9?5DriverEntry?5?9?5Test?5filter?5@FNODOBFM@ DB 'F'
	DB	'LT - DriverEntry - Test filter driver succesfully loaded.', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DL@ENFACENM@?6?6FLT?5?9?5DriverEntry?5?9?5Test?5filte@FNODOBFM@
text$s	SEGMENT
??_C@_0DL@ENFACENM@?6?6FLT?5?9?5DriverEntry?5?9?5Test?5filte@FNODOBFM@ DB 0aH
	DB	0aH, 'FLT - DriverEntry - Test filter driver, compiled %s %s', 0aH
	DB	0aH, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0M@DJNHNKNB@May?5?51?52013?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0M@DJNHNKNB@May?5?51?52013?$AA@FNODOBFM@ DB 'May  1 2013', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_08EEFIHIAN@11?308?319?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_08EEFIHIAN@11?308?319?$AA@FNODOBFM@ DB '11:08:19', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BD@NCBACJCG@IRP_MN_QUERY_POWER?$AA@
CONST	SEGMENT
??_C@_0BD@NCBACJCG@IRP_MN_QUERY_POWER?$AA@ DB 'IRP_MN_QUERY_POWER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MOFGLKAE@IRP_MN_SET_POWER?$AA@
CONST	SEGMENT
??_C@_0BB@MOFGLKAE@IRP_MN_SET_POWER?$AA@ DB 'IRP_MN_SET_POWER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HJCHODFP@IRP_MN_POWER_SEQUENCE?$AA@
CONST	SEGMENT
??_C@_0BG@HJCHODFP@IRP_MN_POWER_SEQUENCE?$AA@ DB 'IRP_MN_POWER_SEQUENCE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KEEBPEDL@IRP_MN_WAIT_WAKE?$AA@
CONST	SEGMENT
??_C@_0BB@KEEBPEDL@IRP_MN_WAIT_WAKE?$AA@ DB 'IRP_MN_WAIT_WAKE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JJMGKCHF@IRP_MN_SURPRISE_REMOVAL?$AA@
CONST	SEGMENT
??_C@_0BI@JJMGKCHF@IRP_MN_SURPRISE_REMOVAL?$AA@ DB 'IRP_MN_SURPRISE_REMOV'
	DB	'AL', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EEGIBKLH@IRP_MN_DEVICE_USAGE_NOTIFICATION@
CONST	SEGMENT
??_C@_0CB@EEGIBKLH@IRP_MN_DEVICE_USAGE_NOTIFICATION@ DB 'IRP_MN_DEVICE_US'
	DB	'AGE_NOTIFICATION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FKLLPNEA@IRP_MN_QUERY_BUS_INFORMATION?$AA@
CONST	SEGMENT
??_C@_0BN@FKLLPNEA@IRP_MN_QUERY_BUS_INFORMATION?$AA@ DB 'IRP_MN_QUERY_BUS'
	DB	'_INFORMATION', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CLJGNPDL@IRP_MN_QUERY_PNP_DEVICE_STATE?$AA@
CONST	SEGMENT
??_C@_0BO@CLJGNPDL@IRP_MN_QUERY_PNP_DEVICE_STATE?$AA@ DB 'IRP_MN_QUERY_PN'
	DB	'P_DEVICE_STATE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MPOLLMHD@IRP_MN_QUERY_ID?$AA@
CONST	SEGMENT
??_C@_0BA@MPOLLMHD@IRP_MN_QUERY_ID?$AA@ DB 'IRP_MN_QUERY_ID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JCIHPHAO@IRP_MN_SET_LOCK?$AA@
CONST	SEGMENT
??_C@_0BA@JCIHPHAO@IRP_MN_SET_LOCK?$AA@ DB 'IRP_MN_SET_LOCK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KBDCJDGM@IRP_MN_EJECT?$AA@
CONST	SEGMENT
??_C@_0N@KBDCJDGM@IRP_MN_EJECT?$AA@ DB 'IRP_MN_EJECT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MNGKLJHO@IRP_MN_WRITE_CONFIG?$AA@
CONST	SEGMENT
??_C@_0BE@MNGKLJHO@IRP_MN_WRITE_CONFIG?$AA@ DB 'IRP_MN_WRITE_CONFIG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KCLCONNF@IRP_MN_READ_CONFIG?$AA@
CONST	SEGMENT
??_C@_0BD@KCLCONNF@IRP_MN_READ_CONFIG?$AA@ DB 'IRP_MN_READ_CONFIG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CIFAGBMG@unknown?$AA@
CONST	SEGMENT
??_C@_07CIFAGBMG@unknown?$AA@ DB 'unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FFGNIHMK@IRP_MN_FILTER_RESOURCE_REQUIREME@
CONST	SEGMENT
??_C@_0CE@FFGNIHMK@IRP_MN_FILTER_RESOURCE_REQUIREME@ DB 'IRP_MN_FILTER_RE'
	DB	'SOURCE_REQUIREMENTS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KBKMPMKH@IRP_MN_QUERY_DEVICE_TEXT?$AA@
CONST	SEGMENT
??_C@_0BJ@KBKMPMKH@IRP_MN_QUERY_DEVICE_TEXT?$AA@ DB 'IRP_MN_QUERY_DEVICE_'
	DB	'TEXT', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MPPOHAEF@IRP_MN_QUERY_RESOURCE_REQUIREMEN@
CONST	SEGMENT
??_C@_0CD@MPPOHAEF@IRP_MN_QUERY_RESOURCE_REQUIREMEN@ DB 'IRP_MN_QUERY_RES'
	DB	'OURCE_REQUIREMENTS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BAILDNEP@IRP_MN_QUERY_RESOURCES?$AA@
CONST	SEGMENT
??_C@_0BH@BAILDNEP@IRP_MN_QUERY_RESOURCES?$AA@ DB 'IRP_MN_QUERY_RESOURCES'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FNPJPCCF@IRP_MN_QUERY_CAPABILITIES?$AA@
CONST	SEGMENT
??_C@_0BK@FNPJPCCF@IRP_MN_QUERY_CAPABILITIES?$AA@ DB 'IRP_MN_QUERY_CAPABI'
	DB	'LITIES', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NJFMIPMO@IRP_MN_QUERY_INTERFACE?$AA@
CONST	SEGMENT
??_C@_0BH@NJFMIPMO@IRP_MN_QUERY_INTERFACE?$AA@ DB 'IRP_MN_QUERY_INTERFACE'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EDNJKJCF@IRP_MN_QUERY_DEVICE_RELATIONS?$AA@
CONST	SEGMENT
??_C@_0BO@EDNJKJCF@IRP_MN_QUERY_DEVICE_RELATIONS?$AA@ DB 'IRP_MN_QUERY_DE'
	DB	'VICE_RELATIONS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IHBBLJPI@IRP_MN_CANCEL_STOP_DEVICE?$AA@
CONST	SEGMENT
??_C@_0BK@IHBBLJPI@IRP_MN_CANCEL_STOP_DEVICE?$AA@ DB 'IRP_MN_CANCEL_STOP_'
	DB	'DEVICE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DBBODAKD@IRP_MN_QUERY_STOP_DEVICE?$AA@
CONST	SEGMENT
??_C@_0BJ@DBBODAKD@IRP_MN_QUERY_STOP_DEVICE?$AA@ DB 'IRP_MN_QUERY_STOP_DE'
	DB	'VICE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OKOEKPNG@IRP_MN_STOP_DEVICE?$AA@
CONST	SEGMENT
??_C@_0BD@OKOEKPNG@IRP_MN_STOP_DEVICE?$AA@ DB 'IRP_MN_STOP_DEVICE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NHOBKHFC@IRP_MN_CANCEL_REMOVE_DEVICE?$AA@
CONST	SEGMENT
??_C@_0BM@NHOBKHFC@IRP_MN_CANCEL_REMOVE_DEVICE?$AA@ DB 'IRP_MN_CANCEL_REM'
	DB	'OVE_DEVICE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CIDCHGNK@IRP_MN_REMOVE_DEVICE?$AA@
CONST	SEGMENT
??_C@_0BF@CIDCHGNK@IRP_MN_REMOVE_DEVICE?$AA@ DB 'IRP_MN_REMOVE_DEVICE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BKMKKOEG@IRP_MN_QUERY_REMOVE_DEVICE?$AA@
CONST	SEGMENT
??_C@_0BL@BKMKKOEG@IRP_MN_QUERY_REMOVE_DEVICE?$AA@ DB 'IRP_MN_QUERY_REMOV'
	DB	'E_DEVICE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LNOGIHJB@IRP_MN_START_DEVICE?$AA@
CONST	SEGMENT
??_C@_0BE@LNOGIHJB@IRP_MN_START_DEVICE?$AA@ DB 'IRP_MN_START_DEVICE', 00H ; `string'
?pszMajorFunctionV@@3PAPEADA DQ FLAT:??_C@_0O@LCBLIIOL@IRP_MJ_CREATE?$AA@ ; pszMajorFunctionV
	DQ	FLAT:??_C@_0BJ@MMKIHFHH@IRP_MJ_CREATE_NAMED_PIPE?$AA@
	DQ	FLAT:??_C@_0N@FMCDOLCP@IRP_MJ_CLOSE?$AA@
	DQ	FLAT:??_C@_0M@LJKCMGIA@IRP_MJ_READ?$AA@
	DQ	FLAT:??_C@_0N@DLJAMLBI@IRP_MJ_WRITE?$AA@
	DQ	FLAT:??_C@_0BJ@FPMLIFJJ@IRP_MJ_QUERY_INFORMATION?$AA@
	DQ	FLAT:??_C@_0BH@GNAPBNMO@IRP_MJ_SET_INFORMATION?$AA@
	DQ	FLAT:??_C@_0BA@LFPMCNA@IRP_MJ_QUERY_EA?$AA@
	DQ	FLAT:??_C@_0O@FPNILENL@IRP_MJ_SET_EA?$AA@
	DQ	FLAT:??_C@_0BF@CBDAKCPM@IRP_MJ_FLUSH_BUFFERS?$AA@
	DQ	FLAT:??_C@_0CA@FDGJPBOD@IRP_MJ_QUERY_VOLUME_INFORMATION?$AA@
	DQ	FLAT:??_C@_0BO@CJJMMMF@IRP_MJ_SET_VOLUME_INFORMATION?$AA@
	DQ	FLAT:??_C@_0BJ@NCGIANAN@IRP_MJ_DIRECTORY_CONTROL?$AA@
	DQ	FLAT:??_C@_0BL@MFHGBIDL@IRP_MJ_FILE_SYSTEM_CONTROL?$AA@
	DQ	FLAT:??_C@_0BG@HAFCIBGJ@IRP_MJ_DEVICE_CONTROL?$AA@
	DQ	FLAT:??_C@_0BP@ODEFGAEK@IRP_MJ_INTERNAL_DEVICE_CONTROL?$AA@
	DQ	FLAT:??_C@_0BA@CDMDNOAC@IRP_MJ_SHUTDOWN?$AA@
	DQ	FLAT:??_C@_0BE@LODBBEFP@IRP_MJ_LOCK_CONTROL?$AA@
	DQ	FLAT:??_C@_0P@JJLCIODE@IRP_MJ_CLEANUP?$AA@
	DQ	FLAT:??_C@_0BH@CKPKPKHL@IRP_MJ_CREATE_MAILSLOT?$AA@
	DQ	FLAT:??_C@_0BG@MIODHPEN@IRP_MJ_QUERY_SECURITY?$AA@
	DQ	FLAT:??_C@_0BE@MPINJCAP@IRP_MJ_SET_SECURITY?$AA@
	DQ	FLAT:??_C@_0N@BGEEMFOO@IRP_MJ_POWER?$AA@
	DQ	FLAT:??_C@_0BG@JHIMGJML@IRP_MJ_SYSTEM_CONTROL?$AA@
	DQ	FLAT:??_C@_0BF@HOMHCDN@IRP_MJ_DEVICE_CHANGE?$AA@
	DQ	FLAT:??_C@_0BD@MDBGANBO@IRP_MJ_QUERY_QUOTA?$AA@
	DQ	FLAT:??_C@_0BB@MFPKCKFI@IRP_MJ_SET_QUOTA?$AA@
	DQ	FLAT:??_C@_0L@EACGAIIF@IRP_MJ_PNP?$AA@
?pszPnpMinorFunctionV@@3PAPEADA DQ FLAT:??_C@_0BE@LNOGIHJB@IRP_MN_START_DEVICE?$AA@ ; pszPnpMinorFunctionV
	DQ	FLAT:??_C@_0BL@BKMKKOEG@IRP_MN_QUERY_REMOVE_DEVICE?$AA@
	DQ	FLAT:??_C@_0BF@CIDCHGNK@IRP_MN_REMOVE_DEVICE?$AA@
	DQ	FLAT:??_C@_0BM@NHOBKHFC@IRP_MN_CANCEL_REMOVE_DEVICE?$AA@
	DQ	FLAT:??_C@_0BD@OKOEKPNG@IRP_MN_STOP_DEVICE?$AA@
	DQ	FLAT:??_C@_0BJ@DBBODAKD@IRP_MN_QUERY_STOP_DEVICE?$AA@
	DQ	FLAT:??_C@_0BK@IHBBLJPI@IRP_MN_CANCEL_STOP_DEVICE?$AA@
	DQ	FLAT:??_C@_0BO@EDNJKJCF@IRP_MN_QUERY_DEVICE_RELATIONS?$AA@
	DQ	FLAT:??_C@_0BH@NJFMIPMO@IRP_MN_QUERY_INTERFACE?$AA@
	DQ	FLAT:??_C@_0BK@FNPJPCCF@IRP_MN_QUERY_CAPABILITIES?$AA@
	DQ	FLAT:??_C@_0BH@BAILDNEP@IRP_MN_QUERY_RESOURCES?$AA@
	DQ	FLAT:??_C@_0CD@MPPOHAEF@IRP_MN_QUERY_RESOURCE_REQUIREMEN@
	DQ	FLAT:??_C@_0BJ@KBKMPMKH@IRP_MN_QUERY_DEVICE_TEXT?$AA@
	DQ	FLAT:??_C@_0CE@FFGNIHMK@IRP_MN_FILTER_RESOURCE_REQUIREME@
	DQ	FLAT:??_C@_07CIFAGBMG@unknown?$AA@
	DQ	FLAT:??_C@_0BD@KCLCONNF@IRP_MN_READ_CONFIG?$AA@
	DQ	FLAT:??_C@_0BE@MNGKLJHO@IRP_MN_WRITE_CONFIG?$AA@
	DQ	FLAT:??_C@_0N@KBDCJDGM@IRP_MN_EJECT?$AA@
	DQ	FLAT:??_C@_0BA@JCIHPHAO@IRP_MN_SET_LOCK?$AA@
	DQ	FLAT:??_C@_0BA@MPOLLMHD@IRP_MN_QUERY_ID?$AA@
	DQ	FLAT:??_C@_0BO@CLJGNPDL@IRP_MN_QUERY_PNP_DEVICE_STATE?$AA@
	DQ	FLAT:??_C@_0BN@FKLLPNEA@IRP_MN_QUERY_BUS_INFORMATION?$AA@
	DQ	FLAT:??_C@_0CB@EEGIBKLH@IRP_MN_DEVICE_USAGE_NOTIFICATION@
	DQ	FLAT:??_C@_0BI@JJMGKCHF@IRP_MN_SURPRISE_REMOVAL?$AA@
?pszPowerMinorFunctionV@@3PAPEADA DQ FLAT:??_C@_0BB@KEEBPEDL@IRP_MN_WAIT_WAKE?$AA@ ; pszPowerMinorFunctionV
	DQ	FLAT:??_C@_0BG@HJCHODFP@IRP_MN_POWER_SEQUENCE?$AA@
	DQ	FLAT:??_C@_0BB@MOFGLKAE@IRP_MN_SET_POWER?$AA@
	DQ	FLAT:??_C@_0BD@NCBACJCG@IRP_MN_QUERY_POWER?$AA@
;	COMDAT ??_C@_0L@EACGAIIF@IRP_MJ_PNP?$AA@
CONST	SEGMENT
??_C@_0L@EACGAIIF@IRP_MJ_PNP?$AA@ DB 'IRP_MJ_PNP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MFPKCKFI@IRP_MJ_SET_QUOTA?$AA@
CONST	SEGMENT
??_C@_0BB@MFPKCKFI@IRP_MJ_SET_QUOTA?$AA@ DB 'IRP_MJ_SET_QUOTA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MDBGANBO@IRP_MJ_QUERY_QUOTA?$AA@
CONST	SEGMENT
??_C@_0BD@MDBGANBO@IRP_MJ_QUERY_QUOTA?$AA@ DB 'IRP_MJ_QUERY_QUOTA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HOMHCDN@IRP_MJ_DEVICE_CHANGE?$AA@
CONST	SEGMENT
??_C@_0BF@HOMHCDN@IRP_MJ_DEVICE_CHANGE?$AA@ DB 'IRP_MJ_DEVICE_CHANGE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JHIMGJML@IRP_MJ_SYSTEM_CONTROL?$AA@
CONST	SEGMENT
??_C@_0BG@JHIMGJML@IRP_MJ_SYSTEM_CONTROL?$AA@ DB 'IRP_MJ_SYSTEM_CONTROL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BGEEMFOO@IRP_MJ_POWER?$AA@
CONST	SEGMENT
??_C@_0N@BGEEMFOO@IRP_MJ_POWER?$AA@ DB 'IRP_MJ_POWER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MPINJCAP@IRP_MJ_SET_SECURITY?$AA@
CONST	SEGMENT
??_C@_0BE@MPINJCAP@IRP_MJ_SET_SECURITY?$AA@ DB 'IRP_MJ_SET_SECURITY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MIODHPEN@IRP_MJ_QUERY_SECURITY?$AA@
CONST	SEGMENT
??_C@_0BG@MIODHPEN@IRP_MJ_QUERY_SECURITY?$AA@ DB 'IRP_MJ_QUERY_SECURITY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CKPKPKHL@IRP_MJ_CREATE_MAILSLOT?$AA@
CONST	SEGMENT
??_C@_0BH@CKPKPKHL@IRP_MJ_CREATE_MAILSLOT?$AA@ DB 'IRP_MJ_CREATE_MAILSLOT'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JJLCIODE@IRP_MJ_CLEANUP?$AA@
CONST	SEGMENT
??_C@_0P@JJLCIODE@IRP_MJ_CLEANUP?$AA@ DB 'IRP_MJ_CLEANUP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LODBBEFP@IRP_MJ_LOCK_CONTROL?$AA@
CONST	SEGMENT
??_C@_0BE@LODBBEFP@IRP_MJ_LOCK_CONTROL?$AA@ DB 'IRP_MJ_LOCK_CONTROL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CDMDNOAC@IRP_MJ_SHUTDOWN?$AA@
CONST	SEGMENT
??_C@_0BA@CDMDNOAC@IRP_MJ_SHUTDOWN?$AA@ DB 'IRP_MJ_SHUTDOWN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@ODEFGAEK@IRP_MJ_INTERNAL_DEVICE_CONTROL?$AA@
CONST	SEGMENT
??_C@_0BP@ODEFGAEK@IRP_MJ_INTERNAL_DEVICE_CONTROL?$AA@ DB 'IRP_MJ_INTERNA'
	DB	'L_DEVICE_CONTROL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HAFCIBGJ@IRP_MJ_DEVICE_CONTROL?$AA@
CONST	SEGMENT
??_C@_0BG@HAFCIBGJ@IRP_MJ_DEVICE_CONTROL?$AA@ DB 'IRP_MJ_DEVICE_CONTROL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MFHGBIDL@IRP_MJ_FILE_SYSTEM_CONTROL?$AA@
CONST	SEGMENT
??_C@_0BL@MFHGBIDL@IRP_MJ_FILE_SYSTEM_CONTROL?$AA@ DB 'IRP_MJ_FILE_SYSTEM'
	DB	'_CONTROL', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NCGIANAN@IRP_MJ_DIRECTORY_CONTROL?$AA@
CONST	SEGMENT
??_C@_0BJ@NCGIANAN@IRP_MJ_DIRECTORY_CONTROL?$AA@ DB 'IRP_MJ_DIRECTORY_CON'
	DB	'TROL', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CJJMMMF@IRP_MJ_SET_VOLUME_INFORMATION?$AA@
CONST	SEGMENT
??_C@_0BO@CJJMMMF@IRP_MJ_SET_VOLUME_INFORMATION?$AA@ DB 'IRP_MJ_SET_VOLUM'
	DB	'E_INFORMATION', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FDGJPBOD@IRP_MJ_QUERY_VOLUME_INFORMATION?$AA@
CONST	SEGMENT
??_C@_0CA@FDGJPBOD@IRP_MJ_QUERY_VOLUME_INFORMATION?$AA@ DB 'IRP_MJ_QUERY_'
	DB	'VOLUME_INFORMATION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CBDAKCPM@IRP_MJ_FLUSH_BUFFERS?$AA@
CONST	SEGMENT
??_C@_0BF@CBDAKCPM@IRP_MJ_FLUSH_BUFFERS?$AA@ DB 'IRP_MJ_FLUSH_BUFFERS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FPNILENL@IRP_MJ_SET_EA?$AA@
CONST	SEGMENT
??_C@_0O@FPNILENL@IRP_MJ_SET_EA?$AA@ DB 'IRP_MJ_SET_EA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LFPMCNA@IRP_MJ_QUERY_EA?$AA@
CONST	SEGMENT
??_C@_0BA@LFPMCNA@IRP_MJ_QUERY_EA?$AA@ DB 'IRP_MJ_QUERY_EA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GNAPBNMO@IRP_MJ_SET_INFORMATION?$AA@
CONST	SEGMENT
??_C@_0BH@GNAPBNMO@IRP_MJ_SET_INFORMATION?$AA@ DB 'IRP_MJ_SET_INFORMATION'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FPMLIFJJ@IRP_MJ_QUERY_INFORMATION?$AA@
CONST	SEGMENT
??_C@_0BJ@FPMLIFJJ@IRP_MJ_QUERY_INFORMATION?$AA@ DB 'IRP_MJ_QUERY_INFORMA'
	DB	'TION', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DLJAMLBI@IRP_MJ_WRITE?$AA@
CONST	SEGMENT
??_C@_0N@DLJAMLBI@IRP_MJ_WRITE?$AA@ DB 'IRP_MJ_WRITE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LJKCMGIA@IRP_MJ_READ?$AA@
CONST	SEGMENT
??_C@_0M@LJKCMGIA@IRP_MJ_READ?$AA@ DB 'IRP_MJ_READ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FMCDOLCP@IRP_MJ_CLOSE?$AA@
CONST	SEGMENT
??_C@_0N@FMCDOLCP@IRP_MJ_CLOSE?$AA@ DB 'IRP_MJ_CLOSE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MMKIHFHH@IRP_MJ_CREATE_NAMED_PIPE?$AA@
CONST	SEGMENT
??_C@_0BJ@MMKIHFHH@IRP_MJ_CREATE_NAMED_PIPE?$AA@ DB 'IRP_MJ_CREATE_NAMED_'
	DB	'PIPE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LCBLIIOL@IRP_MJ_CREATE?$AA@
CONST	SEGMENT
??_C@_0O@LCBLIIOL@IRP_MJ_CREATE?$AA@ DB 'IRP_MJ_CREATE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HDMHMCGD@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
text$s	SEGMENT
??_C@_0CI@HDMHMCGD@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ DB 'I'
	DB	'rp->CurrentLocation <= Irp->StackCount', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0FK@JAEDPCKJ@?$CIInvokeOnSuccess?5?$HM?$HM?5InvokeOnErro@FNODOBFM@
text$s	SEGMENT
??_C@_0FK@JAEDPCKJ@?$CIInvokeOnSuccess?5?$HM?$HM?5InvokeOnErro@FNODOBFM@ DB '('
	DB	'InvokeOnSuccess || InvokeOnError || InvokeOnCancel) ? (Comple'
	DB	'tionRoutine != NULL) : TRUE', 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@ DB 'Irp'
	DB	'->CurrentLocation > 0', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
text$s	SEGMENT
??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ DB 'I'
	DB	'rp->CurrentLocation <= Irp->StackCount + 1', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CJ@NOBCDHO@c?3?2apps?2pw7hp?2devpgm?2msddk?2inc?2d@FNODOBFM@
text$s	SEGMENT
??_C@_0CJ@NOBCDHO@c?3?2apps?2pw7hp?2devpgm?2msddk?2inc?2d@FNODOBFM@ DB 'c'
	DB	':\apps\pw7hp\devpgm\msddk\inc\ddk\wdm.h', 00H ;  ?? ::FNODOBFM::`string'
;	COMDAT pdata
; File b:\programm\wntsys\testfilter\release\1_1\source\driver\drvmain.cpp
pdata	SEGMENT
$pdata$?SendIrpSyncCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z DD imagerel ?SendIrpSyncCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z
	DD	imagerel ?SendIrpSyncCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z+45
	DD	imagerel $unwind$?SendIrpSyncCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SendIrpSyncCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?SendIrpSyncCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z
_TEXT	SEGMENT
pDevObj$ = 48
pIrp$ = 56
Context$ = 64
?SendIrpSyncCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z PROC ; SendIrpSyncCompletion, COMDAT

; 3214 : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3215 : 	KeSetEvent((PKEVENT) Context, IO_NO_INCREMENT, FALSE);

	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR Context$[rsp]
	call	QWORD PTR __imp_KeSetEvent

; 3216 : 	return STATUS_MORE_PROCESSING_REQUIRED;

	mov	eax, -1073741802			; ffffffffc0000016H

; 3217 : }

	add	rsp, 40					; 00000028H
	ret	0
?SendIrpSyncCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z ENDP ; SendIrpSyncCompletion
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetRWIrpBuffer@@YAJPEAU_IRP@@PEAU_DEVICE_OBJECT@@PEAPEAX@Z DD imagerel ?GetRWIrpBuffer@@YAJPEAU_IRP@@PEAU_DEVICE_OBJECT@@PEAPEAX@Z
	DD	imagerel ?GetRWIrpBuffer@@YAJPEAU_IRP@@PEAU_DEVICE_OBJECT@@PEAPEAX@Z+238
	DD	imagerel $unwind$?GetRWIrpBuffer@@YAJPEAU_IRP@@PEAU_DEVICE_OBJECT@@PEAPEAX@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetRWIrpBuffer@@YAJPEAU_IRP@@PEAU_DEVICE_OBJECT@@PEAPEAX@Z DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?GetRWIrpBuffer@@YAJPEAU_IRP@@PEAU_DEVICE_OBJECT@@PEAPEAX@Z
_TEXT	SEGMENT
pMdl$28890 = 48
tv85 = 56
pIrp$ = 80
pDevObj$ = 88
ppBuffer$ = 96
?GetRWIrpBuffer@@YAJPEAU_IRP@@PEAU_DEVICE_OBJECT@@PEAPEAX@Z PROC ; GetRWIrpBuffer, COMDAT

; 1857 : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1858 : 	if (pDevObj->Flags & DO_BUFFERED_IO) {

	mov	rax, QWORD PTR pDevObj$[rsp]
	mov	eax, DWORD PTR [rax+48]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN5@GetRWIrpBu

; 1859 : 		*ppBuffer = pIrp->AssociatedIrp.SystemBuffer;

	mov	rcx, QWORD PTR ppBuffer$[rsp]
	mov	rax, QWORD PTR pIrp$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR [rcx], rax

; 1860 : 		return STATUS_SUCCESS;

	xor	eax, eax
	jmp	$LN6@GetRWIrpBu
	jmp	$LN4@GetRWIrpBu
$LN5@GetRWIrpBu:

; 1861 : 	} else if (pDevObj->Flags & DO_DIRECT_IO) {

	mov	rax, QWORD PTR pDevObj$[rsp]
	mov	eax, DWORD PTR [rax+48]
	and	eax, 16
	test	eax, eax
	je	$LN3@GetRWIrpBu

; 1862 : 		PMDL pMdl = pIrp->MdlAddress;

	mov	rax, QWORD PTR pIrp$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR pMdl$28890[rsp], rax

; 1863 : 		*ppBuffer = 
; 1864 : 			MmGetSystemAddressForMdlSafe(pMdl, LowPagePriority);

	mov	rax, QWORD PTR pMdl$28890[rsp]
	movsx	eax, WORD PTR [rax+10]
	and	eax, 5
	test	eax, eax
	je	SHORT $LN8@GetRWIrpBu
	mov	rax, QWORD PTR pMdl$28890[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR tv85[rsp], rax
	jmp	SHORT $LN9@GetRWIrpBu
$LN8@GetRWIrpBu:
	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8d, 1
	xor	edx, edx
	mov	rcx, QWORD PTR pMdl$28890[rsp]
	call	QWORD PTR __imp_MmMapLockedPagesSpecifyCache
	mov	QWORD PTR tv85[rsp], rax
$LN9@GetRWIrpBu:
	mov	rcx, QWORD PTR ppBuffer$[rsp]
	mov	rax, QWORD PTR tv85[rsp]
	mov	QWORD PTR [rcx], rax

; 1865 : 		if (*ppBuffer == NULL) {

	mov	rax, QWORD PTR ppBuffer$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN2@GetRWIrpBu

; 1866 : 			DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1867 : 				"FLT - GetRWIrpBuffer - "
; 1868 : 				"MmGetSystemAddressForMdlSafe() returned NULL\n");

	lea	r8, OFFSET FLAT:??_C@_0EF@BMIAKKGE@FLT?5?9?5GetRWIrpBuffer?5?9?5MmGetSyst@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 1869 : 			return STATUS_NO_MEMORY;

	mov	eax, -1073741801			; ffffffffc0000017H
	jmp	SHORT $LN6@GetRWIrpBu
$LN2@GetRWIrpBu:

; 1870 : 		}
; 1871 : 		return STATUS_SUCCESS;

	xor	eax, eax
	jmp	SHORT $LN6@GetRWIrpBu

; 1872 : 	} else {

	jmp	SHORT $LN1@GetRWIrpBu
$LN3@GetRWIrpBu:

; 1873 : 		return STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; ffffffffc000000dH
$LN1@GetRWIrpBu:
$LN4@GetRWIrpBu:
$LN6@GetRWIrpBu:

; 1874 : 	}
; 1875 : }

	add	rsp, 72					; 00000048H
	ret	0
?GetRWIrpBuffer@@YAJPEAU_IRP@@PEAU_DEVICE_OBJECT@@PEAPEAX@Z ENDP ; GetRWIrpBuffer
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetReadData@@YAXPEAU_IRP@@PEAU_DEVICE_EXTENSION@@PEAPEAXPEA_K@Z DD imagerel ?GetReadData@@YAXPEAU_IRP@@PEAU_DEVICE_EXTENSION@@PEAPEAXPEA_K@Z
	DD	imagerel ?GetReadData@@YAXPEAU_IRP@@PEAU_DEVICE_EXTENSION@@PEAPEAXPEA_K@Z+319
	DD	imagerel $unwind$?GetReadData@@YAXPEAU_IRP@@PEAU_DEVICE_EXTENSION@@PEAPEAXPEA_K@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetReadData@@YAXPEAU_IRP@@PEAU_DEVICE_EXTENSION@@PEAPEAXPEA_K@Z DD 011801H
	DD	0a218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?GetReadData@@YAXPEAU_IRP@@PEAU_DEVICE_EXTENSION@@PEAPEAXPEA_K@Z
_TEXT	SEGMENT
pMdl$28874 = 48
pBufStart$28875 = 56
tv87 = 64
pReadIrp$ = 96
pDevExt$ = 104
ppReadData$ = 112
pcbDataLen$ = 120
?GetReadData@@YAXPEAU_IRP@@PEAU_DEVICE_EXTENSION@@PEAPEAXPEA_K@Z PROC ; GetReadData, COMDAT

; 1792 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1793 : 	*ppReadData = NULL;

	mov	rax, QWORD PTR ppReadData$[rsp]
	mov	QWORD PTR [rax], 0

; 1794 : 	*pcbDataLen = 0;

	mov	rax, QWORD PTR pcbDataLen$[rsp]
	mov	QWORD PTR [rax], 0

; 1795 : 
; 1796 : 	if (!NT_SUCCESS(pReadIrp->IoStatus.Status)) return;

	mov	rax, QWORD PTR pReadIrp$[rsp]
	cmp	DWORD PTR [rax+48], 0
	jge	SHORT $LN6@GetReadDat
	jmp	$LN7@GetReadDat
$LN6@GetReadDat:

; 1797 : 	*pcbDataLen = pReadIrp->IoStatus.Information;

	mov	rcx, QWORD PTR pcbDataLen$[rsp]
	mov	rax, QWORD PTR pReadIrp$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR [rcx], rax

; 1798 : 	if (!*pcbDataLen) return;

	mov	rax, QWORD PTR pcbDataLen$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN5@GetReadDat
	jmp	$LN7@GetReadDat
$LN5@GetReadDat:

; 1799 : 
; 1800 : 	// Determine the buffering mode
; 1801 : 	//
; 1802 : 	if (pDevExt->hdr.pDevice->Flags & DO_DIRECT_IO) {

	mov	rax, QWORD PTR pDevExt$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [rax+48]
	and	eax, 16
	test	eax, eax
	je	$LN4@GetReadDat

; 1803 : 
; 1804 : 		PMDL pMdl = pReadIrp->MdlAddress;

	mov	rax, QWORD PTR pReadIrp$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR pMdl$28874[rsp], rax

; 1805 : 		PCHAR pBufStart = (PCHAR) MmGetSystemAddressForMdlSafe(pMdl, 
; 1806 : 				LowPagePriority);

	mov	rax, QWORD PTR pMdl$28874[rsp]
	movsx	eax, WORD PTR [rax+10]
	and	eax, 5
	test	eax, eax
	je	SHORT $LN9@GetReadDat
	mov	rax, QWORD PTR pMdl$28874[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR tv87[rsp], rax
	jmp	SHORT $LN10@GetReadDat
$LN9@GetReadDat:
	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8d, 1
	xor	edx, edx
	mov	rcx, QWORD PTR pMdl$28874[rsp]
	call	QWORD PTR __imp_MmMapLockedPagesSpecifyCache
	mov	QWORD PTR tv87[rsp], rax
$LN10@GetReadDat:
	mov	rax, QWORD PTR tv87[rsp]
	mov	QWORD PTR pBufStart$28875[rsp], rax

; 1807 : 		if (pBufStart != NULL) {

	cmp	QWORD PTR pBufStart$28875[rsp], 0
	je	SHORT $LN3@GetReadDat

; 1808 : 			*ppReadData = pBufStart;

	mov	rcx, QWORD PTR ppReadData$[rsp]
	mov	rax, QWORD PTR pBufStart$28875[rsp]
	mov	QWORD PTR [rcx], rax

; 1809 : 		} else {

	jmp	SHORT $LN2@GetReadDat
$LN3@GetReadDat:

; 1810 : 
; 1811 : 			// This should never happen, because the client buffer
; 1812 : 			// has already been locked in place by who issued the
; 1813 : 			// read IRP.
; 1814 : 			//
; 1815 : 			*pcbDataLen = 0;

	mov	rax, QWORD PTR pcbDataLen$[rsp]
	mov	QWORD PTR [rax], 0
$LN2@GetReadDat:

; 1816 : 		}
; 1817 : 	} else {

	jmp	SHORT $LN1@GetReadDat
$LN4@GetReadDat:

; 1818 : 
; 1819 : 		// Buffered I/O
; 1820 : 		//
; 1821 : 		*ppReadData = pReadIrp->AssociatedIrp.SystemBuffer;

	mov	rcx, QWORD PTR ppReadData$[rsp]
	mov	rax, QWORD PTR pReadIrp$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR [rcx], rax
$LN1@GetReadDat:

; 1822 : 	}
; 1823 : 
; 1824 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1825 : 		"FLT - GetReadData - Read data address: %#p, length: %#x\n",
; 1826 : 		*ppReadData, *pcbDataLen);

	mov	rax, QWORD PTR pcbDataLen$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR ppReadData$[rsp]
	mov	r9, QWORD PTR [r9]
	lea	r8, OFFSET FLAT:??_C@_0DJ@OOGMKJA@FLT?5?9?5GetReadData?5?9?5Read?5data?5ad@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx
$LN7@GetReadDat:

; 1827 : 
; 1828 : 	return;
; 1829 : }

	add	rsp, 88					; 00000058H
	ret	0
?GetReadData@@YAXPEAU_IRP@@PEAU_DEVICE_EXTENSION@@PEAPEAXPEA_K@Z ENDP ; GetReadData
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CopyWString@@YAXPEAG0_K@Z DD imagerel ?CopyWString@@YAXPEAG0_K@Z
	DD	imagerel ?CopyWString@@YAXPEAG0_K@Z+139
	DD	imagerel $unwind$?CopyWString@@YAXPEAG0_K@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CopyWString@@YAXPEAG0_K@Z DD 011301H
	DD	02213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?CopyWString@@YAXPEAG0_K@Z
_TEXT	SEGMENT
pLast$ = 0
pDest$ = 32
pSrc$ = 40
DestSize$ = 48
?CopyWString@@YAXPEAG0_K@Z PROC				; CopyWString, COMDAT

; 858  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 859  : 	// pLast points to the last WCHAR in the dest buffer.
; 860  : 	//
; 861  : 	PWCHAR pLast = pDest + DestSize / sizeof (WCHAR) -1;

	xor	edx, edx
	mov	rax, QWORD PTR DestSize$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, rax
	mov	rax, QWORD PTR pDest$[rsp]
	lea	rax, QWORD PTR [rax+rcx*2-2]
	mov	QWORD PTR pLast$[rsp], rax

; 862  : 	for (; *pSrc != L'\0'; pSrc++, pDest++) {

	jmp	SHORT $LN4@CopyWStrin
$LN3@CopyWStrin:
	mov	rax, QWORD PTR pSrc$[rsp]
	add	rax, 2
	mov	QWORD PTR pSrc$[rsp], rax
	mov	rax, QWORD PTR pDest$[rsp]
	add	rax, 2
	mov	QWORD PTR pDest$[rsp], rax
$LN4@CopyWStrin:
	mov	rax, QWORD PTR pSrc$[rsp]
	movzx	eax, WORD PTR [rax]
	test	eax, eax
	je	SHORT $LN2@CopyWStrin

; 863  : 		if (pDest >= pLast) break;

	mov	rax, QWORD PTR pLast$[rsp]
	cmp	QWORD PTR pDest$[rsp], rax
	jb	SHORT $LN1@CopyWStrin
	jmp	SHORT $LN2@CopyWStrin
$LN1@CopyWStrin:

; 864  : 		*pDest = *pSrc;

	mov	rcx, QWORD PTR pDest$[rsp]
	mov	rax, QWORD PTR pSrc$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR [rcx], ax

; 865  : 	}

	jmp	SHORT $LN3@CopyWStrin
$LN2@CopyWStrin:

; 866  : 	*pDest = L'\0';

	xor	ecx, ecx
	mov	rax, QWORD PTR pDest$[rsp]
	mov	WORD PTR [rax], cx

; 867  : 	return;
; 868  : }

	add	rsp, 24
	ret	0
?CopyWString@@YAXPEAG0_K@Z ENDP				; CopyWString
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CopyMultiWString@@YAXPEAG0_K@Z DD imagerel ?CopyMultiWString@@YAXPEAG0_K@Z
	DD	imagerel ?CopyMultiWString@@YAXPEAG0_K@Z+206
	DD	imagerel $unwind$?CopyMultiWString@@YAXPEAG0_K@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CopyMultiWString@@YAXPEAG0_K@Z DD 011301H
	DD	02213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?CopyMultiWString@@YAXPEAG0_K@Z
_TEXT	SEGMENT
pLast$ = 0
pDest$ = 32
pSrc$ = 40
DestSize$ = 48
?CopyMultiWString@@YAXPEAG0_K@Z PROC			; CopyMultiWString, COMDAT

; 815  : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 816  : 	// pLast points to the next to last WCHAR in the dest buffer.
; 817  : 	//
; 818  : 	PWCHAR pLast = pDest + DestSize / sizeof (WCHAR) -2;

	xor	edx, edx
	mov	rax, QWORD PTR DestSize$[rsp]
	mov	ecx, 2
	div	rcx
	mov	rcx, rax
	mov	rax, QWORD PTR pDest$[rsp]
	lea	rax, QWORD PTR [rax+rcx*2-4]
	mov	QWORD PTR pLast$[rsp], rax
$LN8@CopyMultiW:

; 819  : 	do {
; 820  : 		for (; *pSrc != L'\0'; pSrc++, pDest++) {

	jmp	SHORT $LN5@CopyMultiW
$LN4@CopyMultiW:
	mov	rax, QWORD PTR pSrc$[rsp]
	add	rax, 2
	mov	QWORD PTR pSrc$[rsp], rax
	mov	rax, QWORD PTR pDest$[rsp]
	add	rax, 2
	mov	QWORD PTR pDest$[rsp], rax
$LN5@CopyMultiW:
	mov	rax, QWORD PTR pSrc$[rsp]
	movzx	eax, WORD PTR [rax]
	test	eax, eax
	je	SHORT $LN3@CopyMultiW

; 821  : 			if (pDest >= pLast) break;

	mov	rax, QWORD PTR pLast$[rsp]
	cmp	QWORD PTR pDest$[rsp], rax
	jb	SHORT $LN2@CopyMultiW
	jmp	SHORT $LN3@CopyMultiW
$LN2@CopyMultiW:

; 822  : 			*pDest = *pSrc;

	mov	rcx, QWORD PTR pDest$[rsp]
	mov	rax, QWORD PTR pSrc$[rsp]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR [rcx], ax

; 823  : 		}

	jmp	SHORT $LN4@CopyMultiW
$LN3@CopyMultiW:

; 824  : 		*pDest = L'\0';

	xor	ecx, ecx
	mov	rax, QWORD PTR pDest$[rsp]
	mov	WORD PTR [rax], cx

; 825  : 		pDest++;

	mov	rax, QWORD PTR pDest$[rsp]
	add	rax, 2
	mov	QWORD PTR pDest$[rsp], rax

; 826  : 		if (pDest >= pLast) break;

	mov	rax, QWORD PTR pLast$[rsp]
	cmp	QWORD PTR pDest$[rsp], rax
	jb	SHORT $LN1@CopyMultiW
	jmp	SHORT $LN6@CopyMultiW
$LN1@CopyMultiW:

; 827  : 		pSrc++;

	mov	rax, QWORD PTR pSrc$[rsp]
	add	rax, 2
	mov	QWORD PTR pSrc$[rsp], rax

; 828  : 	} while (*pSrc != L'\0');

	mov	rax, QWORD PTR pSrc$[rsp]
	movzx	eax, WORD PTR [rax]
	test	eax, eax
	jne	$LN8@CopyMultiW
$LN6@CopyMultiW:

; 829  : 	*(pDest) = L'\0';

	xor	ecx, ecx
	mov	rax, QWORD PTR pDest$[rsp]
	mov	WORD PTR [rax], cx

; 830  : 	return;
; 831  : }

	add	rsp, 24
	ret	0
?CopyMultiWString@@YAXPEAG0_K@Z ENDP			; CopyMultiWString
_TEXT	ENDS
;	COMDAT pdata
; File c:\apps\pw7hp\devpgm\msddk\inc\ddk\ntstrsafe.h
pdata	SEGMENT
$pdata$RtlWideCharArrayVPrintfWorker DD imagerel RtlWideCharArrayVPrintfWorker
	DD	imagerel RtlWideCharArrayVPrintfWorker+126
	DD	imagerel $unwind$RtlWideCharArrayVPrintfWorker
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RtlWideCharArrayVPrintfWorker DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT RtlWideCharArrayVPrintfWorker
_TEXT	SEGMENT
iRet$ = 32
status$ = 36
pszDest$ = 64
cchDest$ = 72
pcchNewDestLength$ = 80
pszFormat$ = 88
argList$ = 96
RtlWideCharArrayVPrintfWorker PROC			; COMDAT

; 12374: {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 12375:     NTSTATUS status = STATUS_SUCCESS;

	mov	DWORD PTR status$[rsp], 0

; 12376:     int iRet;
; 12377:     
; 12378:     #pragma warning(push)
; 12379:     #pragma warning(disable: __WARNING_BANNED_API_USAGE)// "STRSAFE not included"
; 12380:     iRet = _vsnwprintf(pszDest, cchDest, pszFormat, argList);

	mov	r9, QWORD PTR argList$[rsp]
	mov	r8, QWORD PTR pszFormat$[rsp]
	mov	rdx, QWORD PTR cchDest$[rsp]
	mov	rcx, QWORD PTR pszDest$[rsp]
	call	QWORD PTR __imp__vsnwprintf
	mov	DWORD PTR iRet$[rsp], eax

; 12381:     #pragma warning(pop)
; 12382:     // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));
; 12383: 
; 12384:     if ((iRet < 0) || (((size_t)iRet) > cchDest))

	cmp	DWORD PTR iRet$[rsp], 0
	jl	SHORT $LN2@RtlWideCha
	movsxd	rax, DWORD PTR iRet$[rsp]
	cmp	rax, QWORD PTR cchDest$[rsp]
	jbe	SHORT $LN3@RtlWideCha
$LN2@RtlWideCha:

; 12385:     {
; 12386:         *pcchNewDestLength = cchDest;

	mov	rcx, QWORD PTR pcchNewDestLength$[rsp]
	mov	rax, QWORD PTR cchDest$[rsp]
	mov	QWORD PTR [rcx], rax

; 12387: 
; 12388:         // we have truncated pszDest
; 12389:         status = STATUS_BUFFER_OVERFLOW;

	mov	DWORD PTR status$[rsp], -2147483643	; ffffffff80000005H

; 12390:     }
; 12391:     else

	jmp	SHORT $LN1@RtlWideCha
$LN3@RtlWideCha:

; 12392:     {
; 12393:         *pcchNewDestLength = (size_t)iRet;

	movsxd	rcx, DWORD PTR iRet$[rsp]
	mov	rax, QWORD PTR pcchNewDestLength$[rsp]
	mov	QWORD PTR [rax], rcx
$LN1@RtlWideCha:

; 12394:     }
; 12395: 
; 12396:     return status;

	mov	eax, DWORD PTR status$[rsp]

; 12397: }

	add	rsp, 56					; 00000038H
	ret	0
RtlWideCharArrayVPrintfWorker ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$RtlUnicodeStringValidateWorker DD imagerel RtlUnicodeStringValidateWorker
	DD	imagerel RtlUnicodeStringValidateWorker+202
	DD	imagerel $unwind$RtlUnicodeStringValidateWorker
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RtlUnicodeStringValidateWorker DD 011301H
	DD	02213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT RtlUnicodeStringValidateWorker
_TEXT	SEGMENT
status$ = 0
SourceString$ = 32
cchMax$ = 40
dwFlags$ = 48
RtlUnicodeStringValidateWorker PROC			; COMDAT

; 12173: {

	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 12174:     NTSTATUS status = STATUS_SUCCESS;

	mov	DWORD PTR status$[rsp], 0

; 12175: 
; 12176:     if (SourceString || !(dwFlags & STRSAFE_IGNORE_NULLS))

	cmp	QWORD PTR SourceString$[rsp], 0
	jne	SHORT $LN6@RtlUnicode
	mov	eax, DWORD PTR dwFlags$[rsp]
	and	eax, 256				; 00000100H
	test	eax, eax
	jne	$LN7@RtlUnicode
$LN6@RtlUnicode:

; 12177:     {
; 12178:         if (((SourceString->Length % sizeof(wchar_t)) != 0)         ||
; 12179:             ((SourceString->MaximumLength % sizeof(wchar_t)) != 0)  ||
; 12180:             (SourceString->Length > SourceString->MaximumLength)    ||
; 12181:             (SourceString->MaximumLength > (cchMax * sizeof(wchar_t))))

	mov	rax, QWORD PTR SourceString$[rsp]
	movzx	eax, WORD PTR [rax]
	xor	edx, edx
	mov	ecx, 2
	div	rcx
	test	rdx, rdx
	jne	SHORT $LN4@RtlUnicode
	mov	rax, QWORD PTR SourceString$[rsp]
	movzx	eax, WORD PTR [rax+2]
	xor	edx, edx
	mov	ecx, 2
	div	rcx
	test	rdx, rdx
	jne	SHORT $LN4@RtlUnicode
	mov	rax, QWORD PTR SourceString$[rsp]
	movzx	ecx, WORD PTR [rax]
	mov	rax, QWORD PTR SourceString$[rsp]
	movzx	eax, WORD PTR [rax+2]
	cmp	ecx, eax
	jg	SHORT $LN4@RtlUnicode
	mov	rax, QWORD PTR SourceString$[rsp]
	movzx	ecx, WORD PTR [rax+2]
	mov	rax, QWORD PTR cchMax$[rsp]
	shl	rax, 1
	cmp	rcx, rax
	jbe	SHORT $LN5@RtlUnicode
$LN4@RtlUnicode:

; 12182:         {
; 12183:             status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR status$[rsp], -1073741811	; ffffffffc000000dH

; 12184:         }
; 12185:         else if ((SourceString->Buffer == NULL) &&

	jmp	SHORT $LN3@RtlUnicode
$LN5@RtlUnicode:

; 12186:                  ((SourceString->Length != 0) || (SourceString->MaximumLength != 0)))

	mov	rax, QWORD PTR SourceString$[rsp]
	cmp	QWORD PTR [rax+8], 0
	jne	SHORT $LN2@RtlUnicode
	mov	rax, QWORD PTR SourceString$[rsp]
	movzx	eax, WORD PTR [rax]
	test	eax, eax
	jne	SHORT $LN1@RtlUnicode
	mov	rax, QWORD PTR SourceString$[rsp]
	movzx	eax, WORD PTR [rax+2]
	test	eax, eax
	je	SHORT $LN2@RtlUnicode
$LN1@RtlUnicode:

; 12187:         {
; 12188:             status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR status$[rsp], -1073741811	; ffffffffc000000dH
$LN2@RtlUnicode:
$LN3@RtlUnicode:
$LN7@RtlUnicode:

; 12189:         }
; 12190:     }
; 12191: 
; 12192:     return status;

	mov	eax, DWORD PTR status$[rsp]

; 12193: }

	add	rsp, 24
	ret	0
RtlUnicodeStringValidateWorker ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$RtlStringVPrintfWorkerA DD imagerel RtlStringVPrintfWorkerA
	DD	imagerel RtlStringVPrintfWorkerA+240
	DD	imagerel $unwind$RtlStringVPrintfWorkerA
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RtlStringVPrintfWorkerA DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT RtlStringVPrintfWorkerA
_TEXT	SEGMENT
cchNewDestLength$ = 32
cchMax$ = 40
iRet$ = 48
status$ = 52
pszDest$ = 80
cchDest$ = 88
pcchNewDestLength$ = 96
pszFormat$ = 104
argList$ = 112
RtlStringVPrintfWorkerA PROC				; COMDAT

; 11858: {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 11859:     NTSTATUS status = STATUS_SUCCESS;

	mov	DWORD PTR status$[rsp], 0

; 11860:     int iRet;
; 11861:     size_t cchMax;
; 11862:     size_t cchNewDestLength = 0;

	mov	QWORD PTR cchNewDestLength$[rsp], 0

; 11863: 
; 11864:     // leave the last space for the null terminator
; 11865:     cchMax = cchDest - 1;

	mov	rax, QWORD PTR cchDest$[rsp]
	sub	rax, 1
	mov	QWORD PTR cchMax$[rsp], rax

; 11866: 
; 11867: #if (NTSTRSAFE_USE_SECURE_CRT == 1) && !defined(NTSTRSAFE_LIB_IMPL)
; 11868:     iRet = _vsnprintf_s(pszDest, cchDest, cchMax, pszFormat, argList);
; 11869: #else
; 11870:     #pragma warning(push)
; 11871:     #pragma warning(disable: __WARNING_BANNED_API_USAGE)// "STRSAFE not included"
; 11872:     iRet = _vsnprintf(pszDest, cchMax, pszFormat, argList);

	mov	r9, QWORD PTR argList$[rsp]
	mov	r8, QWORD PTR pszFormat$[rsp]
	mov	rdx, QWORD PTR cchMax$[rsp]
	mov	rcx, QWORD PTR pszDest$[rsp]
	call	QWORD PTR __imp__vsnprintf
	mov	DWORD PTR iRet$[rsp], eax

; 11873:     #pragma warning(pop)
; 11874: #endif
; 11875:     // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));
; 11876: 
; 11877:     if ((iRet < 0) || (((size_t)iRet) > cchMax))

	cmp	DWORD PTR iRet$[rsp], 0
	jl	SHORT $LN5@RtlStringV
	movsxd	rax, DWORD PTR iRet$[rsp]
	cmp	rax, QWORD PTR cchMax$[rsp]
	jbe	SHORT $LN6@RtlStringV
$LN5@RtlStringV:

; 11878:     {
; 11879:         // need to null terminate the string
; 11880:         pszDest += cchMax;

	mov	rcx, QWORD PTR cchMax$[rsp]
	mov	rax, QWORD PTR pszDest$[rsp]
	add	rax, rcx
	mov	QWORD PTR pszDest$[rsp], rax

; 11881:         *pszDest = '\0';

	mov	rax, QWORD PTR pszDest$[rsp]
	mov	BYTE PTR [rax], 0

; 11882: 
; 11883:         cchNewDestLength = cchMax;

	mov	rax, QWORD PTR cchMax$[rsp]
	mov	QWORD PTR cchNewDestLength$[rsp], rax

; 11884: 
; 11885:         // we have truncated pszDest
; 11886:         status = STATUS_BUFFER_OVERFLOW;

	mov	DWORD PTR status$[rsp], -2147483643	; ffffffff80000005H
	jmp	SHORT $LN4@RtlStringV
$LN6@RtlStringV:

; 11887:     }
; 11888:     else if (((size_t)iRet) == cchMax)

	movsxd	rax, DWORD PTR iRet$[rsp]
	cmp	rax, QWORD PTR cchMax$[rsp]
	jne	SHORT $LN3@RtlStringV

; 11889:     {
; 11890:         // need to null terminate the string
; 11891:         pszDest += cchMax;

	mov	rcx, QWORD PTR cchMax$[rsp]
	mov	rax, QWORD PTR pszDest$[rsp]
	add	rax, rcx
	mov	QWORD PTR pszDest$[rsp], rax

; 11892:         *pszDest = '\0';

	mov	rax, QWORD PTR pszDest$[rsp]
	mov	BYTE PTR [rax], 0

; 11893: 
; 11894:         cchNewDestLength = cchMax;

	mov	rax, QWORD PTR cchMax$[rsp]
	mov	QWORD PTR cchNewDestLength$[rsp], rax

; 11895:     }
; 11896:     else

	jmp	SHORT $LN2@RtlStringV
$LN3@RtlStringV:

; 11897:     {
; 11898:         cchNewDestLength = (size_t)iRet;

	movsxd	rax, DWORD PTR iRet$[rsp]
	mov	QWORD PTR cchNewDestLength$[rsp], rax
$LN2@RtlStringV:
$LN4@RtlStringV:

; 11899:     }
; 11900: 
; 11901:     if (pcchNewDestLength)

	cmp	QWORD PTR pcchNewDestLength$[rsp], 0
	je	SHORT $LN1@RtlStringV

; 11902:     {
; 11903:         *pcchNewDestLength = cchNewDestLength;

	mov	rcx, QWORD PTR pcchNewDestLength$[rsp]
	mov	rax, QWORD PTR cchNewDestLength$[rsp]
	mov	QWORD PTR [rcx], rax
$LN1@RtlStringV:

; 11904:     }
; 11905: 
; 11906:     return status;

	mov	eax, DWORD PTR status$[rsp]

; 11907: }

	add	rsp, 72					; 00000048H
	ret	0
RtlStringVPrintfWorkerA ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$RtlStringCopyWorkerA DD imagerel RtlStringCopyWorkerA
	DD	imagerel RtlStringCopyWorkerA+232
	DD	imagerel $unwind$RtlStringCopyWorkerA
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RtlStringCopyWorkerA DD 011801H
	DD	02218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT RtlStringCopyWorkerA
_TEXT	SEGMENT
cchNewDestLength$ = 0
status$ = 8
pszDest$ = 32
cchDest$ = 40
pcchNewDestLength$ = 48
pszSrc$ = 56
cchToCopy$ = 64
RtlStringCopyWorkerA PROC				; COMDAT

; 11776: {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 11777:     NTSTATUS status = STATUS_SUCCESS;

	mov	DWORD PTR status$[rsp], 0

; 11778:     size_t cchNewDestLength = 0;

	mov	QWORD PTR cchNewDestLength$[rsp], 0
$LN4@RtlStringC:

; 11779:     
; 11780:     // ASSERT(cchDest != 0);
; 11781: 
; 11782:     while (cchDest && cchToCopy && (*pszSrc != '\0'))

	cmp	QWORD PTR cchDest$[rsp], 0
	je	SHORT $LN3@RtlStringC
	cmp	QWORD PTR cchToCopy$[rsp], 0
	je	SHORT $LN3@RtlStringC
	mov	rax, QWORD PTR pszSrc$[rsp]
	movsx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN3@RtlStringC

; 11783:     {
; 11784:         *pszDest++ = *pszSrc++;

	mov	rcx, QWORD PTR pszDest$[rsp]
	mov	rax, QWORD PTR pszSrc$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx], al
	mov	rax, QWORD PTR pszDest$[rsp]
	add	rax, 1
	mov	QWORD PTR pszDest$[rsp], rax
	mov	rax, QWORD PTR pszSrc$[rsp]
	add	rax, 1
	mov	QWORD PTR pszSrc$[rsp], rax

; 11785:         cchDest--;

	mov	rax, QWORD PTR cchDest$[rsp]
	sub	rax, 1
	mov	QWORD PTR cchDest$[rsp], rax

; 11786:         cchToCopy--;

	mov	rax, QWORD PTR cchToCopy$[rsp]
	sub	rax, 1
	mov	QWORD PTR cchToCopy$[rsp], rax

; 11787: 
; 11788:         cchNewDestLength++;

	mov	rax, QWORD PTR cchNewDestLength$[rsp]
	add	rax, 1
	mov	QWORD PTR cchNewDestLength$[rsp], rax

; 11789:     }

	jmp	SHORT $LN4@RtlStringC
$LN3@RtlStringC:

; 11790: 
; 11791:     if (cchDest == 0)

	cmp	QWORD PTR cchDest$[rsp], 0
	jne	SHORT $LN2@RtlStringC

; 11792:     {
; 11793:         // we are going to truncate pszDest
; 11794:         pszDest--;

	mov	rax, QWORD PTR pszDest$[rsp]
	sub	rax, 1
	mov	QWORD PTR pszDest$[rsp], rax

; 11795:         cchNewDestLength--;

	mov	rax, QWORD PTR cchNewDestLength$[rsp]
	sub	rax, 1
	mov	QWORD PTR cchNewDestLength$[rsp], rax

; 11796: 
; 11797:         status = STATUS_BUFFER_OVERFLOW;

	mov	DWORD PTR status$[rsp], -2147483643	; ffffffff80000005H
$LN2@RtlStringC:

; 11798:     }
; 11799: 
; 11800:     *pszDest = '\0';

	mov	rax, QWORD PTR pszDest$[rsp]
	mov	BYTE PTR [rax], 0

; 11801: 
; 11802:     if (pcchNewDestLength)

	cmp	QWORD PTR pcchNewDestLength$[rsp], 0
	je	SHORT $LN1@RtlStringC

; 11803:     {
; 11804:         *pcchNewDestLength = cchNewDestLength;

	mov	rcx, QWORD PTR pcchNewDestLength$[rsp]
	mov	rax, QWORD PTR cchNewDestLength$[rsp]
	mov	QWORD PTR [rcx], rax
$LN1@RtlStringC:

; 11805:     }
; 11806: 
; 11807:     return status;

	mov	eax, DWORD PTR status$[rsp]

; 11808: }

	add	rsp, 24
	ret	0
RtlStringCopyWorkerA ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$RtlStringValidateDestA DD imagerel RtlStringValidateDestA
	DD	imagerel RtlStringValidateDestA+61
	DD	imagerel $unwind$RtlStringValidateDestA
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RtlStringValidateDestA DD 011301H
	DD	02213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT RtlStringValidateDestA
_TEXT	SEGMENT
status$ = 0
pszDest$ = 32
cchDest$ = 40
cchMax$ = 48
RtlStringValidateDestA PROC				; COMDAT

; 11550: {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 11551:     NTSTATUS status = STATUS_SUCCESS;

	mov	DWORD PTR status$[rsp], 0

; 11552: 
; 11553:     if ((cchDest == 0) || (cchDest > cchMax))

	cmp	QWORD PTR cchDest$[rsp], 0
	je	SHORT $LN1@RtlStringV@2
	mov	rax, QWORD PTR cchMax$[rsp]
	cmp	QWORD PTR cchDest$[rsp], rax
	jbe	SHORT $LN2@RtlStringV@2
$LN1@RtlStringV@2:

; 11554:     {
; 11555:         status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR status$[rsp], -1073741811	; ffffffffc000000dH
$LN2@RtlStringV@2:

; 11556:     }
; 11557: 
; 11558:     return status;

	mov	eax, DWORD PTR status$[rsp]

; 11559: }

	add	rsp, 24
	ret	0
RtlStringValidateDestA ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$RtlStringCbPrintfA DD imagerel $LN4
	DD	imagerel $LN4+131
	DD	imagerel $unwind$RtlStringCbPrintfA
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RtlStringCbPrintfA DD 011801H
	DD	0a218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT RtlStringCbPrintfA
_TEXT	SEGMENT
status$ = 48
cchDest$ = 56
argList$26071 = 64
pszDest$ = 96
cbDest$ = 104
pszFormat$ = 112
RtlStringCbPrintfA PROC					; COMDAT

; 4503 : {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 88					; 00000058H

; 4504 :     NTSTATUS status;
; 4505 :     size_t cchDest = cbDest / sizeof(char);

	mov	rax, QWORD PTR cbDest$[rsp]
	mov	QWORD PTR cchDest$[rsp], rax

; 4506 : 
; 4507 :     status = RtlStringValidateDestA(pszDest, cchDest, NTSTRSAFE_MAX_CCH);

	mov	r8d, 2147483647				; 7fffffffH
	mov	rdx, QWORD PTR cchDest$[rsp]
	mov	rcx, QWORD PTR pszDest$[rsp]
	call	RtlStringValidateDestA
	mov	DWORD PTR status$[rsp], eax

; 4508 :     
; 4509 :     if (NT_SUCCESS(status))

	cmp	DWORD PTR status$[rsp], 0
	jl	SHORT $LN1@RtlStringC@2

; 4510 :     {
; 4511 :         va_list argList;
; 4512 : 
; 4513 :         va_start(argList, pszFormat);

	lea	rax, QWORD PTR pszFormat$[rsp+8]
	mov	QWORD PTR argList$26071[rsp], rax

; 4514 : 
; 4515 :         status = RtlStringVPrintfWorkerA(pszDest,
; 4516 :                                   cchDest,
; 4517 :                                   NULL,
; 4518 :                                   pszFormat,
; 4519 :                                   argList);

	mov	rax, QWORD PTR argList$26071[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR pszFormat$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR cchDest$[rsp]
	mov	rcx, QWORD PTR pszDest$[rsp]
	call	RtlStringVPrintfWorkerA
	mov	DWORD PTR status$[rsp], eax

; 4520 : 
; 4521 :         va_end(argList);

	mov	QWORD PTR argList$26071[rsp], 0
$LN1@RtlStringC@2:

; 4522 :     }
; 4523 : 
; 4524 :     return status;

	mov	eax, DWORD PTR status$[rsp]

; 4525 : }

	add	rsp, 88					; 00000058H
	ret	0
RtlStringCbPrintfA ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$RtlStringCbCopyA DD imagerel $LN4
	DD	imagerel $LN4+106
	DD	imagerel $unwind$RtlStringCbCopyA
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RtlStringCbCopyA DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT RtlStringCbCopyA
_TEXT	SEGMENT
status$ = 48
cchDest$ = 56
pszDest$ = 80
cbDest$ = 88
pszSrc$ = 96
RtlStringCbCopyA PROC					; COMDAT

; 632  : {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 633  :     NTSTATUS status;
; 634  :     size_t cchDest = cbDest / sizeof(char);

	mov	rax, QWORD PTR cbDest$[rsp]
	mov	QWORD PTR cchDest$[rsp], rax

; 635  : 
; 636  :     status = RtlStringValidateDestA(pszDest, cchDest, NTSTRSAFE_MAX_CCH);

	mov	r8d, 2147483647				; 7fffffffH
	mov	rdx, QWORD PTR cchDest$[rsp]
	mov	rcx, QWORD PTR pszDest$[rsp]
	call	RtlStringValidateDestA
	mov	DWORD PTR status$[rsp], eax

; 637  : 
; 638  :     if (NT_SUCCESS(status))

	cmp	DWORD PTR status$[rsp], 0
	jl	SHORT $LN1@RtlStringC@3

; 639  :     {
; 640  :         status = RtlStringCopyWorkerA(pszDest,
; 641  :                                cchDest,
; 642  :                                NULL,
; 643  :                                pszSrc,
; 644  :                                NTSTRSAFE_MAX_LENGTH);

	mov	QWORD PTR [rsp+32], 2147483646		; 7ffffffeH
	mov	r9, QWORD PTR pszSrc$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR cchDest$[rsp]
	mov	rcx, QWORD PTR pszDest$[rsp]
	call	RtlStringCopyWorkerA
	mov	DWORD PTR status$[rsp], eax
$LN1@RtlStringC@3:

; 645  :     }
; 646  : 
; 647  :     return status;

	mov	eax, DWORD PTR status$[rsp]

; 648  : }

	add	rsp, 72					; 00000048H
	ret	0
RtlStringCbCopyA ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\apps\pw7hp\devpgm\msddk\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$IoSkipCurrentIrpStackLocation DD imagerel $LN5
	DD	imagerel $LN5+131
	DD	imagerel $unwind$IoSkipCurrentIrpStackLocation
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IoSkipCurrentIrpStackLocation DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IoSkipCurrentIrpStackLocation
_TEXT	SEGMENT
tv73 = 32
Irp$ = 64
IoSkipCurrentIrpStackLocation PROC			; COMDAT

; 23945: {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 23946:     ASSERT(Irp->CurrentLocation <= Irp->StackCount);

	mov	rax, QWORD PTR Irp$[rsp]
	movsx	ecx, BYTE PTR [rax+67]
	mov	rax, QWORD PTR Irp$[rsp]
	movsx	eax, BYTE PTR [rax+66]
	cmp	ecx, eax
	jle	SHORT $LN3@IoSkipCurr
	xor	r9d, r9d
	mov	r8d, 23946				; 00005d8aH
	lea	rdx, OFFSET FLAT:??_C@_0CJ@NOBCDHO@c?3?2apps?2pw7hp?2devpgm?2msddk?2inc?2d@FNODOBFM@
	lea	rcx, OFFSET FLAT:??_C@_0CI@HDMHMCGD@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
	call	QWORD PTR __imp_RtlAssert
	mov	DWORD PTR tv73[rsp], 0
	jmp	SHORT $LN4@IoSkipCurr
$LN3@IoSkipCurr:
	mov	DWORD PTR tv73[rsp], 1
$LN4@IoSkipCurr:

; 23947:     Irp->CurrentLocation++;

	mov	rax, QWORD PTR Irp$[rsp]
	movzx	ecx, BYTE PTR [rax+67]
	add	cl, 1
	mov	rax, QWORD PTR Irp$[rsp]
	mov	BYTE PTR [rax+67], cl

; 23948:     Irp->Tail.Overlay.CurrentStackLocation++;

	mov	rcx, QWORD PTR Irp$[rsp]
	mov	rcx, QWORD PTR [rcx+184]
	add	rcx, 72					; 00000048H
	mov	rax, QWORD PTR Irp$[rsp]
	mov	QWORD PTR [rax+184], rcx

; 23949: }

	add	rsp, 56					; 00000038H
	ret	0
IoSkipCurrentIrpStackLocation ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$IoGetNextIrpStackLocation DD imagerel $LN5
	DD	imagerel $LN5+90
	DD	imagerel $unwind$IoGetNextIrpStackLocation
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IoGetNextIrpStackLocation DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IoGetNextIrpStackLocation
_TEXT	SEGMENT
tv71 = 32
Irp$ = 64
IoGetNextIrpStackLocation PROC				; COMDAT

; 23479: {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 23480:     ASSERT(Irp->CurrentLocation > 0);

	mov	rax, QWORD PTR Irp$[rsp]
	movsx	eax, BYTE PTR [rax+67]
	test	eax, eax
	jg	SHORT $LN3@IoGetNextI
	xor	r9d, r9d
	mov	r8d, 23480				; 00005bb8H
	lea	rdx, OFFSET FLAT:??_C@_0CJ@NOBCDHO@c?3?2apps?2pw7hp?2devpgm?2msddk?2inc?2d@FNODOBFM@
	lea	rcx, OFFSET FLAT:??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@
	call	QWORD PTR __imp_RtlAssert
	mov	DWORD PTR tv71[rsp], 0
	jmp	SHORT $LN4@IoGetNextI
$LN3@IoGetNextI:
	mov	DWORD PTR tv71[rsp], 1
$LN4@IoGetNextI:

; 23481: 
; 23482:     return ((Irp)->Tail.Overlay.CurrentStackLocation - 1 );

	mov	rax, QWORD PTR Irp$[rsp]
	mov	rax, QWORD PTR [rax+184]
	sub	rax, 72					; 00000048H

; 23483: }

	add	rsp, 56					; 00000038H
	ret	0
IoGetNextIrpStackLocation ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$IoGetCurrentIrpStackLocation DD imagerel $LN5
	DD	imagerel $LN5+98
	DD	imagerel $unwind$IoGetCurrentIrpStackLocation
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IoGetCurrentIrpStackLocation DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IoGetCurrentIrpStackLocation
_TEXT	SEGMENT
tv74 = 32
Irp$ = 64
IoGetCurrentIrpStackLocation PROC			; COMDAT

; 23316: {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 23317:     ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);

	mov	rax, QWORD PTR Irp$[rsp]
	movsx	ecx, BYTE PTR [rax+67]
	mov	rax, QWORD PTR Irp$[rsp]
	movsx	eax, BYTE PTR [rax+66]
	add	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN3@IoGetCurre
	xor	r9d, r9d
	mov	r8d, 23317				; 00005b15H
	lea	rdx, OFFSET FLAT:??_C@_0CJ@NOBCDHO@c?3?2apps?2pw7hp?2devpgm?2msddk?2inc?2d@FNODOBFM@
	lea	rcx, OFFSET FLAT:??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
	call	QWORD PTR __imp_RtlAssert
	mov	DWORD PTR tv74[rsp], 0
	jmp	SHORT $LN4@IoGetCurre
$LN3@IoGetCurre:
	mov	DWORD PTR tv74[rsp], 1
$LN4@IoGetCurre:

; 23318:     return Irp->Tail.Overlay.CurrentStackLocation;

	mov	rax, QWORD PTR Irp$[rsp]
	mov	rax, QWORD PTR [rax+184]

; 23319: }

	add	rsp, 56					; 00000038H
	ret	0
IoGetCurrentIrpStackLocation ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT KeInitializeSpinLock
_TEXT	SEGMENT
SpinLock$ = 8
KeInitializeSpinLock PROC				; COMDAT

; 15095: {

	mov	QWORD PTR [rsp+8], rcx

; 15096: 
; 15097:     *SpinLock = 0;

	mov	rax, QWORD PTR SpinLock$[rsp]
	mov	QWORD PTR [rax], 0

; 15098:     return;
; 15099: }

	ret	0
KeInitializeSpinLock ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$InsertTailList DD imagerel $LN3
	DD	imagerel $LN3+84
	DD	imagerel $unwind$InsertTailList
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$InsertTailList DD 010e01H
	DD	0220eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT InsertTailList
_TEXT	SEGMENT
Blink$ = 0
ListHead$ = 32
Entry$ = 40
InsertTailList PROC					; COMDAT

; 7621 : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 7622 :     PLIST_ENTRY Blink;
; 7623 : 
; 7624 :     Blink = ListHead->Blink;

	mov	rax, QWORD PTR ListHead$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR Blink$[rsp], rax

; 7625 :     Entry->Flink = ListHead;

	mov	rcx, QWORD PTR Entry$[rsp]
	mov	rax, QWORD PTR ListHead$[rsp]
	mov	QWORD PTR [rcx], rax

; 7626 :     Entry->Blink = Blink;

	mov	rcx, QWORD PTR Entry$[rsp]
	mov	rax, QWORD PTR Blink$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 7627 :     Blink->Flink = Entry;

	mov	rcx, QWORD PTR Blink$[rsp]
	mov	rax, QWORD PTR Entry$[rsp]
	mov	QWORD PTR [rcx], rax

; 7628 :     ListHead->Blink = Entry;

	mov	rcx, QWORD PTR ListHead$[rsp]
	mov	rax, QWORD PTR Entry$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 7629 : }

	add	rsp, 24
	ret	0
InsertTailList ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$RemoveHeadList DD imagerel $LN3
	DD	imagerel $LN3+69
	DD	imagerel $unwind$RemoveHeadList
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RemoveHeadList DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT RemoveHeadList
_TEXT	SEGMENT
Entry$ = 0
Flink$ = 8
ListHead$ = 32
RemoveHeadList PROC					; COMDAT

; 7585 : {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 7586 :     PLIST_ENTRY Flink;
; 7587 :     PLIST_ENTRY Entry;
; 7588 : 
; 7589 :     Entry = ListHead->Flink;

	mov	rax, QWORD PTR ListHead$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR Entry$[rsp], rax

; 7590 :     Flink = Entry->Flink;

	mov	rax, QWORD PTR Entry$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR Flink$[rsp], rax

; 7591 :     ListHead->Flink = Flink;

	mov	rcx, QWORD PTR ListHead$[rsp]
	mov	rax, QWORD PTR Flink$[rsp]
	mov	QWORD PTR [rcx], rax

; 7592 :     Flink->Blink = ListHead;

	mov	rcx, QWORD PTR Flink$[rsp]
	mov	rax, QWORD PTR ListHead$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 7593 :     return Entry;

	mov	rax, QWORD PTR Entry$[rsp]

; 7594 : }

	add	rsp, 24
	ret	0
RemoveHeadList ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$RemoveEntryList DD imagerel $LN5
	DD	imagerel $LN5+92
	DD	imagerel $unwind$RemoveEntryList
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RemoveEntryList DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT RemoveEntryList
_TEXT	SEGMENT
Flink$ = 0
Blink$ = 8
tv67 = 16
Entry$ = 48
RemoveEntryList PROC					; COMDAT

; 7569 : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 7570 :     PLIST_ENTRY Blink;
; 7571 :     PLIST_ENTRY Flink;
; 7572 : 
; 7573 :     Flink = Entry->Flink;

	mov	rax, QWORD PTR Entry$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR Flink$[rsp], rax

; 7574 :     Blink = Entry->Blink;

	mov	rax, QWORD PTR Entry$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR Blink$[rsp], rax

; 7575 :     Blink->Flink = Flink;

	mov	rcx, QWORD PTR Blink$[rsp]
	mov	rax, QWORD PTR Flink$[rsp]
	mov	QWORD PTR [rcx], rax

; 7576 :     Flink->Blink = Blink;

	mov	rcx, QWORD PTR Flink$[rsp]
	mov	rax, QWORD PTR Blink$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 7577 :     return (BOOLEAN)(Flink == Blink);

	mov	rax, QWORD PTR Blink$[rsp]
	cmp	QWORD PTR Flink$[rsp], rax
	jne	SHORT $LN3@RemoveEntr
	mov	BYTE PTR tv67[rsp], 1
	jmp	SHORT $LN4@RemoveEntr
$LN3@RemoveEntr:
	mov	BYTE PTR tv67[rsp], 0
$LN4@RemoveEntr:
	mov	al, BYTE PTR tv67[rsp]

; 7578 : }

	add	rsp, 40					; 00000028H
	ret	0
RemoveEntryList ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$IsListEmpty DD imagerel $LN5
	DD	imagerel $LN5+42
	DD	imagerel $unwind$IsListEmpty
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IsListEmpty DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IsListEmpty
_TEXT	SEGMENT
tv65 = 0
ListHead$ = 32
IsListEmpty PROC					; COMDAT

; 7560 : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 7561 :     return (BOOLEAN)(ListHead->Flink == ListHead);

	mov	rcx, QWORD PTR ListHead$[rsp]
	mov	rax, QWORD PTR ListHead$[rsp]
	cmp	QWORD PTR [rcx], rax
	jne	SHORT $LN3@IsListEmpt
	mov	BYTE PTR tv65[rsp], 1
	jmp	SHORT $LN4@IsListEmpt
$LN3@IsListEmpt:
	mov	BYTE PTR tv65[rsp], 0
$LN4@IsListEmpt:
	mov	al, BYTE PTR tv65[rsp]

; 7562 : }

	add	rsp, 24
	ret	0
IsListEmpty ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT InitializeListHead
_TEXT	SEGMENT
ListHead$ = 8
InitializeListHead PROC					; COMDAT

; 7550 : {

	mov	QWORD PTR [rsp+8], rcx

; 7551 :     ListHead->Flink = ListHead->Blink = ListHead;

	mov	rcx, QWORD PTR ListHead$[rsp]
	mov	rax, QWORD PTR ListHead$[rsp]
	mov	QWORD PTR [rcx+8], rax
	mov	rcx, QWORD PTR ListHead$[rsp]
	mov	rax, QWORD PTR ListHead$[rsp]
	mov	QWORD PTR [rcx], rax

; 7552 : }

	ret	0
InitializeListHead ENDP
;	COMDAT pdata
; File b:\programm\wntsys\testfilter\release\1_1\source\driver\drvmain.cpp
pdata	SEGMENT
$pdata$?QueueCltIrpForCompletion@@YAXPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z DD imagerel ?QueueCltIrpForCompletion@@YAXPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z
	DD	imagerel ?QueueCltIrpForCompletion@@YAXPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z+93
	DD	imagerel $unwind$?QueueCltIrpForCompletion@@YAXPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?QueueCltIrpForCompletion@@YAXPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?QueueCltIrpForCompletion@@YAXPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z
_TEXT	SEGMENT
pDevExt$ = 48
pCltIrp$ = 56
?QueueCltIrpForCompletion@@YAXPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z PROC ; QueueCltIrpForCompletion, COMDAT

; 3027 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 3028 : 	InsertTailList(
; 3029 : 		&pDevExt->pWaitingComplIrpList,
; 3030 : 		&pCltIrp->Tail.Overlay.ListEntry);

	mov	rdx, QWORD PTR pCltIrp$[rsp]
	add	rdx, 168				; 000000a8H
	mov	rcx, QWORD PTR pDevExt$[rsp]
	add	rcx, 296				; 00000128H
	call	InsertTailList

; 3031 : 	KeInsertQueueDpc(
; 3032 : 		&pDevExt->ComplDpc,
; 3033 : 		NULL,
; 3034 : 		NULL);

	mov	rcx, QWORD PTR pDevExt$[rsp]
	add	rcx, 16
	xor	r8d, r8d
	xor	edx, edx
	call	QWORD PTR __imp_KeInsertQueueDpc

; 3035 : 
; 3036 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 3037 : 		"FLT - QueueCltIrpForCompletion - Client IRP %#p queued "
; 3038 : 		"for completion\n", 
; 3039 : 		pCltIrp);

	mov	r9, QWORD PTR pCltIrp$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0EH@FIHPDACL@FLT?5?9?5QueueCltIrpForCompletion?5?9@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 3040 : }

	add	rsp, 40					; 00000028H
	ret	0
?QueueCltIrpForCompletion@@YAXPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z ENDP ; QueueCltIrpForCompletion
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MoveIrpDataToCltIrp@@YAXPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z DD imagerel ?MoveIrpDataToCltIrp@@YAXPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z
	DD	imagerel ?MoveIrpDataToCltIrp@@YAXPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z+664
	DD	imagerel $unwind$?MoveIrpDataToCltIrp@@YAXPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MoveIrpDataToCltIrp@@YAXPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z DD 041301H
	DD	0150113H
	DD	0600b700cH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?MoveIrpDataToCltIrp@@YAXPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z
_TEXT	SEGMENT
pTmpRecvPointer$ = 48
maxDataLen$ = 56
cbRemaining$ = 64
pOutBuf$ = 72
pMdl$ = 80
tmpRemaining$ = 88
pCbuf$ = 96
cbBytesToRead$ = 104
irpHeader$ = 112
status$ = 128
pIoStack$ = 136
cbXtractOffset$ = 144
tv77 = 152
pDevExt$ = 192
pCltIrp$ = 200
?MoveIrpDataToCltIrp@@YAXPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z PROC ; MoveIrpDataToCltIrp, COMDAT

; 2837 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 168				; 000000a8H

; 2838 : 	NTSTATUS status;
; 2839 : 
; 2840 : 	// The client IRP is for the filter access device, which does
; 2841 : 	// direct I/O.
; 2842 : 	//
; 2843 : 	PMDL pMdl = pCltIrp->MdlAddress;

	mov	rax, QWORD PTR pCltIrp$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR pMdl$[rsp], rax

; 2844 : 	PCHAR pOutBuf = (PCHAR) MmGetSystemAddressForMdlSafe(pMdl, 
; 2845 : 			LowPagePriority);

	mov	rax, QWORD PTR pMdl$[rsp]
	movsx	eax, WORD PTR [rax+10]
	and	eax, 5
	test	eax, eax
	je	SHORT $LN6@MoveIrpDat
	mov	rax, QWORD PTR pMdl$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR tv77[rsp], rax
	jmp	SHORT $LN7@MoveIrpDat
$LN6@MoveIrpDat:
	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8d, 1
	xor	edx, edx
	mov	rcx, QWORD PTR pMdl$[rsp]
	call	QWORD PTR __imp_MmMapLockedPagesSpecifyCache
	mov	QWORD PTR tv77[rsp], rax
$LN7@MoveIrpDat:
	mov	rax, QWORD PTR tv77[rsp]
	mov	QWORD PTR pOutBuf$[rsp], rax

; 2846 : 	if (pOutBuf == NULL) {

	cmp	QWORD PTR pOutBuf$[rsp], 0
	jne	SHORT $LN3@MoveIrpDat

; 2847 : 
; 2848 : 		// This should never happen, because the MDL has already been
; 2849 : 		// locked by the I/O manager.
; 2850 : 		//
; 2851 : 		pCltIrp->IoStatus.Status = STATUS_NO_MEMORY;

	mov	rax, QWORD PTR pCltIrp$[rsp]
	mov	DWORD PTR [rax+48], -1073741801		; ffffffffc0000017H

; 2852 : 		pCltIrp->IoStatus.Information = 0;

	mov	rax, QWORD PTR pCltIrp$[rsp]
	mov	QWORD PTR [rax+56], 0

; 2853 : 		return;

	jmp	$LN4@MoveIrpDat
$LN3@MoveIrpDat:

; 2854 : 	}
; 2855 : 	PIO_STACK_LOCATION pIoStack = IoGetCurrentIrpStackLocation(pCltIrp);

	mov	rcx, QWORD PTR pCltIrp$[rsp]
	call	IoGetCurrentIrpStackLocation
	mov	QWORD PTR pIoStack$[rsp], rax

; 2856 : 	SIZE_T cbRemaining = pIoStack->Parameters.Read.Length;

	mov	rax, QWORD PTR pIoStack$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	QWORD PTR cbRemaining$[rsp], rax

; 2857 : 
; 2858 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 2859 : 		"FLT - MoveIrpDataToCltIrp - Client IRP %#p: buffer %#p, "
; 2860 : 		"len: %#x\n",
; 2861 : 		pCltIrp,
; 2862 : 		pOutBuf,
; 2863 : 		cbRemaining);

	mov	rax, QWORD PTR cbRemaining$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR pOutBuf$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR pCltIrp$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0EC@MMEJNLGB@FLT?5?9?5MoveIrpDataToCltIrp?5?9?5Clie@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 2864 : 
; 2865 : 	// We know that the data block is header + IRP + I/O stack +
; 2866 : 	// (optionally) data.
; 2867 : 	//
; 2868 : 	// We also know that cbRemaining is >= the length of header, IRP and
; 2869 : 	// I/O stack, because this is checked when client IRPs are received.
; 2870 : 	//
; 2871 : 	// Let's start by transferring the header.
; 2872 : 	//
; 2873 : 	PCIRCULAR_BUFFER pCbuf = &pDevExt->DataBuffer;

	mov	rax, QWORD PTR pDevExt$[rsp]
	add	rax, 80					; 00000050H
	mov	QWORD PTR pCbuf$[rsp], rax

; 2874 : 
; 2875 : 	// Extract the IRP header into a local variable, because we will 
; 2876 : 	// need to access it here.
; 2877 : 	//
; 2878 : 	IRP_HEADER irpHeader;
; 2879 : 	PCHAR pTmpRecvPointer = (PCHAR) &irpHeader;

	lea	rax, QWORD PTR irpHeader$[rsp]
	mov	QWORD PTR pTmpRecvPointer$[rsp], rax

; 2880 : 	SIZE_T tmpRemaining = sizeof irpHeader;

	mov	QWORD PTR tmpRemaining$[rsp], 16

; 2881 : 	SIZE_T cbBytesToRead = sizeof irpHeader;

	mov	QWORD PTR cbBytesToRead$[rsp], 16

; 2882 : 	SIZE_T cbXtractOffset = 0;

	mov	QWORD PTR cbXtractOffset$[rsp], 0

; 2883 : 	status = CBXtractFromStart(
; 2884 : 		pCbuf,
; 2885 : 		&cbXtractOffset,
; 2886 : 		&pTmpRecvPointer,
; 2887 : 		&tmpRemaining,
; 2888 : 		&cbBytesToRead,
; 2889 : 		NULL);

	mov	QWORD PTR [rsp+40], 0
	lea	rax, QWORD PTR cbBytesToRead$[rsp]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR tmpRemaining$[rsp]
	lea	r8, QWORD PTR pTmpRecvPointer$[rsp]
	lea	rdx, QWORD PTR cbXtractOffset$[rsp]
	mov	rcx, QWORD PTR pCbuf$[rsp]
	call	?CBXtractFromStart@@YAJPEAU_CIRCULAR_BUFFER@@PEA_KPEAPEAD111@Z ; CBXtractFromStart
	mov	DWORD PTR status$[rsp], eax

; 2890 : 	if (!NT_SUCCESS(status)) {

	cmp	DWORD PTR status$[rsp], 0
	jge	SHORT $LN2@MoveIrpDat

; 2891 : 
; 2892 : 		// This should not happen. It means that there is no data
; 2893 : 		// into the buffer, which should be prevented by design.
; 2894 : 		//
; 2895 : 		pCltIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;

	mov	rax, QWORD PTR pCltIrp$[rsp]
	mov	DWORD PTR [rax+48], -1073741823		; ffffffffc0000001H

; 2896 : 		pCltIrp->IoStatus.Information = 0;

	mov	rax, QWORD PTR pCltIrp$[rsp]
	mov	QWORD PTR [rax+56], 0

; 2897 : 		return;

	jmp	$LN4@MoveIrpDat
$LN2@MoveIrpDat:

; 2898 : 	}
; 2899 : 
; 2900 : 	// Look into the header to see if there are data bytes following 
; 2901 : 	// the IRP and set a flag if the buffer isn't big enough.
; 2902 : 	//
; 2903 : 	SIZE_T maxDataLen  = cbRemaining - sizeof (IRP_HEADER) -
; 2904 : 		sizeof (IRP) - sizeof(IO_STACK_LOCATION);

	mov	rax, QWORD PTR cbRemaining$[rsp]
	sub	rax, 296				; 00000128H
	mov	QWORD PTR maxDataLen$[rsp], rax

; 2905 : 	if (irpHeader.cbDataLen > maxDataLen) {

	mov	rax, QWORD PTR maxDataLen$[rsp]
	cmp	QWORD PTR irpHeader$[rsp+8], rax
	jbe	SHORT $LN1@MoveIrpDat

; 2906 : 		irpHeader.dwFlags |= IRPSTAT_DATA_LOST;

	mov	eax, DWORD PTR irpHeader$[rsp]
	or	eax, 1
	mov	DWORD PTR irpHeader$[rsp], eax

; 2907 : 
; 2908 : 		// Adjust the data length returned to the client.
; 2909 : 		//
; 2910 : 		irpHeader.cbDataLen = maxDataLen;

	mov	rax, QWORD PTR maxDataLen$[rsp]
	mov	QWORD PTR irpHeader$[rsp+8], rax
$LN1@MoveIrpDat:

; 2911 : 	}
; 2912 : 
; 2913 : 	// Copy the header content into the output buffer.
; 2914 : 	//
; 2915 : 	RtlCopyMemory(pOutBuf, &irpHeader, sizeof irpHeader);

	lea	rsi, QWORD PTR irpHeader$[rsp]
	mov	rdi, QWORD PTR pOutBuf$[rsp]
	mov	ecx, 16
	rep movsb

; 2916 : 	pOutBuf += sizeof irpHeader;

	mov	rax, QWORD PTR pOutBuf$[rsp]
	add	rax, 16
	mov	QWORD PTR pOutBuf$[rsp], rax

; 2917 : 	cbRemaining -= sizeof irpHeader;

	mov	rax, QWORD PTR cbRemaining$[rsp]
	sub	rax, 16
	mov	QWORD PTR cbRemaining$[rsp], rax

; 2918 : 
; 2919 : 	// Extract the remainder of the data block directly into the output 
; 2920 : 	// buffer.
; 2921 : 	//
; 2922 : 	// We are sure we have at least the IRP and the I/O stack location 
; 2923 : 	// to tansfer. Optionally, we'll transfer some data, if there are 
; 2924 : 	// any and if there's room in the client buffer.
; 2925 : 	//
; 2926 : 	CBXtractFromStart(
; 2927 : 		pCbuf,
; 2928 : 		&cbXtractOffset,
; 2929 : 		&pOutBuf,
; 2930 : 		&cbRemaining,
; 2931 : 		NULL,
; 2932 : 		NULL);

	mov	QWORD PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR cbRemaining$[rsp]
	lea	r8, QWORD PTR pOutBuf$[rsp]
	lea	rdx, QWORD PTR cbXtractOffset$[rsp]
	mov	rcx, QWORD PTR pCbuf$[rsp]
	call	?CBXtractFromStart@@YAJPEAU_CIRCULAR_BUFFER@@PEA_KPEAPEAD111@Z ; CBXtractFromStart

; 2933 : 
; 2934 : 	// cbRemaining was originally set to the client buffer size, so we
; 2935 : 	// can compute the number of bytes transferred.
; 2936 : 	//
; 2937 : 	pCltIrp->IoStatus.Information = pIoStack->Parameters.Read.Length -
; 2938 : 		cbRemaining;

	mov	rdx, QWORD PTR pIoStack$[rsp]
	mov	ecx, DWORD PTR [rdx+8]
	sub	rcx, QWORD PTR cbRemaining$[rsp]
	mov	rax, QWORD PTR pCltIrp$[rsp]
	mov	QWORD PTR [rax+56], rcx

; 2939 : 	pCltIrp->IoStatus.Status = STATUS_SUCCESS;

	mov	rax, QWORD PTR pCltIrp$[rsp]
	mov	DWORD PTR [rax+48], 0

; 2940 : 
; 2941 : 
; 2942 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 2943 : 		"FLT - MoveIrpDataToCltIrp - Passed %#x bytes of data to "
; 2944 : 		"IRP %#p\n", 
; 2945 : 		pCltIrp->IoStatus.Information, pCltIrp);

	mov	rax, QWORD PTR pCltIrp$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR pCltIrp$[rsp]
	mov	r9, QWORD PTR [r9+56]
	lea	r8, OFFSET FLAT:??_C@_0EB@GMMKCGII@FLT?5?9?5MoveIrpDataToCltIrp?5?9?5Pass@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 2946 : 
; 2947 : 	// Discard the data block from the buffer
; 2948 : 	//
; 2949 : 	CBFreeOldestDataBlock(pCbuf);

	mov	rcx, QWORD PTR pCbuf$[rsp]
	call	?CBFreeOldestDataBlock@@YAXPEAU_CIRCULAR_BUFFER@@@Z ; CBFreeOldestDataBlock
$LN4@MoveIrpDat:

; 2950 : 	return;
; 2951 : }

	add	rsp, 168				; 000000a8H
	pop	rdi
	pop	rsi
	ret	0
?MoveIrpDataToCltIrp@@YAXPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z ENDP ; MoveIrpDataToCltIrp
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IoctlSetMJFFlags@@YAJPEAU_IRP@@PEAU_DEVICE_EXTENSION@@@Z DD imagerel ?IoctlSetMJFFlags@@YAJPEAU_IRP@@PEAU_DEVICE_EXTENSION@@@Z
	DD	imagerel ?IoctlSetMJFFlags@@YAJPEAU_IRP@@PEAU_DEVICE_EXTENSION@@@Z+263
	DD	imagerel $unwind$?IoctlSetMJFFlags@@YAJPEAU_IRP@@PEAU_DEVICE_EXTENSION@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IoctlSetMJFFlags@@YAJPEAU_IRP@@PEAU_DEVICE_EXTENSION@@@Z DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?IoctlSetMJFFlags@@YAJPEAU_IRP@@PEAU_DEVICE_EXTENSION@@@Z
_TEXT	SEGMENT
pNewFlags$ = 32
pStack$ = 40
MajFun$ = 48
status$ = 52
i$29054 = 56
pIrp$ = 80
pFltDevExt$ = 88
?IoctlSetMJFFlags@@YAJPEAU_IRP@@PEAU_DEVICE_EXTENSION@@@Z PROC ; IoctlSetMJFFlags, COMDAT

; 2465 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2466 : 	NTSTATUS status = STATUS_UNSUCCESSFUL;

	mov	DWORD PTR status$[rsp], -1073741823	; ffffffffc0000001H

; 2467 : 	pIrp->IoStatus.Information = 0;

	mov	rax, QWORD PTR pIrp$[rsp]
	mov	QWORD PTR [rax+56], 0

; 2468 : 	PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoGetCurrentIrpStackLocation
	mov	QWORD PTR pStack$[rsp], rax

; 2469 : 	if (pStack->Parameters.DeviceIoControl.InputBufferLength <
; 2470 : 		sizeof (MJF_CONTROL)) {

	mov	rax, QWORD PTR pStack$[rsp]
	mov	eax, DWORD PTR [rax+16]
	cmp	rax, 8
	jae	SHORT $LN9@IoctlSetMJ

; 2471 : 		status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR status$[rsp], -1073741811	; ffffffffc000000dH
	jmp	$LN8@IoctlSetMJ

; 2472 : 		goto QUIT;

	jmp	$QUIT$29048
$LN9@IoctlSetMJ:

; 2473 : 	}
; 2474 : 	PMJF_CONTROL pNewFlags = 
; 2475 : 		(PMJF_CONTROL) pIrp->AssociatedIrp.SystemBuffer;

	mov	rax, QWORD PTR pIrp$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR pNewFlags$[rsp], rax

; 2476 : 	UCHAR MajFun = pNewFlags->MajorFunction;

	mov	rax, QWORD PTR pNewFlags$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR MajFun$[rsp], al

; 2477 : 	if (MajFun == 0xff) {

	movzx	eax, BYTE PTR MajFun$[rsp]
	cmp	eax, 255				; 000000ffH
	jne	SHORT $LN7@IoctlSetMJ

; 2478 : 
; 2479 : 		// 0xff means to set the flags for all the function codes.
; 2480 : 		//
; 2481 : 		for (INT i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) {

	mov	DWORD PTR i$29054[rsp], 0
	jmp	SHORT $LN6@IoctlSetMJ
$LN5@IoctlSetMJ:
	mov	eax, DWORD PTR i$29054[rsp]
	add	eax, 1
	mov	DWORD PTR i$29054[rsp], eax
$LN6@IoctlSetMJ:
	cmp	DWORD PTR i$29054[rsp], 27
	jge	SHORT $LN4@IoctlSetMJ

; 2482 : 			pFltDevExt->dwMJFlags[i] = pNewFlags->dwFlags;

	movsxd	rdx, DWORD PTR i$29054[rsp]
	mov	rcx, QWORD PTR pFltDevExt$[rsp]
	mov	rax, QWORD PTR pNewFlags$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR [rcx+rdx*4+148], eax

; 2483 : 		}

	jmp	SHORT $LN5@IoctlSetMJ
$LN4@IoctlSetMJ:

; 2484 : 		status = STATUS_SUCCESS;

	mov	DWORD PTR status$[rsp], 0
	jmp	SHORT $LN3@IoctlSetMJ

; 2485 : 		goto QUIT;

	jmp	SHORT $QUIT$29048
$LN7@IoctlSetMJ:

; 2486 : 	}
; 2487 : 	if (MajFun > IRP_MJ_MAXIMUM_FUNCTION) {

	movzx	eax, BYTE PTR MajFun$[rsp]
	cmp	eax, 27
	jle	SHORT $LN2@IoctlSetMJ

; 2488 : 		status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR status$[rsp], -1073741811	; ffffffffc000000dH
	jmp	SHORT $LN1@IoctlSetMJ

; 2489 : 		goto QUIT;

	jmp	SHORT $QUIT$29048
$LN2@IoctlSetMJ:

; 2490 : 	}
; 2491 : 	pFltDevExt->dwMJFlags[MajFun] = pNewFlags->dwFlags;

	movzx	edx, BYTE PTR MajFun$[rsp]
	mov	rcx, QWORD PTR pFltDevExt$[rsp]
	mov	rax, QWORD PTR pNewFlags$[rsp]
	mov	eax, DWORD PTR [rax+4]
	mov	DWORD PTR [rcx+rdx*4+148], eax

; 2492 :     status = STATUS_SUCCESS;

	mov	DWORD PTR status$[rsp], 0
$LN1@IoctlSetMJ:
$LN3@IoctlSetMJ:
$LN8@IoctlSetMJ:
$QUIT$29048:

; 2493 : 
; 2494 : QUIT:
; 2495 : 	pIrp->IoStatus.Status = status;

	mov	rcx, QWORD PTR pIrp$[rsp]
	mov	eax, DWORD PTR status$[rsp]
	mov	DWORD PTR [rcx+48], eax

; 2496 : 	return status;

	mov	eax, DWORD PTR status$[rsp]

; 2497 : }

	add	rsp, 72					; 00000048H
	ret	0
?IoctlSetMJFFlags@@YAJPEAU_IRP@@PEAU_DEVICE_EXTENSION@@@Z ENDP ; IoctlSetMJFFlags
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?IoctlGetMJFFlags@@YAJPEAU_IRP@@PEAU_DEVICE_EXTENSION@@@Z DD imagerel ?IoctlGetMJFFlags@@YAJPEAU_IRP@@PEAU_DEVICE_EXTENSION@@@Z
	DD	imagerel ?IoctlGetMJFFlags@@YAJPEAU_IRP@@PEAU_DEVICE_EXTENSION@@@Z+191
	DD	imagerel $unwind$?IoctlGetMJFFlags@@YAJPEAU_IRP@@PEAU_DEVICE_EXTENSION@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?IoctlGetMJFFlags@@YAJPEAU_IRP@@PEAU_DEVICE_EXTENSION@@@Z DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?IoctlGetMJFFlags@@YAJPEAU_IRP@@PEAU_DEVICE_EXTENSION@@@Z
_TEXT	SEGMENT
pOutFlags$ = 32
pStack$ = 40
MajFun$ = 48
status$ = 52
pIrp$ = 80
pFltDevExt$ = 88
?IoctlGetMJFFlags@@YAJPEAU_IRP@@PEAU_DEVICE_EXTENSION@@@Z PROC ; IoctlGetMJFFlags, COMDAT

; 2420 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2421 : 	NTSTATUS status = STATUS_UNSUCCESSFUL;

	mov	DWORD PTR status$[rsp], -1073741823	; ffffffffc0000001H

; 2422 : 	pIrp->IoStatus.Information = 0;

	mov	rax, QWORD PTR pIrp$[rsp]
	mov	QWORD PTR [rax+56], 0

; 2423 : 	PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoGetCurrentIrpStackLocation
	mov	QWORD PTR pStack$[rsp], rax

; 2424 : 	if (pStack->Parameters.DeviceIoControl.OutputBufferLength <
; 2425 : 		sizeof (MJF_CONTROL)) {

	mov	rax, QWORD PTR pStack$[rsp]
	mov	eax, DWORD PTR [rax+8]
	cmp	rax, 8
	jae	SHORT $LN4@IoctlGetMJ

; 2426 : 		status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR status$[rsp], -1073741811	; ffffffffc000000dH
	jmp	SHORT $LN3@IoctlGetMJ

; 2427 : 		goto QUIT;

	jmp	SHORT $QUIT$29028
$LN4@IoctlGetMJ:

; 2428 : 	}
; 2429 : 	PMJF_CONTROL pOutFlags = 
; 2430 : 		(PMJF_CONTROL) pIrp->AssociatedIrp.SystemBuffer;

	mov	rax, QWORD PTR pIrp$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR pOutFlags$[rsp], rax

; 2431 : 	UCHAR MajFun = pOutFlags->MajorFunction;

	mov	rax, QWORD PTR pOutFlags$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR MajFun$[rsp], al

; 2432 : 	if (MajFun > IRP_MJ_MAXIMUM_FUNCTION) {

	movzx	eax, BYTE PTR MajFun$[rsp]
	cmp	eax, 27
	jle	SHORT $LN2@IoctlGetMJ

; 2433 : 		status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR status$[rsp], -1073741811	; ffffffffc000000dH
	jmp	SHORT $LN1@IoctlGetMJ

; 2434 : 		goto QUIT;

	jmp	SHORT $QUIT$29028
$LN2@IoctlGetMJ:

; 2435 : 	}
; 2436 : 	pOutFlags->dwFlags = pFltDevExt->dwMJFlags[MajFun];

	movzx	edx, BYTE PTR MajFun$[rsp]
	mov	rcx, QWORD PTR pOutFlags$[rsp]
	mov	rax, QWORD PTR pFltDevExt$[rsp]
	mov	eax, DWORD PTR [rax+rdx*4+148]
	mov	DWORD PTR [rcx+4], eax

; 2437 :     status = STATUS_SUCCESS;

	mov	DWORD PTR status$[rsp], 0

; 2438 : 	pIrp->IoStatus.Information = sizeof (MJF_CONTROL);

	mov	rax, QWORD PTR pIrp$[rsp]
	mov	QWORD PTR [rax+56], 8
$LN1@IoctlGetMJ:
$LN3@IoctlGetMJ:
$QUIT$29028:

; 2439 : 
; 2440 : QUIT:
; 2441 : 	pIrp->IoStatus.Status = status;

	mov	rcx, QWORD PTR pIrp$[rsp]
	mov	eax, DWORD PTR status$[rsp]
	mov	DWORD PTR [rcx+48], eax

; 2442 : 	return status;

	mov	eax, DWORD PTR status$[rsp]

; 2443 : }

	add	rsp, 72					; 00000048H
	ret	0
?IoctlGetMJFFlags@@YAJPEAU_IRP@@PEAU_DEVICE_EXTENSION@@@Z ENDP ; IoctlGetMJFFlags
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?InterceptIrpAndData@@YAXPEAU_IRP@@PEAX_KPEAU_DEVICE_EXTENSION@@@Z DD imagerel ?InterceptIrpAndData@@YAXPEAU_IRP@@PEAX_KPEAU_DEVICE_EXTENSION@@@Z
	DD	imagerel ?InterceptIrpAndData@@YAXPEAU_IRP@@PEAX_KPEAU_DEVICE_EXTENSION@@@Z+564
	DD	imagerel $unwind$?InterceptIrpAndData@@YAXPEAU_IRP@@PEAX_KPEAU_DEVICE_EXTENSION@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?InterceptIrpAndData@@YAXPEAU_IRP@@PEAX_KPEAU_DEVICE_EXTENSION@@@Z DD 021901H
	DD	07015d219H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?InterceptIrpAndData@@YAXPEAU_IRP@@PEAX_KPEAU_DEVICE_EXTENSION@@@Z
_TEXT	SEGMENT
IrpHea$ = 48
pStore$ = 64
status$ = 72
cbStoreLength$ = 80
pBuf$ = 88
cbBlockOffset$ = 96
pIrp$ = 128
pData$ = 136
cbDataLen$ = 144
pDevExt$ = 152
?InterceptIrpAndData@@YAXPEAU_IRP@@PEAX_KPEAU_DEVICE_EXTENSION@@@Z PROC ; InterceptIrpAndData, COMDAT

; 2316 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 112				; 00000070H

; 2317 : 	PCIRCULAR_BUFFER pBuf = &pDevExt->DataBuffer;

	mov	rax, QWORD PTR pDevExt$[rsp]
	add	rax, 80					; 00000050H
	mov	QWORD PTR pBuf$[rsp], rax

; 2318 : 	NTSTATUS		status;
; 2319 : 
; 2320 : 	// Allocate a buffer block to store the IRP with its header,
; 2321 : 	// its I/O stack loc and its data, iF any.
; 2322 : 	//
; 2323 : 	status = CBAllocateBlock(
; 2324 : 		pBuf,
; 2325 : 		sizeof (IRP_HEADER) + sizeof (IRP) + sizeof(IO_STACK_LOCATION) + 
; 2326 : 			cbDataLen
; 2327 : 	);

	mov	rdx, QWORD PTR cbDataLen$[rsp]
	add	rdx, 296				; 00000128H
	mov	rcx, QWORD PTR pBuf$[rsp]
	call	?CBAllocateBlock@@YAJPEAU_CIRCULAR_BUFFER@@_K@Z ; CBAllocateBlock
	mov	DWORD PTR status$[rsp], eax

; 2328 : 
; 2329 : 	if (NT_ERROR(status)) {	// This should happen only if the size

	mov	eax, DWORD PTR status$[rsp]
	shr	eax, 30
	cmp	eax, 3
	jne	SHORT $LN3@InterceptI

; 2330 : 								// is greater than the entire buffer 
; 2331 : 								// size
; 2332 : 
; 2333 : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 2334 : 			"FLT - InterceptIrpAndData - Buffer allocation failed "
; 2335 : 			"with status: %#010x\n", 
; 2336 : 			status);

	mov	r9d, DWORD PTR status$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0EK@OJJBHMCK@FLT?5?9?5InterceptIrpAndData?5?9?5Buff@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 2337 : 		// Set the data lost flag and quit
; 2338 : 		//
; 2339 : 		pDevExt->dwStatus |= FSTATUS_DATA_LOST;

	mov	rdx, QWORD PTR pDevExt$[rsp]
	mov	ecx, DWORD PTR [rdx+260]
	or	ecx, 1
	mov	rax, QWORD PTR pDevExt$[rsp]
	mov	DWORD PTR [rax+260], ecx

; 2340 : 		return;

	jmp	$LN4@InterceptI
$LN3@InterceptI:

; 2341 : 	}
; 2342 : 
; 2343 : 	if (status == CB_STATUS_WARN_DATA_LOST) {	// Data has been thrown 

	cmp	DWORD PTR status$[rsp], -1610612735	; ffffffffa0000001H
	jne	SHORT $LN2@InterceptI

; 2344 : 		// out to make room into the buffer.
; 2345 : 
; 2346 : 		pDevExt->dwStatus |= FSTATUS_DATA_LOST;

	mov	rax, QWORD PTR pDevExt$[rsp]
	mov	ecx, DWORD PTR [rax+260]
	or	ecx, 1
	mov	rax, QWORD PTR pDevExt$[rsp]
	mov	DWORD PTR [rax+260], ecx
$LN2@InterceptI:

; 2347 : 	}
; 2348 : 
; 2349 : 	// Set up the IRP header and store it into the buffer.
; 2350 : 	//
; 2351 : 	IRP_HEADER IrpHea = {0};

	mov	DWORD PTR IrpHea$[rsp], 0
	lea	rdi, QWORD PTR IrpHea$[rsp+8]
	xor	eax, eax
	mov	ecx, 8
	rep stosb

; 2352 : 	IrpHea.cbDataLen = cbDataLen;

	mov	rax, QWORD PTR cbDataLen$[rsp]
	mov	QWORD PTR IrpHea$[rsp+8], rax

; 2353 : 	PCHAR pStore = (PCHAR) &IrpHea;

	lea	rax, QWORD PTR IrpHea$[rsp]
	mov	QWORD PTR pStore$[rsp], rax

; 2354 : 	SIZE_T cbBlockOffset = 0;

	mov	QWORD PTR cbBlockOffset$[rsp], 0

; 2355 : 	SIZE_T cbStoreLength = sizeof IrpHea;

	mov	QWORD PTR cbStoreLength$[rsp], 16

; 2356 : 
; 2357 : 	// Don't check CBStore ret status, because we are sure we have 
; 2358 : 	// allocated the block.
; 2359 : 	//
; 2360 : 	CBStore(pBuf, &pStore, &cbStoreLength, &cbBlockOffset, NULL);

	mov	QWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR cbBlockOffset$[rsp]
	lea	r8, QWORD PTR cbStoreLength$[rsp]
	lea	rdx, QWORD PTR pStore$[rsp]
	mov	rcx, QWORD PTR pBuf$[rsp]
	call	?CBStore@@YAJPEAU_CIRCULAR_BUFFER@@PEAPEADPEA_K22@Z ; CBStore

; 2361 : 
; 2362 : 	// Now store the IRP into the buffer.
; 2363 : 	//
; 2364 : 	pStore = (PCHAR) pIrp;

	mov	rdx, QWORD PTR pIrp$[rsp]
	mov	QWORD PTR pStore$[rsp], rdx

; 2365 : 	cbStoreLength = sizeof (IRP);

	mov	QWORD PTR cbStoreLength$[rsp], 208	; 000000d0H

; 2366 : 
; 2367 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 2368 : 		"FLT - InterceptIrpAndData - Storing IRP %#p into the "
; 2369 : 		"buffer\n", pIrp);

	mov	r9, QWORD PTR pIrp$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0DN@KNINDNNC@FLT?5?9?5InterceptIrpAndData?5?9?5Stor@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 2370 : 
; 2371 : 	CBStore(pBuf, &pStore, &cbStoreLength, &cbBlockOffset, NULL);

	mov	QWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR cbBlockOffset$[rsp]
	lea	r8, QWORD PTR cbStoreLength$[rsp]
	lea	rdx, QWORD PTR pStore$[rsp]
	mov	rcx, QWORD PTR pBuf$[rsp]
	call	?CBStore@@YAJPEAU_CIRCULAR_BUFFER@@PEAPEADPEA_K22@Z ; CBStore

; 2372 : 
; 2373 : 	// Store the current stack location into the buffer.
; 2374 : 	//
; 2375 : 	pStore = (PCHAR) IoGetCurrentIrpStackLocation(pIrp);

	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoGetCurrentIrpStackLocation
	mov	QWORD PTR pStore$[rsp], rax

; 2376 : 	cbStoreLength = sizeof (IO_STACK_LOCATION);

	mov	QWORD PTR cbStoreLength$[rsp], 72	; 00000048H

; 2377 : 
; 2378 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 2379 : 		"FLT - InterceptIrpAndData - Storing current stack "
; 2380 : 		"location %#p into the "
; 2381 : 		"buffer\n", pStore);

	mov	r9, QWORD PTR pStore$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0FA@GIHNANGK@FLT?5?9?5InterceptIrpAndData?5?9?5Stor@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 2382 : 
; 2383 : 	CBStore(pBuf, &pStore, &cbStoreLength, &cbBlockOffset, NULL);

	mov	QWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR cbBlockOffset$[rsp]
	lea	r8, QWORD PTR cbStoreLength$[rsp]
	lea	rdx, QWORD PTR pStore$[rsp]
	mov	rcx, QWORD PTR pBuf$[rsp]
	call	?CBStore@@YAJPEAU_CIRCULAR_BUFFER@@PEAPEADPEA_K22@Z ; CBStore

; 2384 : 
; 2385 : 	if (cbStoreLength = cbDataLen) {	// The = operator is 

	mov	rax, QWORD PTR cbDataLen$[rsp]
	mov	QWORD PTR cbStoreLength$[rsp], rax
	cmp	QWORD PTR cbStoreLength$[rsp], 0
	je	SHORT $LN1@InterceptI

; 2386 : 										// intentional!
; 2387 : 										// Check cbDataLen != 0 
; 2388 : 										// and copy it into 
; 2389 : 										// cbStoreLength.
; 2390 : 		pStore = (PCHAR) pData;

	mov	rax, QWORD PTR pData$[rsp]
	mov	QWORD PTR pStore$[rsp], rax

; 2391 : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 2392 : 			"FLT - InterceptIrpAndData - Storing %#x bytes of "
; 2393 : 			"data at %#p into the "
; 2394 : 			"buffer\n", cbDataLen, pStore);

	mov	rax, QWORD PTR pStore$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR cbDataLen$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0EO@KNKPAAK@FLT?5?9?5InterceptIrpAndData?5?9?5Stor@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 2395 : 		CBStore(pBuf, &pStore, &cbStoreLength, &cbBlockOffset, NULL);

	mov	QWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR cbBlockOffset$[rsp]
	lea	r8, QWORD PTR cbStoreLength$[rsp]
	lea	rdx, QWORD PTR pStore$[rsp]
	mov	rcx, QWORD PTR pBuf$[rsp]
	call	?CBStore@@YAJPEAU_CIRCULAR_BUFFER@@PEAPEADPEA_K22@Z ; CBStore
$LN1@InterceptI:
$LN4@InterceptI:

; 2396 : 	}
; 2397 : 	return;
; 2398 : }

	add	rsp, 112				; 00000070H
	pop	rdi
	ret	0
?InterceptIrpAndData@@YAXPEAU_IRP@@PEAX_KPEAU_DEVICE_EXTENSION@@@Z ENDP ; InterceptIrpAndData
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetWriteData@@YAXPEAU_IRP@@PEAU_DEVICE_EXTENSION@@PEAPEAXPEA_K@Z DD imagerel ?GetWriteData@@YAXPEAU_IRP@@PEAU_DEVICE_EXTENSION@@PEAPEAXPEA_K@Z
	DD	imagerel ?GetWriteData@@YAXPEAU_IRP@@PEAU_DEVICE_EXTENSION@@PEAPEAXPEA_K@Z+317
	DD	imagerel $unwind$?GetWriteData@@YAXPEAU_IRP@@PEAU_DEVICE_EXTENSION@@PEAPEAXPEA_K@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetWriteData@@YAXPEAU_IRP@@PEAU_DEVICE_EXTENSION@@PEAPEAXPEA_K@Z DD 011801H
	DD	0a218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?GetWriteData@@YAXPEAU_IRP@@PEAU_DEVICE_EXTENSION@@PEAPEAXPEA_K@Z
_TEXT	SEGMENT
pStack$ = 48
pMdl$28967 = 56
pBufStart$28968 = 64
tv88 = 72
pIrp$ = 96
pDevExt$ = 104
ppWriteData$ = 112
pcbDataLen$ = 120
?GetWriteData@@YAXPEAU_IRP@@PEAU_DEVICE_EXTENSION@@PEAPEAXPEA_K@Z PROC ; GetWriteData, COMDAT

; 2177 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 2178 : 	*ppWriteData = NULL;

	mov	rax, QWORD PTR ppWriteData$[rsp]
	mov	QWORD PTR [rax], 0

; 2179 : 	*pcbDataLen = 0;

	mov	rax, QWORD PTR pcbDataLen$[rsp]
	mov	QWORD PTR [rax], 0

; 2180 : 
; 2181 : 	PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoGetCurrentIrpStackLocation
	mov	QWORD PTR pStack$[rsp], rax

; 2182 : 	*pcbDataLen = pStack->Parameters.Write.Length;

	mov	rax, QWORD PTR pStack$[rsp]
	mov	ecx, DWORD PTR [rax+8]
	mov	rax, QWORD PTR pcbDataLen$[rsp]
	mov	QWORD PTR [rax], rcx

; 2183 : 	if (!*pcbDataLen) return;

	mov	rax, QWORD PTR pcbDataLen$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN5@GetWriteDa
	jmp	$LN6@GetWriteDa
$LN5@GetWriteDa:

; 2184 : 
; 2185 : 	// Determine the buffering mode
; 2186 : 	//
; 2187 : 	if (pDevExt->hdr.pDevice->Flags & DO_DIRECT_IO) {

	mov	rax, QWORD PTR pDevExt$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	eax, DWORD PTR [rax+48]
	and	eax, 16
	test	eax, eax
	je	$LN4@GetWriteDa

; 2188 : 
; 2189 : 		PMDL pMdl = pIrp->MdlAddress;

	mov	rax, QWORD PTR pIrp$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR pMdl$28967[rsp], rax

; 2190 : 		PCHAR pBufStart = (PCHAR) MmGetSystemAddressForMdlSafe(pMdl, 
; 2191 : 				LowPagePriority);

	mov	rax, QWORD PTR pMdl$28967[rsp]
	movsx	eax, WORD PTR [rax+10]
	and	eax, 5
	test	eax, eax
	je	SHORT $LN8@GetWriteDa
	mov	rax, QWORD PTR pMdl$28967[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR tv88[rsp], rax
	jmp	SHORT $LN9@GetWriteDa
$LN8@GetWriteDa:
	mov	DWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	xor	r9d, r9d
	mov	r8d, 1
	xor	edx, edx
	mov	rcx, QWORD PTR pMdl$28967[rsp]
	call	QWORD PTR __imp_MmMapLockedPagesSpecifyCache
	mov	QWORD PTR tv88[rsp], rax
$LN9@GetWriteDa:
	mov	rax, QWORD PTR tv88[rsp]
	mov	QWORD PTR pBufStart$28968[rsp], rax

; 2192 : 		if (pBufStart != NULL) {

	cmp	QWORD PTR pBufStart$28968[rsp], 0
	je	SHORT $LN3@GetWriteDa

; 2193 : 			*ppWriteData = pBufStart;

	mov	rcx, QWORD PTR ppWriteData$[rsp]
	mov	rax, QWORD PTR pBufStart$28968[rsp]
	mov	QWORD PTR [rcx], rax

; 2194 : 		} else {

	jmp	SHORT $LN2@GetWriteDa
$LN3@GetWriteDa:

; 2195 : 
; 2196 : 			// This should never happen, because the client buffer
; 2197 : 			// has already been locked in place by who issued the
; 2198 : 			// read IRP.
; 2199 : 			//
; 2200 : 			*pcbDataLen = 0;

	mov	rax, QWORD PTR pcbDataLen$[rsp]
	mov	QWORD PTR [rax], 0
$LN2@GetWriteDa:

; 2201 : 		}
; 2202 : 	} else {

	jmp	SHORT $LN1@GetWriteDa
$LN4@GetWriteDa:

; 2203 : 
; 2204 : 		// Buffered I/O
; 2205 : 		//
; 2206 : 		*ppWriteData = pIrp->AssociatedIrp.SystemBuffer;

	mov	rcx, QWORD PTR ppWriteData$[rsp]
	mov	rax, QWORD PTR pIrp$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR [rcx], rax
$LN1@GetWriteDa:

; 2207 : 	}
; 2208 : 
; 2209 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 2210 : 		"FLT - GetWriteData - Write data address: %#p, length: %#x\n",
; 2211 : 		*ppWriteData, *pcbDataLen);

	mov	rax, QWORD PTR pcbDataLen$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR ppWriteData$[rsp]
	mov	r9, QWORD PTR [r9]
	lea	r8, OFFSET FLAT:??_C@_0DL@GMEEJJEE@FLT?5?9?5GetWriteData?5?9?5Write?5data?5@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx
$LN6@GetWriteDa:

; 2212 : 
; 2213 : 	return;
; 2214 : }

	add	rsp, 88					; 00000058H
	ret	0
?GetWriteData@@YAXPEAU_IRP@@PEAU_DEVICE_EXTENSION@@PEAPEAXPEA_K@Z ENDP ; GetWriteData
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ForwardToNext@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD imagerel ?ForwardToNext@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
	DD	imagerel ?ForwardToNext@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z+66
	DD	imagerel $unwind$?ForwardToNext@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ForwardToNext@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?ForwardToNext@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
_TEXT	SEGMENT
pDevExt$ = 32
pDevObj$ = 64
pIrp$ = 72
?ForwardToNext@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z PROC ; ForwardToNext, COMDAT

; 1689 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1690 : 	PDEVICE_EXTENSION	pDevExt;
; 1691 : 
; 1692 : 	pDevExt = (PDEVICE_EXTENSION) pDevObj->DeviceExtension;

	mov	rax, QWORD PTR pDevObj$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR pDevExt$[rsp], rax

; 1693 : 
; 1694 : 	IoSkipCurrentIrpStackLocation(pIrp);

	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoSkipCurrentIrpStackLocation

; 1695 : 	return IoCallDriver(
; 1696 : 		pDevExt->pTargStack,
; 1697 : 		pIrp );

	mov	rdx, QWORD PTR pIrp$[rsp]
	mov	rcx, QWORD PTR pDevExt$[rsp]
	mov	rcx, QWORD PTR [rcx+288]
	call	QWORD PTR __imp_IofCallDriver

; 1698 : }

	add	rsp, 56					; 00000038H
	ret	0
?ForwardToNext@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ENDP ; ForwardToNext
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ForwardPIrpToNext@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD imagerel ?ForwardPIrpToNext@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
	DD	imagerel ?ForwardPIrpToNext@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z+77
	DD	imagerel $unwind$?ForwardPIrpToNext@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ForwardPIrpToNext@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?ForwardPIrpToNext@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
_TEXT	SEGMENT
pDevExt$ = 32
pDevObj$ = 64
pIrp$ = 72
?ForwardPIrpToNext@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z PROC ; ForwardPIrpToNext, COMDAT

; 1660 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1661 : 	PDEVICE_EXTENSION	pDevExt;
; 1662 : 
; 1663 : 	pDevExt = (PDEVICE_EXTENSION) pDevObj->DeviceExtension;

	mov	rax, QWORD PTR pDevObj$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR pDevExt$[rsp], rax

; 1664 : 	PoStartNextPowerIrp(pIrp);

	mov	rcx, QWORD PTR pIrp$[rsp]
	call	QWORD PTR __imp_PoStartNextPowerIrp

; 1665 : 	IoSkipCurrentIrpStackLocation(pIrp);

	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoSkipCurrentIrpStackLocation

; 1666 : 	return PoCallDriver(
; 1667 : 		pDevExt->pTargStack,
; 1668 : 		pIrp );

	mov	rdx, QWORD PTR pIrp$[rsp]
	mov	rcx, QWORD PTR pDevExt$[rsp]
	mov	rcx, QWORD PTR [rcx+288]
	call	QWORD PTR __imp_PoCallDriver

; 1669 : }

	add	rsp, 56					; 00000038H
	ret	0
?ForwardPIrpToNext@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ENDP ; ForwardPIrpToNext
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ForwardIrpOrPIrp@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD imagerel ?ForwardIrpOrPIrp@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
	DD	imagerel ?ForwardIrpOrPIrp@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z+108
	DD	imagerel $unwind$?ForwardIrpOrPIrp@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ForwardIrpOrPIrp@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?ForwardIrpOrPIrp@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
_TEXT	SEGMENT
pStack$ = 32
status$ = 40
MajFun$ = 44
pDevObj$ = 64
pIrp$ = 72
?ForwardIrpOrPIrp@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z PROC ; ForwardIrpOrPIrp, COMDAT

; 1626 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 1627 : 	PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoGetCurrentIrpStackLocation
	mov	QWORD PTR pStack$[rsp], rax

; 1628 : 	UCHAR MajFun = pStack->MajorFunction;

	mov	rax, QWORD PTR pStack$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR MajFun$[rsp], al

; 1629 : 	NTSTATUS status = STATUS_UNSUCCESSFUL;

	mov	DWORD PTR status$[rsp], -1073741823	; ffffffffc0000001H

; 1630 : 	if (MajFun == IRP_MJ_POWER) {

	movzx	eax, BYTE PTR MajFun$[rsp]
	cmp	eax, 22
	jne	SHORT $LN2@ForwardIrp

; 1631 : 
; 1632 : 		// Power IRP must be forwarded differently.
; 1633 : 		//
; 1634 : 		status = ForwardPIrpToNext(pDevObj, pIrp);

	mov	rdx, QWORD PTR pIrp$[rsp]
	mov	rcx, QWORD PTR pDevObj$[rsp]
	call	?ForwardPIrpToNext@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ; ForwardPIrpToNext
	mov	DWORD PTR status$[rsp], eax

; 1635 : 	} else {

	jmp	SHORT $LN1@ForwardIrp
$LN2@ForwardIrp:

; 1636 : 		status = ForwardToNext(pDevObj, pIrp);

	mov	rdx, QWORD PTR pIrp$[rsp]
	mov	rcx, QWORD PTR pDevObj$[rsp]
	call	?ForwardToNext@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ; ForwardToNext
	mov	DWORD PTR status$[rsp], eax
$LN1@ForwardIrp:

; 1637 : 	}
; 1638 : 	return status;

	mov	eax, DWORD PTR status$[rsp]

; 1639 : }

	add	rsp, 56					; 00000038H
	ret	0
?ForwardIrpOrPIrp@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ENDP ; ForwardIrpOrPIrp
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FADispatchIoctl@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD imagerel ?FADispatchIoctl@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
	DD	imagerel ?FADispatchIoctl@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z+216
	DD	imagerel $unwind$?FADispatchIoctl@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FADispatchIoctl@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?FADispatchIoctl@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
_TEXT	SEGMENT
pFltDevExt$ = 32
pFaDevExt$ = 40
ctlCode$ = 48
pIrpStack$ = 56
status$ = 64
tv77 = 68
pDevObj$ = 96
pIrp$ = 104
?FADispatchIoctl@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z PROC ; FADispatchIoctl, COMDAT

; 1503 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1504 : 	PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoGetCurrentIrpStackLocation
	mov	QWORD PTR pIrpStack$[rsp], rax

; 1505 : 	ULONG ctlCode = pIrpStack->Parameters.DeviceIoControl.IoControlCode;

	mov	rax, QWORD PTR pIrpStack$[rsp]
	mov	eax, DWORD PTR [rax+24]
	mov	DWORD PTR ctlCode$[rsp], eax

; 1506 : 
; 1507 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1508 : 		"FLT - FADispatchDioc - IOCTL code = %#010x\n", ctlCode);

	mov	r9d, DWORD PTR ctlCode$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0CM@CDEFGHPM@FLT?5?9?5FADispatchDioc?5?9?5IOCTL?5cod@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 1509 : 
; 1510 : 	pIrp->IoStatus.Information = 0;	// bytes xfered

	mov	r11, QWORD PTR pIrp$[rsp]
	mov	QWORD PTR [r11+56], 0

; 1511 : 
; 1512 : 	// pFaDevExt points to the dev ext for the FA device. pFltDevExt
; 1513 : 	// points to the one for the filter device.
; 1514 : 	//
; 1515 : 	PFADEVICE_EXTENSION pFaDevExt = 
; 1516 : 		(PFADEVICE_EXTENSION) pDevObj->DeviceExtension;

	mov	rax, QWORD PTR pDevObj$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR pFaDevExt$[rsp], rax

; 1517 : 	PDEVICE_EXTENSION pFltDevExt = 
; 1518 : 		(PDEVICE_EXTENSION) pFaDevExt->pFilterDevExt;

	mov	rax, QWORD PTR pFaDevExt$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR pFltDevExt$[rsp], rax

; 1519 : 	NTSTATUS status = STATUS_UNSUCCESSFUL;

	mov	DWORD PTR status$[rsp], -1073741823	; ffffffffc0000001H

; 1520 : 	//PMJF_CONTROL pOutFlags = NULL;
; 1521 : 	//PMJF_CONTROL pNewFlags = NULL;
; 1522 : 	switch (ctlCode) {

	mov	eax, DWORD PTR ctlCode$[rsp]
	mov	DWORD PTR tv77[rsp], eax
	cmp	DWORD PTR tv77[rsp], 2252800		; 00226000H
	je	SHORT $LN3@FADispatch
	cmp	DWORD PTR tv77[rsp], 2269188		; 0022a004H
	je	SHORT $LN2@FADispatch
	jmp	SHORT $LN1@FADispatch
$LN3@FADispatch:

; 1523 : 	    case IOCTL_FILTER_GET_MJF_FLAGS:
; 1524 : 			status = IoctlGetMJFFlags(pIrp, pFltDevExt);

	mov	rdx, QWORD PTR pFltDevExt$[rsp]
	mov	rcx, QWORD PTR pIrp$[rsp]
	call	?IoctlGetMJFFlags@@YAJPEAU_IRP@@PEAU_DEVICE_EXTENSION@@@Z ; IoctlGetMJFFlags
	mov	DWORD PTR status$[rsp], eax

; 1525 : 			break;

	jmp	SHORT $LN4@FADispatch
$LN2@FADispatch:

; 1526 : 	    case IOCTL_FILTER_SET_MJF_FLAGS:
; 1527 : 			status = IoctlSetMJFFlags(pIrp, pFltDevExt);

	mov	rdx, QWORD PTR pFltDevExt$[rsp]
	mov	rcx, QWORD PTR pIrp$[rsp]
	call	?IoctlSetMJFFlags@@YAJPEAU_IRP@@PEAU_DEVICE_EXTENSION@@@Z ; IoctlSetMJFFlags
	mov	DWORD PTR status$[rsp], eax

; 1528 : 			break;

	jmp	SHORT $LN4@FADispatch
$LN1@FADispatch:

; 1529 : 		default:
; 1530 : 			status = STATUS_INVALID_DEVICE_REQUEST;

	mov	DWORD PTR status$[rsp], -1073741808	; ffffffffc0000010H

; 1531 : 			pIrp->IoStatus.Status = status;

	mov	rcx, QWORD PTR pIrp$[rsp]
	mov	eax, DWORD PTR status$[rsp]
	mov	DWORD PTR [rcx+48], eax
$LN4@FADispatch:

; 1532 : 	}
; 1533 : 	return status;

	mov	eax, DWORD PTR status$[rsp]

; 1534 : }

	add	rsp, 88					; 00000058H
	ret	0
?FADispatchIoctl@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ENDP ; FADispatchIoctl
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FACancel@@YAXPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD imagerel ?FACancel@@YAXPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
	DD	imagerel ?FACancel@@YAXPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z+303
	DD	imagerel $unwind$?FACancel@@YAXPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FACancel@@YAXPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD 010e01H
	DD	0c20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?FACancel@@YAXPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
_TEXT	SEGMENT
pFltDevExt$ = 32
pCurIrp$ = 40
pCurrItem$ = 48
pFaDevExt$ = 56
LockHandle$ = 64
pDevObj$ = 112
pIrp$ = 120
?FACancel@@YAXPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z PROC	; FACancel, COMDAT

; 1442 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 1443 : 	IoReleaseCancelSpinLock(pIrp->CancelIrql);

	mov	rax, QWORD PTR pIrp$[rsp]
	movzx	ecx, BYTE PTR [rax+69]
	call	QWORD PTR __imp_IoReleaseCancelSpinLock

; 1444 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1445 : 		"FLT - FACancel - Entering, IRP %#p\n", pIrp);

	mov	r9, QWORD PTR pIrp$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0CE@KKGIALML@FLT?5?9?5FACancel?5?9?5Entering?0?5IRP?5?$CF@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 1446 : 	PFADEVICE_EXTENSION pFaDevExt = 
; 1447 : 		(PFADEVICE_EXTENSION) pDevObj->DeviceExtension;

	mov	rax, QWORD PTR pDevObj$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR pFaDevExt$[rsp], rax

; 1448 : 
; 1449 : 	// Get the filter device extension.
; 1450 : 	//
; 1451 : 	PDEVICE_EXTENSION pFltDevExt = pFaDevExt->pFilterDevExt;

	mov	rax, QWORD PTR pFaDevExt$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR pFltDevExt$[rsp], rax

; 1452 : 
; 1453 : 	// Look for an IRP to cancel into the internal queue.
; 1454 : 	//
; 1455 : 	KLOCK_QUEUE_HANDLE LockHandle;
; 1456 : 	KeAcquireInStackQueuedSpinLock(&pFltDevExt->DataLock, &LockHandle);

	mov	rcx, QWORD PTR pFltDevExt$[rsp]
	add	rcx, 136				; 00000088H
	lea	rdx, QWORD PTR LockHandle$[rsp]
	call	QWORD PTR __imp_KeAcquireInStackQueuedSpinLock

; 1457 : 	PLIST_ENTRY pCurrItem;
; 1458 : 	PIRP pCurIrp = NULL;

	mov	QWORD PTR pCurIrp$[rsp], 0

; 1459 : 	for (
; 1460 : 		pCurrItem = pFltDevExt->pIrpList.Flink; 

	mov	rax, QWORD PTR pFltDevExt$[rsp]
	mov	rax, QWORD PTR [rax+272]
	mov	QWORD PTR pCurrItem$[rsp], rax

; 1461 : 		pCurrItem != &pFltDevExt->pIrpList;

	jmp	SHORT $LN5@FACancel
$LN4@FACancel:

; 1462 : 		pCurrItem = pCurrItem->Flink) {

	mov	rax, QWORD PTR pCurrItem$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR pCurrItem$[rsp], rax
$LN5@FACancel:
	mov	rax, QWORD PTR pFltDevExt$[rsp]
	add	rax, 272				; 00000110H
	cmp	QWORD PTR pCurrItem$[rsp], rax
	je	SHORT $LN3@FACancel

; 1463 : 
; 1464 : 		pCurIrp = CONTAINING_RECORD(pCurrItem, IRP,
; 1465 : 			Tail.Overlay.ListEntry);

	mov	rax, QWORD PTR pCurrItem$[rsp]
	sub	rax, 168				; 000000a8H
	mov	QWORD PTR pCurIrp$[rsp], rax

; 1466 : 		if (pCurIrp->Cancel) {

	mov	rax, QWORD PTR pCurIrp$[rsp]
	movzx	eax, BYTE PTR [rax+68]
	test	eax, eax
	je	SHORT $LN2@FACancel

; 1467 : 			RemoveEntryList(pCurrItem);

	mov	rcx, QWORD PTR pCurrItem$[rsp]
	call	RemoveEntryList

; 1468 : 			break;

	jmp	SHORT $LN3@FACancel
$LN2@FACancel:

; 1469 : 		}
; 1470 : 		pCurIrp = NULL;

	mov	QWORD PTR pCurIrp$[rsp], 0

; 1471 : 	}

	jmp	SHORT $LN4@FACancel
$LN3@FACancel:

; 1472 : 	KeReleaseInStackQueuedSpinLock(&LockHandle);

	lea	rcx, QWORD PTR LockHandle$[rsp]
	call	QWORD PTR __imp_KeReleaseInStackQueuedSpinLock

; 1473 : 	if (pCurIrp != NULL) {

	cmp	QWORD PTR pCurIrp$[rsp], 0
	je	SHORT $LN1@FACancel

; 1474 : 		pCurIrp->IoStatus.Status = STATUS_CANCELLED;

	mov	rax, QWORD PTR pCurIrp$[rsp]
	mov	DWORD PTR [rax+48], -1073741536		; ffffffffc0000120H

; 1475 : 		pCurIrp->IoStatus.Information = 0;

	mov	rax, QWORD PTR pCurIrp$[rsp]
	mov	QWORD PTR [rax+56], 0

; 1476 : 		IoCompleteRequest(pCurIrp, IO_NO_INCREMENT);

	xor	edx, edx
	mov	rcx, QWORD PTR pCurIrp$[rsp]
	call	QWORD PTR __imp_IofCompleteRequest

; 1477 : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1478 : 			"FLT - FACancel - Client IRP %#p cancelled\n", 
; 1479 : 			pCurIrp);

	mov	r9, QWORD PTR pCurIrp$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0CL@DMKAKDEG@FLT?5?9?5FACancel?5?9?5Client?5IRP?5?$CF?$CDp?5@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx
$LN1@FACancel:

; 1480 : 	}
; 1481 : 	return;
; 1482 : }

	add	rsp, 104				; 00000068H
	ret	0
?FACancel@@YAXPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ENDP	; FACancel
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DpcCltIrpCompletion@@YAXPEAU_KDPC@@PEAX11@Z DD imagerel ?DpcCltIrpCompletion@@YAXPEAU_KDPC@@PEAX11@Z
	DD	imagerel ?DpcCltIrpCompletion@@YAXPEAU_KDPC@@PEAX11@Z+207
	DD	imagerel $unwind$?DpcCltIrpCompletion@@YAXPEAU_KDPC@@PEAX11@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DpcCltIrpCompletion@@YAXPEAU_KDPC@@PEAX11@Z DD 011801H
	DD	0c218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?DpcCltIrpCompletion@@YAXPEAU_KDPC@@PEAX11@Z
_TEXT	SEGMENT
LockHandle$ = 32
pWCompl$ = 56
pDevExt$ = 64
pIrp$28730 = 72
pItem$28729 = 80
Dpc$ = 112
DeferredContext$ = 120
SystemArgument1$ = 128
SystemArgument2$ = 136
?DpcCltIrpCompletion@@YAXPEAU_KDPC@@PEAX11@Z PROC	; DpcCltIrpCompletion, COMDAT

; 1319 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 1320 : 	PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION) DeferredContext;

	mov	rax, QWORD PTR DeferredContext$[rsp]
	mov	QWORD PTR pDevExt$[rsp], rax

; 1321 : 	PLIST_ENTRY pWCompl = &pDevExt->pWaitingComplIrpList;

	mov	rax, QWORD PTR pDevExt$[rsp]
	add	rax, 296				; 00000128H
	mov	QWORD PTR pWCompl$[rsp], rax
$LN3@DpcCltIrpC:

; 1322 : 	KLOCK_QUEUE_HANDLE LockHandle;
; 1323 : 	for (;;) {
; 1324 : 		KeAcquireInStackQueuedSpinLock(&pDevExt->DataLock, &LockHandle);

	mov	rcx, QWORD PTR pDevExt$[rsp]
	add	rcx, 136				; 00000088H
	lea	rdx, QWORD PTR LockHandle$[rsp]
	call	QWORD PTR __imp_KeAcquireInStackQueuedSpinLock

; 1325 : 		if (IsListEmpty(pWCompl)) {

	mov	rcx, QWORD PTR pWCompl$[rsp]
	call	IsListEmpty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@DpcCltIrpC

; 1326 : 			KeReleaseInStackQueuedSpinLock(&LockHandle);

	lea	rcx, QWORD PTR LockHandle$[rsp]
	call	QWORD PTR __imp_KeReleaseInStackQueuedSpinLock

; 1327 : 			break;

	jmp	SHORT $LN2@DpcCltIrpC
$LN1@DpcCltIrpC:

; 1328 : 		}
; 1329 : 		PLIST_ENTRY pItem = RemoveHeadList(pWCompl);

	mov	rcx, QWORD PTR pWCompl$[rsp]
	call	RemoveHeadList
	mov	QWORD PTR pItem$28729[rsp], rax

; 1330 : 		KeReleaseInStackQueuedSpinLock(&LockHandle);

	lea	rcx, QWORD PTR LockHandle$[rsp]
	call	QWORD PTR __imp_KeReleaseInStackQueuedSpinLock

; 1331 : 		PIRP pIrp = 
; 1332 : 			CONTAINING_RECORD(pItem, IRP, Tail.Overlay.ListEntry);

	mov	rax, QWORD PTR pItem$28729[rsp]
	sub	rax, 168				; 000000a8H
	mov	QWORD PTR pIrp$28730[rsp], rax

; 1333 : 
; 1334 : 		IoSetCancelRoutine(pIrp, NULL);

	mov	rax, QWORD PTR pIrp$28730[rsp]
	add	rax, 104				; 00000068H
	xor	ecx, ecx
	xchg	QWORD PTR [rax], rcx

; 1335 : 		IoCompleteRequest(pIrp, IO_NO_INCREMENT);

	xor	edx, edx
	mov	rcx, QWORD PTR pIrp$28730[rsp]
	call	QWORD PTR __imp_IofCompleteRequest

; 1336 : 
; 1337 : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1338 : 			"FLT - DpcCltIrpCompletion - Client Irp %#p "
; 1339 : 			"completed\n", pIrp);

	mov	r9, QWORD PTR pIrp$28730[rsp]
	lea	r8, OFFSET FLAT:??_C@_0DG@FLIENFEL@FLT?5?9?5DpcCltIrpCompletion?5?9?5Clie@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx
	jmp	$LN3@DpcCltIrpC
$LN2@DpcCltIrpC:

; 1340 : 	}
; 1341 : }

	add	rsp, 104				; 00000068H
	ret	0
?DpcCltIrpCompletion@@YAXPEAU_KDPC@@PEAX11@Z ENDP	; DpcCltIrpCompletion
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DecodeEnum@@YAPEADHHQEAPEADHPEAD_K@Z DD imagerel ?DecodeEnum@@YAPEADHHQEAPEADHPEAD_K@Z
	DD	imagerel ?DecodeEnum@@YAPEADHHQEAPEADHPEAD_K@Z+121
	DD	imagerel $unwind$?DecodeEnum@@YAPEADHHQEAPEADHPEAD_K@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DecodeEnum@@YAPEADHHQEAPEADHPEAD_K@Z DD 011601H
	DD	06216H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?DecodeEnum@@YAPEADHHQEAPEADHPEAD_K@Z
_TEXT	SEGMENT
Index$ = 32
Value$ = 64
Base$ = 72
pszDecodeV$ = 80
VectLen$ = 88
pszOutBuf$ = 96
cbBufSize$ = 104
?DecodeEnum@@YAPEADHHQEAPEADHPEAD_K@Z PROC		; DecodeEnum, COMDAT

; 1125 : {

	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 1126 : 	INT Index = Value - Base;

	mov	ecx, DWORD PTR Base$[rsp]
	mov	eax, DWORD PTR Value$[rsp]
	sub	eax, ecx
	mov	DWORD PTR Index$[rsp], eax

; 1127 : 	if ((Index >= 0) && ((INT) Index < VectLen)) {

	cmp	DWORD PTR Index$[rsp], 0
	jl	SHORT $LN2@DecodeEnum
	mov	eax, DWORD PTR VectLen$[rsp]
	cmp	DWORD PTR Index$[rsp], eax
	jge	SHORT $LN2@DecodeEnum

; 1128 : 		RtlStringCbCopyA(pszOutBuf, cbBufSize, pszDecodeV[Index]);

	movsxd	rax, DWORD PTR Index$[rsp]
	mov	r8, QWORD PTR pszDecodeV$[rsp]
	mov	r8, QWORD PTR [r8+rax*8]
	mov	rdx, QWORD PTR cbBufSize$[rsp]
	mov	rcx, QWORD PTR pszOutBuf$[rsp]
	call	RtlStringCbCopyA

; 1129 : 	} else {

	jmp	SHORT $LN1@DecodeEnum
$LN2@DecodeEnum:

; 1130 : 		RtlStringCbPrintfA(pszOutBuf, cbBufSize, "%#x", Value);

	mov	r9d, DWORD PTR Value$[rsp]
	lea	r8, OFFSET FLAT:??_C@_03JELKHEKI@?$CF?$CDx?$AA@FNODOBFM@
	mov	rdx, QWORD PTR cbBufSize$[rsp]
	mov	rcx, QWORD PTR pszOutBuf$[rsp]
	call	RtlStringCbPrintfA
$LN1@DecodeEnum:

; 1131 : 	}
; 1132 : 
; 1133 : 	return pszOutBuf;

	mov	rax, QWORD PTR pszOutBuf$[rsp]

; 1134 : }

	add	rsp, 56					; 00000038H
	ret	0
?DecodeEnum@@YAPEADHHQEAPEADHPEAD_K@Z ENDP		; DecodeEnum
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CheckMAReadParams@@YAJPEAU_IRP@@PEAU_DEVICE_OBJECT@@PEAPEAU_IO_STACK_LOCATION@@PEAPEAU_ACCESS_DEVICES_LIST@@@Z DD imagerel ?CheckMAReadParams@@YAJPEAU_IRP@@PEAU_DEVICE_OBJECT@@PEAPEAU_IO_STACK_LOCATION@@PEAPEAU_ACCESS_DEVICES_LIST@@@Z
	DD	imagerel ?CheckMAReadParams@@YAJPEAU_IRP@@PEAU_DEVICE_OBJECT@@PEAPEAU_IO_STACK_LOCATION@@PEAPEAU_ACCESS_DEVICES_LIST@@@Z+222
	DD	imagerel $unwind$?CheckMAReadParams@@YAJPEAU_IRP@@PEAU_DEVICE_OBJECT@@PEAPEAU_IO_STACK_LOCATION@@PEAPEAU_ACCESS_DEVICES_LIST@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CheckMAReadParams@@YAJPEAU_IRP@@PEAU_DEVICE_OBJECT@@PEAPEAU_IO_STACK_LOCATION@@PEAPEAU_ACCESS_DEVICES_LIST@@@Z DD 011801H
	DD	0a218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?CheckMAReadParams@@YAJPEAU_IRP@@PEAU_DEVICE_OBJECT@@PEAPEAU_IO_STACK_LOCATION@@PEAPEAU_ACCESS_DEVICES_LIST@@@Z
_TEXT	SEGMENT
pAdl$ = 48
pStack$ = 56
status$ = 64
pIrp$ = 96
pDevObj$ = 104
ppStack$ = 112
ppAdl$ = 120
?CheckMAReadParams@@YAJPEAU_IRP@@PEAU_DEVICE_OBJECT@@PEAPEAU_IO_STACK_LOCATION@@PEAPEAU_ACCESS_DEVICES_LIST@@@Z PROC ; CheckMAReadParams, COMDAT

; 755  : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 756  : 	PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoGetCurrentIrpStackLocation
	mov	QWORD PTR pStack$[rsp], rax

; 757  : 	*ppStack = pStack;

	mov	rcx, QWORD PTR ppStack$[rsp]
	mov	rax, QWORD PTR pStack$[rsp]
	mov	QWORD PTR [rcx], rax

; 758  : 	if (pStack->Parameters.Read.Length < 
; 759  : 		FIELD_OFFSET(ACCESS_DEVICES_LIST, TargDevVect)) {

	mov	rax, QWORD PTR pStack$[rsp]
	cmp	DWORD PTR [rax+8], 16
	jae	SHORT $LN3@CheckMARea

; 760  : 			DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 761  : 				"FLT - CheckMAReadPArams - Client buffer too small; "
; 762  : 				"minimum required: %d, current: %d\n",
; 763  : 				FIELD_OFFSET(ACCESS_DEVICES_LIST, TargDevVect),
; 764  : 				pStack->Parameters.Read.Length);

	mov	rax, QWORD PTR pStack$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	DWORD PTR [rsp+32], eax
	mov	r9d, 16
	lea	r8, OFFSET FLAT:??_C@_0FG@NEABJAHD@FLT?5?9?5CheckMAReadPArams?5?9?5Client@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 765  : 		return STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; ffffffffc000000dH
	jmp	SHORT $LN4@CheckMARea
$LN3@CheckMARea:

; 766  : 	}
; 767  : 
; 768  : 	PACCESS_DEVICES_LIST pAdl;
; 769  : 	NTSTATUS status = GetRWIrpBuffer(pIrp, pDevObj, (PVOID *) &pAdl);

	lea	r8, QWORD PTR pAdl$[rsp]
	mov	rdx, QWORD PTR pDevObj$[rsp]
	mov	rcx, QWORD PTR pIrp$[rsp]
	call	?GetRWIrpBuffer@@YAJPEAU_IRP@@PEAU_DEVICE_OBJECT@@PEAPEAX@Z ; GetRWIrpBuffer
	mov	DWORD PTR status$[rsp], eax

; 770  : 	if (!NT_SUCCESS(status)) return status;

	cmp	DWORD PTR status$[rsp], 0
	jge	SHORT $LN2@CheckMARea
	mov	eax, DWORD PTR status$[rsp]
	jmp	SHORT $LN4@CheckMARea
$LN2@CheckMARea:

; 771  : 	*ppAdl = pAdl;

	mov	rcx, QWORD PTR ppAdl$[rsp]
	mov	rax, QWORD PTR pAdl$[rsp]
	mov	QWORD PTR [rcx], rax

; 772  : 
; 773  : 	// Check that the buffer is properly aligned for the structure we
; 774  : 	// will return
; 775  : 	//
; 776  : 	if ((ULONG_PTR) pAdl &
; 777  : 		(TYPE_ALIGNMENT(ACCESS_DEVICES_LIST) - 1)) {

	mov	rax, QWORD PTR pAdl$[rsp]
	and	rax, 7
	test	rax, rax
	je	SHORT $LN1@CheckMARea

; 778  : 			DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 779  : 				"FLT - CheckMAReadPArams - Client buffer not aligned; "
; 780  : 				"required alignment: %#x, buffer address: %#p\n",
; 781  : 				TYPE_ALIGNMENT(ACCESS_DEVICES_LIST),
; 782  : 				pAdl);

	mov	rax, QWORD PTR pAdl$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 8
	lea	r8, OFFSET FLAT:??_C@_0GD@DEPIDMO@FLT?5?9?5CheckMAReadPArams?5?9?5Client@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 783  : 		return STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; ffffffffc000000dH
	jmp	SHORT $LN4@CheckMARea
$LN1@CheckMARea:

; 784  : 	}
; 785  : 	return STATUS_SUCCESS;

	xor	eax, eax
$LN4@CheckMARea:

; 786  : }

	add	rsp, 88					; 00000058H
	ret	0
?CheckMAReadParams@@YAJPEAU_IRP@@PEAU_DEVICE_OBJECT@@PEAPEAU_IO_STACK_LOCATION@@PEAPEAU_ACCESS_DEVICES_LIST@@@Z ENDP ; CheckMAReadParams
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CheckFAReadParams@@YAJPEAU_IRP@@@Z DD imagerel ?CheckFAReadParams@@YAJPEAU_IRP@@@Z
	DD	imagerel ?CheckFAReadParams@@YAJPEAU_IRP@@@Z+98
	DD	imagerel $unwind$?CheckFAReadParams@@YAJPEAU_IRP@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CheckFAReadParams@@YAJPEAU_IRP@@@Z DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?CheckFAReadParams@@YAJPEAU_IRP@@@Z
_TEXT	SEGMENT
bufSize$ = 32
status$ = 40
pIoStack$ = 48
pIrp$ = 80
?CheckFAReadParams@@YAJPEAU_IRP@@@Z PROC		; CheckFAReadParams, COMDAT

; 709  : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 710  : 	NTSTATUS status = STATUS_SUCCESS;

	mov	DWORD PTR status$[rsp], 0

; 711  : 	PIO_STACK_LOCATION pIoStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoGetCurrentIrpStackLocation
	mov	QWORD PTR pIoStack$[rsp], rax

; 712  : 	SIZE_T bufSize = pIoStack->Parameters.Read.Length;

	mov	rax, QWORD PTR pIoStack$[rsp]
	mov	eax, DWORD PTR [rax+8]
	mov	QWORD PTR bufSize$[rsp], rax

; 713  : 
; 714  : 	// The buffer for a client read IRP must at least have room for
; 715  : 	// an intercepted IRP + I/O stack with their header.
; 716  : 	// It may also have room for any eventual IRP data, but this is
; 717  : 	// not manadatory.
; 718  : 	//
; 719  : 	if (bufSize < sizeof (IRP_HEADER) + sizeof(IRP) +
; 720  : 		sizeof(IO_STACK_LOCATION)) {

	cmp	QWORD PTR bufSize$[rsp], 296		; 00000128H
	jae	SHORT $LN1@CheckFARea

; 721  : 		status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR status$[rsp], -1073741811	; ffffffffc000000dH

; 722  : 		pIrp->IoStatus.Status = status;

	mov	rcx, QWORD PTR pIrp$[rsp]
	mov	eax, DWORD PTR status$[rsp]
	mov	DWORD PTR [rcx+48], eax

; 723  : 		pIrp->IoStatus.Information = 0;

	mov	rax, QWORD PTR pIrp$[rsp]
	mov	QWORD PTR [rax+56], 0
$LN1@CheckFARea:

; 724  : 	}
; 725  : 	return status;

	mov	eax, DWORD PTR status$[rsp]

; 726  : }

	add	rsp, 72					; 00000048H
	ret	0
?CheckFAReadParams@@YAJPEAU_IRP@@@Z ENDP		; CheckFAReadParams
_TEXT	ENDS
;	COMDAT pdata
; File c:\apps\pw7hp\devpgm\msddk\inc\ddk\ntstrsafe.h
pdata	SEGMENT
$pdata$RtlUnicodeStringValidateDestWorker DD imagerel RtlUnicodeStringValidateDestWorker
	DD	imagerel RtlUnicodeStringValidateDestWorker+200
	DD	imagerel $unwind$RtlUnicodeStringValidateDestWorker
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RtlUnicodeStringValidateDestWorker DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT RtlUnicodeStringValidateDestWorker
_TEXT	SEGMENT
status$ = 32
DestinationString$ = 64
ppszDest$ = 72
pcchDest$ = 80
pcchDestLength$ = 88
cchMax$ = 96
dwFlags$ = 104
RtlUnicodeStringValidateDestWorker PROC			; COMDAT

; 12237: {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 12238:     NTSTATUS status;
; 12239: 
; 12240:     *ppszDest = NULL;

	mov	rax, QWORD PTR ppszDest$[rsp]
	mov	QWORD PTR [rax], 0

; 12241:     *pcchDest = 0;

	mov	rax, QWORD PTR pcchDest$[rsp]
	mov	QWORD PTR [rax], 0

; 12242: 
; 12243:     if (pcchDestLength)

	cmp	QWORD PTR pcchDestLength$[rsp], 0
	je	SHORT $LN3@RtlUnicode@2

; 12244:     {
; 12245:         *pcchDestLength = 0;

	mov	rax, QWORD PTR pcchDestLength$[rsp]
	mov	QWORD PTR [rax], 0
$LN3@RtlUnicode@2:

; 12246:     }
; 12247: 
; 12248:     status = RtlUnicodeStringValidateWorker(DestinationString, cchMax, dwFlags);

	mov	r8d, DWORD PTR dwFlags$[rsp]
	mov	rdx, QWORD PTR cchMax$[rsp]
	mov	rcx, QWORD PTR DestinationString$[rsp]
	call	RtlUnicodeStringValidateWorker
	mov	DWORD PTR status$[rsp], eax

; 12249: 
; 12250:     if (NT_SUCCESS(status) && DestinationString)

	cmp	DWORD PTR status$[rsp], 0
	jl	SHORT $LN2@RtlUnicode@2
	cmp	QWORD PTR DestinationString$[rsp], 0
	je	SHORT $LN2@RtlUnicode@2

; 12251:     {
; 12252:         *ppszDest = DestinationString->Buffer;

	mov	rcx, QWORD PTR ppszDest$[rsp]
	mov	rax, QWORD PTR DestinationString$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx], rax

; 12253:         *pcchDest = DestinationString->MaximumLength / sizeof(wchar_t);

	mov	rax, QWORD PTR DestinationString$[rsp]
	movzx	eax, WORD PTR [rax+2]
	xor	edx, edx
	mov	ecx, 2
	div	rcx
	mov	rcx, rax
	mov	rax, QWORD PTR pcchDest$[rsp]
	mov	QWORD PTR [rax], rcx

; 12254: 
; 12255:         if (pcchDestLength)

	cmp	QWORD PTR pcchDestLength$[rsp], 0
	je	SHORT $LN1@RtlUnicode@2

; 12256:         {
; 12257:             *pcchDestLength = DestinationString->Length / sizeof(wchar_t);

	mov	rax, QWORD PTR DestinationString$[rsp]
	movzx	eax, WORD PTR [rax]
	xor	edx, edx
	mov	ecx, 2
	div	rcx
	mov	rcx, rax
	mov	rax, QWORD PTR pcchDestLength$[rsp]
	mov	QWORD PTR [rax], rcx
$LN1@RtlUnicode@2:
$LN2@RtlUnicode@2:

; 12258:         }
; 12259:     }
; 12260: 
; 12261:     return status;

	mov	eax, DWORD PTR status$[rsp]

; 12262: }

	add	rsp, 56					; 00000038H
	ret	0
RtlUnicodeStringValidateDestWorker ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$RtlUnicodeStringPrintf DD imagerel $LN4
	DD	imagerel $LN4+170
	DD	imagerel $unwind$RtlUnicodeStringPrintf
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RtlUnicodeStringPrintf DD 011801H
	DD	0c218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT RtlUnicodeStringPrintf
_TEXT	SEGMENT
pszDest$ = 48
status$ = 56
cchDest$ = 64
cchNewDestLength$27582 = 72
argList$27581 = 80
DestinationString$ = 112
pszFormat$ = 120
RtlUnicodeStringPrintf PROC				; COMDAT

; 11132: {

$LN4:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 104				; 00000068H

; 11133:     NTSTATUS status;
; 11134:     wchar_t* pszDest;
; 11135:     size_t cchDest;
; 11136:     
; 11137:     status = RtlUnicodeStringValidateDestWorker(DestinationString,
; 11138:                                                 &pszDest,
; 11139:                                                 &cchDest,
; 11140:                                                 NULL,
; 11141:                                                 NTSTRSAFE_UNICODE_STRING_MAX_CCH,
; 11142:                                                 0);

	mov	DWORD PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 32767		; 00007fffH
	xor	r9d, r9d
	lea	r8, QWORD PTR cchDest$[rsp]
	lea	rdx, QWORD PTR pszDest$[rsp]
	mov	rcx, QWORD PTR DestinationString$[rsp]
	call	RtlUnicodeStringValidateDestWorker
	mov	DWORD PTR status$[rsp], eax

; 11143: 
; 11144:     if (NT_SUCCESS(status))

	cmp	DWORD PTR status$[rsp], 0
	jl	SHORT $LN1@RtlUnicode@3

; 11145:     {
; 11146:         va_list argList;
; 11147:         size_t cchNewDestLength = 0;

	mov	QWORD PTR cchNewDestLength$27582[rsp], 0

; 11148: 
; 11149:         va_start(argList, pszFormat);

	lea	rax, QWORD PTR pszFormat$[rsp+8]
	mov	QWORD PTR argList$27581[rsp], rax

; 11150: 
; 11151:         status = RtlWideCharArrayVPrintfWorker(pszDest,
; 11152:                                                cchDest,
; 11153:                                                &cchNewDestLength,
; 11154:                                                pszFormat,
; 11155:                                                argList);

	mov	rax, QWORD PTR argList$27581[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR pszFormat$[rsp]
	lea	r8, QWORD PTR cchNewDestLength$27582[rsp]
	mov	rdx, QWORD PTR cchDest$[rsp]
	mov	rcx, QWORD PTR pszDest$[rsp]
	call	RtlWideCharArrayVPrintfWorker
	mov	DWORD PTR status$[rsp], eax

; 11156: 
; 11157:         va_end(argList);

	mov	QWORD PTR argList$27581[rsp], 0

; 11158: 
; 11159:         // safe to multiply cchNewDestLength * sizeof(wchar_t) since cchDest < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
; 11160:         DestinationString->Length = (USHORT)(cchNewDestLength * sizeof(wchar_t));

	mov	rcx, QWORD PTR cchNewDestLength$27582[rsp]
	shl	rcx, 1
	mov	rax, QWORD PTR DestinationString$[rsp]
	mov	WORD PTR [rax], cx
$LN1@RtlUnicode@3:

; 11161:     }
; 11162: 
; 11163:     return status;

	mov	eax, DWORD PTR status$[rsp]

; 11164: }

	add	rsp, 104				; 00000068H
	ret	0
RtlUnicodeStringPrintf ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\apps\pw7hp\devpgm\msddk\inc\ddk\wdm.h
pdata	SEGMENT
$pdata$IoCopyCurrentIrpStackLocationToNext DD imagerel $LN3
	DD	imagerel $LN3+74
	DD	imagerel $unwind$IoCopyCurrentIrpStackLocationToNext
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IoCopyCurrentIrpStackLocationToNext DD 030b01H
	DD	07007620bH
	DD	06006H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IoCopyCurrentIrpStackLocationToNext
_TEXT	SEGMENT
nextIrpSp$ = 32
irpSp$ = 40
Irp$ = 80
IoCopyCurrentIrpStackLocationToNext PROC		; COMDAT

; 23912: {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 56					; 00000038H

; 23913:     PIO_STACK_LOCATION irpSp;
; 23914:     PIO_STACK_LOCATION nextIrpSp;
; 23915:     irpSp = IoGetCurrentIrpStackLocation(Irp);

	mov	rcx, QWORD PTR Irp$[rsp]
	call	IoGetCurrentIrpStackLocation
	mov	QWORD PTR irpSp$[rsp], rax

; 23916:     nextIrpSp = IoGetNextIrpStackLocation(Irp);

	mov	rcx, QWORD PTR Irp$[rsp]
	call	IoGetNextIrpStackLocation
	mov	QWORD PTR nextIrpSp$[rsp], rax

; 23917:     RtlCopyMemory( nextIrpSp, irpSp, FIELD_OFFSET(IO_STACK_LOCATION, CompletionRoutine));

	mov	rdi, QWORD PTR nextIrpSp$[rsp]
	mov	rsi, QWORD PTR irpSp$[rsp]
	mov	ecx, 56					; 00000038H
	rep movsb

; 23918:     nextIrpSp->Control = 0;

	mov	rax, QWORD PTR nextIrpSp$[rsp]
	mov	BYTE PTR [rax+3], 0

; 23919: }

	add	rsp, 56					; 00000038H
	pop	rdi
	pop	rsi
	ret	0
IoCopyCurrentIrpStackLocationToNext ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$IoSetCompletionRoutine DD imagerel $LN12
	DD	imagerel $LN12+285
	DD	imagerel $unwind$IoSetCompletionRoutine
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IoSetCompletionRoutine DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IoSetCompletionRoutine
_TEXT	SEGMENT
irpSp$ = 32
tv72 = 40
tv71 = 44
tv78 = 48
Irp$ = 80
CompletionRoutine$ = 88
Context$ = 96
InvokeOnSuccess$ = 104
InvokeOnError$ = 112
InvokeOnCancel$ = 120
IoSetCompletionRoutine PROC				; COMDAT

; 23820: {

$LN12:
	mov	BYTE PTR [rsp+32], r9b
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 23821:     PIO_STACK_LOCATION irpSp;
; 23822:     ASSERT( (InvokeOnSuccess || InvokeOnError || InvokeOnCancel) ? (CompletionRoutine != NULL) : TRUE );

	movzx	eax, BYTE PTR InvokeOnSuccess$[rsp]
	test	eax, eax
	jne	SHORT $LN6@IoSetCompl
	movzx	eax, BYTE PTR InvokeOnError$[rsp]
	test	eax, eax
	jne	SHORT $LN6@IoSetCompl
	movzx	eax, BYTE PTR InvokeOnCancel$[rsp]
	test	eax, eax
	jne	SHORT $LN6@IoSetCompl
	mov	DWORD PTR tv72[rsp], 1
	jmp	SHORT $LN9@IoSetCompl
$LN6@IoSetCompl:
	cmp	QWORD PTR CompletionRoutine$[rsp], 0
	je	SHORT $LN7@IoSetCompl
	mov	DWORD PTR tv71[rsp], 1
	jmp	SHORT $LN8@IoSetCompl
$LN7@IoSetCompl:
	mov	DWORD PTR tv71[rsp], 0
$LN8@IoSetCompl:
	mov	eax, DWORD PTR tv71[rsp]
	mov	DWORD PTR tv72[rsp], eax
$LN9@IoSetCompl:
	cmp	DWORD PTR tv72[rsp], 0
	jne	SHORT $LN10@IoSetCompl
	xor	r9d, r9d
	mov	r8d, 23822				; 00005d0eH
	lea	rdx, OFFSET FLAT:??_C@_0CJ@NOBCDHO@c?3?2apps?2pw7hp?2devpgm?2msddk?2inc?2d@FNODOBFM@
	lea	rcx, OFFSET FLAT:??_C@_0FK@JAEDPCKJ@?$CIInvokeOnSuccess?5?$HM?$HM?5InvokeOnErro@FNODOBFM@
	call	QWORD PTR __imp_RtlAssert
	mov	DWORD PTR tv78[rsp], 0
	jmp	SHORT $LN11@IoSetCompl
$LN10@IoSetCompl:
	mov	DWORD PTR tv78[rsp], 1
$LN11@IoSetCompl:

; 23823:     irpSp = IoGetNextIrpStackLocation(Irp);

	mov	rcx, QWORD PTR Irp$[rsp]
	call	IoGetNextIrpStackLocation
	mov	QWORD PTR irpSp$[rsp], rax

; 23824:     irpSp->CompletionRoutine = CompletionRoutine;

	mov	rcx, QWORD PTR irpSp$[rsp]
	mov	rax, QWORD PTR CompletionRoutine$[rsp]
	mov	QWORD PTR [rcx+56], rax

; 23825:     irpSp->Context = Context;

	mov	rcx, QWORD PTR irpSp$[rsp]
	mov	rax, QWORD PTR Context$[rsp]
	mov	QWORD PTR [rcx+64], rax

; 23826:     irpSp->Control = 0;

	mov	rax, QWORD PTR irpSp$[rsp]
	mov	BYTE PTR [rax+3], 0

; 23827: 
; 23828:     if (InvokeOnSuccess) {

	movzx	eax, BYTE PTR InvokeOnSuccess$[rsp]
	test	eax, eax
	je	SHORT $LN3@IoSetCompl

; 23829:         irpSp->Control = SL_INVOKE_ON_SUCCESS;

	mov	rax, QWORD PTR irpSp$[rsp]
	mov	BYTE PTR [rax+3], 64			; 00000040H
$LN3@IoSetCompl:

; 23830:     }
; 23831: 
; 23832:     if (InvokeOnError) {

	movzx	eax, BYTE PTR InvokeOnError$[rsp]
	test	eax, eax
	je	SHORT $LN2@IoSetCompl

; 23833:         irpSp->Control |= SL_INVOKE_ON_ERROR;

	mov	rax, QWORD PTR irpSp$[rsp]
	movzx	ecx, BYTE PTR [rax+3]
	or	ecx, 128				; 00000080H
	mov	rax, QWORD PTR irpSp$[rsp]
	mov	BYTE PTR [rax+3], cl
$LN2@IoSetCompl:

; 23834:     }
; 23835: 
; 23836:     if (InvokeOnCancel) {

	movzx	eax, BYTE PTR InvokeOnCancel$[rsp]
	test	eax, eax
	je	SHORT $LN1@IoSetCompl

; 23837:         irpSp->Control |= SL_INVOKE_ON_CANCEL;

	mov	rax, QWORD PTR irpSp$[rsp]
	movzx	ecx, BYTE PTR [rax+3]
	or	ecx, 32					; 00000020H
	mov	rax, QWORD PTR irpSp$[rsp]
	mov	BYTE PTR [rax+3], cl
$LN1@IoSetCompl:

; 23838:     }
; 23839: }

	add	rsp, 72					; 00000048H
	ret	0
IoSetCompletionRoutine ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$IoMarkIrpPending DD imagerel $LN3
	DD	imagerel $LN3+51
	DD	imagerel $unwind$IoMarkIrpPending
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$IoMarkIrpPending DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT IoMarkIrpPending
_TEXT	SEGMENT
tv67 = 32
Irp$ = 64
IoMarkIrpPending PROC					; COMDAT

; 23667: {

$LN3:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 23668:     IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED;

	mov	rcx, QWORD PTR Irp$[rsp]
	call	IoGetCurrentIrpStackLocation
	add	rax, 3
	mov	QWORD PTR tv67[rsp], rax
	mov	rax, QWORD PTR tv67[rsp]
	movzx	ecx, BYTE PTR [rax]
	or	ecx, 1
	mov	rax, QWORD PTR tv67[rsp]
	mov	BYTE PTR [rax], cl

; 23669: }

	add	rsp, 56					; 00000038H
	ret	0
IoMarkIrpPending ENDP
_TEXT	ENDS
;	COMDAT pdata
; File b:\programm\wntsys\testfilter\release\1_1\source\driver\drvmain.cpp
pdata	SEGMENT
$pdata$?SendIrpSync@@YAJPEAU_IRP@@PEAU_KEVENT@@@Z DD imagerel ?SendIrpSync@@YAJPEAU_IRP@@PEAU_KEVENT@@@Z
	DD	imagerel ?SendIrpSync@@YAJPEAU_IRP@@PEAU_KEVENT@@@Z+159
	DD	imagerel $unwind$?SendIrpSync@@YAJPEAU_IRP@@PEAU_KEVENT@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SendIrpSync@@YAJPEAU_IRP@@PEAU_KEVENT@@@Z DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?SendIrpSync@@YAJPEAU_IRP@@PEAU_KEVENT@@@Z
_TEXT	SEGMENT
pNextStack$ = 48
status$ = 56
pIrp$ = 80
pEvent$ = 88
?SendIrpSync@@YAJPEAU_IRP@@PEAU_KEVENT@@@Z PROC		; SendIrpSync, COMDAT

; 3178 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3179 : 	KeClearEvent (pEvent);

	mov	rcx, QWORD PTR pEvent$[rsp]
	call	QWORD PTR __imp_KeClearEvent

; 3180 : 	IoSetCompletionRoutine(pIrp, SendIrpSyncCompletion, pEvent, TRUE, 
; 3181 : 		TRUE, TRUE);

	mov	BYTE PTR [rsp+40], 1
	mov	BYTE PTR [rsp+32], 1
	mov	r9b, 1
	mov	r8, QWORD PTR pEvent$[rsp]
	lea	rdx, OFFSET FLAT:?SendIrpSyncCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z ; SendIrpSyncCompletion
	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoSetCompletionRoutine

; 3182 : 	PIO_STACK_LOCATION pNextStack = IoGetNextIrpStackLocation(pIrp);

	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoGetNextIrpStackLocation
	mov	QWORD PTR pNextStack$[rsp], rax

; 3183 : 	NTSTATUS status = IoCallDriver(
; 3184 : 		pNextStack->DeviceObject,
; 3185 : 		pIrp);

	mov	rdx, QWORD PTR pIrp$[rsp]
	mov	rcx, QWORD PTR pNextStack$[rsp]
	mov	rcx, QWORD PTR [rcx+40]
	call	QWORD PTR __imp_IofCallDriver
	mov	DWORD PTR status$[rsp], eax

; 3186 : 	if (status == STATUS_PENDING) {

	cmp	DWORD PTR status$[rsp], 259		; 00000103H
	jne	SHORT $LN1@SendIrpSyn

; 3187 : 		KeWaitForSingleObject(pEvent, Executive, KernelMode, FALSE, NULL);

	mov	QWORD PTR [rsp+32], 0
	xor	r9d, r9d
	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR pEvent$[rsp]
	call	QWORD PTR __imp_KeWaitForSingleObject

; 3188 : 		status = pIrp->IoStatus.Status;

	mov	r11, QWORD PTR pIrp$[rsp]
	mov	eax, DWORD PTR [r11+48]
	mov	DWORD PTR status$[rsp], eax
$LN1@SendIrpSyn:

; 3189 : 	}
; 3190 : 	return status;

	mov	eax, DWORD PTR status$[rsp]

; 3191 : }

	add	rsp, 72					; 00000048H
	ret	0
?SendIrpSync@@YAJPEAU_IRP@@PEAU_KEVENT@@@Z ENDP		; SendIrpSync
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SendIrpDataToClt@@YAXPEAU_DEVICE_EXTENSION@@@Z DD imagerel ?SendIrpDataToClt@@YAXPEAU_DEVICE_EXTENSION@@@Z
	DD	imagerel ?SendIrpDataToClt@@YAXPEAU_DEVICE_EXTENSION@@@Z+158
	DD	imagerel $unwind$?SendIrpDataToClt@@YAXPEAU_DEVICE_EXTENSION@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SendIrpDataToClt@@YAXPEAU_DEVICE_EXTENSION@@@Z DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?SendIrpDataToClt@@YAXPEAU_DEVICE_EXTENSION@@@Z
_TEXT	SEGMENT
pIrpList$ = 32
pClientIrp$29232 = 40
pFirst$29231 = 48
pDevExt$ = 80
?SendIrpDataToClt@@YAXPEAU_DEVICE_EXTENSION@@@Z PROC	; SendIrpDataToClt, COMDAT

; 3115 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 3116 : 	PLIST_ENTRY pIrpList = &pDevExt->pIrpList;

	mov	rax, QWORD PTR pDevExt$[rsp]
	add	rax, 272				; 00000110H
	mov	QWORD PTR pIrpList$[rsp], rax
$LN3@SendIrpDat:

; 3117 : 
; 3118 : 	// Pass the intercepted IRPs and their data to any
; 3119 : 	// waiting client IRP.
; 3120 : 	//
; 3121 : 	while (!IsListEmpty(pIrpList)) {

	mov	rcx, QWORD PTR pIrpList$[rsp]
	call	IsListEmpty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@SendIrpDat

; 3122 : 		if (CBDataBufferEmpty(&pDevExt->DataBuffer)) break;

	mov	rcx, QWORD PTR pDevExt$[rsp]
	add	rcx, 80					; 00000050H
	call	?CBDataBufferEmpty@@YAEPEAU_CIRCULAR_BUFFER@@@Z ; CBDataBufferEmpty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@SendIrpDat
	jmp	SHORT $LN2@SendIrpDat
$LN1@SendIrpDat:

; 3123 : 		PLIST_ENTRY pFirst = RemoveHeadList(pIrpList);

	mov	rcx, QWORD PTR pIrpList$[rsp]
	call	RemoveHeadList
	mov	QWORD PTR pFirst$29231[rsp], rax

; 3124 : 
; 3125 : 		// About IRP cancellation: we are removing the IRP from the
; 3126 : 		// queue, so, should the I/O manager cancel it, the cancel 
; 3127 : 		// routine will not process it.
; 3128 : 		//
; 3129 : 		// This is OK, because from now on, the IRP will not be held
; 3130 : 		// into a queue waiting for something (namely, the presence
; 3131 : 		// of intercepted data). It will instead, be completed. So,
; 3132 : 		// we are not interested in its cancellation: what's important 
; 3133 : 		// is not to hold indefinitely into a queue an IRP which must be 
; 3134 : 		// cancelled.
; 3135 : 		//
; 3136 : 		// True, the IRP will be queued waiting for the DPC which will
; 3137 : 		// complete it, but this is bound to happen. That is the
; 3138 : 		// IRP will not be held indefinitely, waiting for some event
; 3139 : 		// to occur, as is the case when it's in the queue waiting for
; 3140 : 		// intercepted data.
; 3141 : 
; 3142 : 		PIRP pClientIrp = CONTAINING_RECORD(pFirst, IRP, 
; 3143 : 			Tail.Overlay.ListEntry);

	mov	rax, QWORD PTR pFirst$29231[rsp]
	sub	rax, 168				; 000000a8H
	mov	QWORD PTR pClientIrp$29232[rsp], rax

; 3144 : 
; 3145 : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 3146 : 			"FLT - SendIrpDataToClt - Client IRP %#p dequeued\n", 
; 3147 : 			pClientIrp);

	mov	r9, QWORD PTR pClientIrp$29232[rsp]
	lea	r8, OFFSET FLAT:??_C@_0DC@JPOPAAME@FLT?5?9?5SendIrpDataToClt?5?9?5Client?5@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 3148 : 
; 3149 : 		MoveIrpDataToCltIrp(pDevExt, pClientIrp);

	mov	rdx, QWORD PTR pClientIrp$29232[rsp]
	mov	rcx, QWORD PTR pDevExt$[rsp]
	call	?MoveIrpDataToCltIrp@@YAXPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z ; MoveIrpDataToCltIrp

; 3150 : 		QueueCltIrpForCompletion(pDevExt, pClientIrp);

	mov	rdx, QWORD PTR pClientIrp$29232[rsp]
	mov	rcx, QWORD PTR pDevExt$[rsp]
	call	?QueueCltIrpForCompletion@@YAXPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z ; QueueCltIrpForCompletion

; 3151 : 	}

	jmp	SHORT $LN3@SendIrpDat
$LN2@SendIrpDat:

; 3152 : 	return;
; 3153 : }

	add	rsp, 72					; 00000048H
	ret	0
?SendIrpDataToClt@@YAXPEAU_DEVICE_EXTENSION@@@Z ENDP	; SendIrpDataToClt
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?QueueCltIrp@@YAJPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z DD imagerel ?QueueCltIrp@@YAJPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z
	DD	imagerel ?QueueCltIrp@@YAJPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z+82
	DD	imagerel $unwind$?QueueCltIrp@@YAJPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?QueueCltIrp@@YAJPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?QueueCltIrp@@YAJPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z
_TEXT	SEGMENT
pDevExt$ = 48
pCltIrp$ = 56
?QueueCltIrp@@YAJPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z PROC ; QueueCltIrp, COMDAT

; 2982 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 2983 : 	IoSetCancelRoutine(pCltIrp, FACancel);

	mov	rax, QWORD PTR pCltIrp$[rsp]
	add	rax, 104				; 00000068H
	lea	rcx, OFFSET FLAT:?FACancel@@YAXPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ; FACancel
	xchg	QWORD PTR [rax], rcx

; 2984 : 	IoMarkIrpPending(pCltIrp);

	mov	rcx, QWORD PTR pCltIrp$[rsp]
	call	IoMarkIrpPending

; 2985 : 	InsertTailList(
; 2986 : 		&pDevExt->pIrpList,
; 2987 : 		&pCltIrp->Tail.Overlay.ListEntry);

	mov	rdx, QWORD PTR pCltIrp$[rsp]
	add	rdx, 168				; 000000a8H
	mov	rcx, QWORD PTR pDevExt$[rsp]
	add	rcx, 272				; 00000110H
	call	InsertTailList

; 2988 : 
; 2989 : 	// Abount cancellation: this function is called inside the dispatch
; 2990 : 	// routine, therefore phase 1 cannot begin while inside of it,
; 2991 : 	// because it doesn't begin until the dispatch routine returns.
; 2992 : 	//
; 2993 : 	// We can therefore be sure that, if cancellation does occur, this
; 2994 : 	// happens only after we have set up our cancel routine
; 2995 : 	//
; 2996 : 	return STATUS_PENDING;

	mov	eax, 259				; 00000103H

; 2997 : }

	add	rsp, 40					; 00000028H
	ret	0
?QueueCltIrp@@YAJPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z ENDP ; QueueCltIrp
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MinorFunctionDes@@YAPEADEEPEAD_K@Z DD imagerel ?MinorFunctionDes@@YAPEADEEPEAD_K@Z
	DD	imagerel ?MinorFunctionDes@@YAPEADEEPEAD_K@Z+182
	DD	imagerel $unwind$?MinorFunctionDes@@YAPEADEEPEAD_K@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MinorFunctionDes@@YAPEADEEPEAD_K@Z DD 011601H
	DD	08216H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?MinorFunctionDes@@YAPEADEEPEAD_K@Z
_TEXT	SEGMENT
tv65 = 48
MajorFunction$ = 80
MinorFunction$ = 88
pszDecodeBuf$ = 96
cbBufSize$ = 104
?MinorFunctionDes@@YAPEADEEPEAD_K@Z PROC		; MinorFunctionDes, COMDAT

; 2745 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	BYTE PTR [rsp+16], dl
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 72					; 00000048H

; 2746 : 	switch (MajorFunction) {

	mov	al, BYTE PTR MajorFunction$[rsp]
	mov	BYTE PTR tv65[rsp], al
	cmp	BYTE PTR tv65[rsp], 22
	je	SHORT $LN2@MinorFunct@2
	cmp	BYTE PTR tv65[rsp], 27
	je	SHORT $LN3@MinorFunct@2
	jmp	SHORT $LN1@MinorFunct@2
$LN3@MinorFunct@2:

; 2747 : 		case IRP_MJ_PNP:
; 2748 : 			return DecodeEnum(
; 2749 : 				MinorFunction,
; 2750 : 				0,
; 2751 : 				pszPnpMinorFunctionV,
; 2752 : 				sizeof pszPnpMinorFunctionV / sizeof (PSTR),
; 2753 : 				pszDecodeBuf,
; 2754 : 				cbBufSize);

	movzx	ecx, BYTE PTR MinorFunction$[rsp]
	mov	rax, QWORD PTR cbBufSize$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR pszDecodeBuf$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 24
	lea	r8, OFFSET FLAT:?pszPnpMinorFunctionV@@3PAPEADA ; pszPnpMinorFunctionV
	xor	edx, edx
	call	?DecodeEnum@@YAPEADHHQEAPEADHPEAD_K@Z	; DecodeEnum
	jmp	SHORT $LN6@MinorFunct@2

; 2755 : 			break;

	jmp	SHORT $LN4@MinorFunct@2
$LN2@MinorFunct@2:

; 2756 : 		case IRP_MJ_POWER:
; 2757 : 			return DecodeEnum(
; 2758 : 				MinorFunction,
; 2759 : 				0,
; 2760 : 				pszPowerMinorFunctionV,
; 2761 : 				sizeof pszPowerMinorFunctionV / sizeof (PSTR),
; 2762 : 				pszDecodeBuf,
; 2763 : 				cbBufSize);

	movzx	ecx, BYTE PTR MinorFunction$[rsp]
	mov	rax, QWORD PTR cbBufSize$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR pszDecodeBuf$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 4
	lea	r8, OFFSET FLAT:?pszPowerMinorFunctionV@@3PAPEADA ; pszPowerMinorFunctionV
	xor	edx, edx
	call	?DecodeEnum@@YAPEADHHQEAPEADHPEAD_K@Z	; DecodeEnum
	jmp	SHORT $LN6@MinorFunct@2

; 2764 : 			break;

	jmp	SHORT $LN4@MinorFunct@2
$LN1@MinorFunct@2:

; 2765 : 		default:
; 2766 : 			RtlStringCbPrintfA(
; 2767 : 				pszDecodeBuf,
; 2768 : 				cbBufSize,
; 2769 : 				"%#x",
; 2770 : 				MinorFunction);

	movzx	r9d, BYTE PTR MinorFunction$[rsp]
	lea	r8, OFFSET FLAT:??_C@_03JELKHEKI@?$CF?$CDx?$AA@FNODOBFM@
	mov	rdx, QWORD PTR cbBufSize$[rsp]
	mov	rcx, QWORD PTR pszDecodeBuf$[rsp]
	call	RtlStringCbPrintfA

; 2771 : 			return pszDecodeBuf;

	mov	rax, QWORD PTR pszDecodeBuf$[rsp]
$LN4@MinorFunct@2:
$LN6@MinorFunct@2:

; 2772 : 	}
; 2773 : }

	add	rsp, 72					; 00000048H
	ret	0
?MinorFunctionDes@@YAPEADEEPEAD_K@Z ENDP		; MinorFunctionDes
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MajorFunctionDes@@YAPEADEPEAD_K@Z DD imagerel ?MajorFunctionDes@@YAPEADEPEAD_K@Z
	DD	imagerel ?MajorFunctionDes@@YAPEADEPEAD_K@Z+68
	DD	imagerel $unwind$?MajorFunctionDes@@YAPEADEPEAD_K@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MajorFunctionDes@@YAPEADEPEAD_K@Z DD 011201H
	DD	06212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?MajorFunctionDes@@YAPEADEPEAD_K@Z
_TEXT	SEGMENT
MajorFunction$ = 64
pszDecodeBuf$ = 72
cbBufSize$ = 80
?MajorFunctionDes@@YAPEADEPEAD_K@Z PROC			; MajorFunctionDes, COMDAT

; 2653 : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	BYTE PTR [rsp+8], cl
	sub	rsp, 56					; 00000038H

; 2654 : 	return DecodeEnum(
; 2655 : 		MajorFunction,
; 2656 : 		0,
; 2657 : 		pszMajorFunctionV,
; 2658 : 		sizeof pszMajorFunctionV / sizeof(PSTR),
; 2659 : 		pszDecodeBuf,
; 2660 : 		cbBufSize);

	movzx	ecx, BYTE PTR MajorFunction$[rsp]
	mov	rax, QWORD PTR cbBufSize$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR pszDecodeBuf$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, 28
	lea	r8, OFFSET FLAT:?pszMajorFunctionV@@3PAPEADA ; pszMajorFunctionV
	xor	edx, edx
	call	?DecodeEnum@@YAPEADHHQEAPEADHPEAD_K@Z	; DecodeEnum

; 2661 : }

	add	rsp, 56					; 00000038H
	ret	0
?MajorFunctionDes@@YAPEADEPEAD_K@Z ENDP			; MajorFunctionDes
_TEXT	ENDS
PUBLIC	$T30698
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MADispatchRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD imagerel ?MADispatchRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
	DD	imagerel ?MADispatchRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z+443
	DD	imagerel $unwind$?MADispatchRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MADispatchRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD 041301H
	DD	0990113H
	DD	0600b700cH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?MADispatchRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
_TEXT	SEGMENT
pAdl$ = 32
ReqBytes$ = 40
pStack$ = 48
status$ = 56
pMastDevExt$ = 64
pDevInfoLink$ = 72
i$29110 = 80
pFADevExt$29114 = 88
$T30698 = 96
pDevObj$ = 1248
pIrp$ = 1256
?MADispatchRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z PROC ; MADispatchRead, COMDAT

; 2572 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 1224				; 000004c8H

; 2573 : 	NTSTATUS status;
; 2574 : 
; 2575 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 2576 : 		"FLT - MADispatchRead - Entered. pIrp = %#p", pIrp);

	mov	r9, QWORD PTR pIrp$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0CL@KFEIBEJF@FLT?5?9?5MADispatchRead?5?9?5Entered?4?5@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 2577 : 	PIO_STACK_LOCATION pStack;
; 2578 : 	PACCESS_DEVICES_LIST pAdl;
; 2579 : 	status = CheckMAReadParams(pIrp, pDevObj, &pStack, &pAdl);

	lea	r9, QWORD PTR pAdl$[rsp]
	lea	r8, QWORD PTR pStack$[rsp]
	mov	rdx, QWORD PTR pDevObj$[rsp]
	mov	rcx, QWORD PTR pIrp$[rsp]
	call	?CheckMAReadParams@@YAJPEAU_IRP@@PEAU_DEVICE_OBJECT@@PEAPEAU_IO_STACK_LOCATION@@PEAPEAU_ACCESS_DEVICES_LIST@@@Z ; CheckMAReadParams
	mov	DWORD PTR status$[rsp], eax

; 2580 : 
; 2581 : 	if (!NT_SUCCESS(status)) return status;

	cmp	DWORD PTR status$[rsp], 0
	jge	SHORT $LN7@MADispatch
	mov	eax, DWORD PTR status$[rsp]
	jmp	$LN8@MADispatch
$LN7@MADispatch:

; 2582 : 
; 2583 : 	PMADEVICE_EXTENSION pMastDevExt = (PMADEVICE_EXTENSION) 
; 2584 : 		pDevObj->DeviceExtension;

	mov	rax, QWORD PTR pDevObj$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR pMastDevExt$[rsp], rax

; 2585 : 
; 2586 : 	// Compute the size the buffer must have to receive all the
; 2587 : 	// data.
; 2588 : 	//
; 2589 : 	ULONG ReqBytes = FIELD_OFFSET(ACCESS_DEVICES_LIST, TargDevVect) +
; 2590 : 		pMastDevExt->FADevsCount * sizeof (TARGET_DEVICE_INFO);

	mov	rax, QWORD PTR pMastDevExt$[rsp]
	mov	eax, DWORD PTR [rax+40]
	imul	rax, 1114				; 0000045aH
	add	rax, 16
	mov	DWORD PTR ReqBytes$[rsp], eax

; 2591 : 	if (pStack->Parameters.Read.Length < ReqBytes) {

	mov	rcx, QWORD PTR pStack$[rsp]
	mov	eax, DWORD PTR ReqBytes$[rsp]
	cmp	DWORD PTR [rcx+8], eax
	jae	SHORT $LN6@MADispatch

; 2592 : 		pAdl->bIncomplete = TRUE;

	mov	rax, QWORD PTR pAdl$[rsp]
	mov	BYTE PTR [rax], 1

; 2593 : 	} else {

	jmp	SHORT $LN5@MADispatch
$LN6@MADispatch:

; 2594 : 		pAdl->bIncomplete = FALSE;

	mov	rax, QWORD PTR pAdl$[rsp]
	mov	BYTE PTR [rax], 0
$LN5@MADispatch:

; 2595 : 	}
; 2596 : 	pAdl->ReqBufSize = ReqBytes;

	mov	ecx, DWORD PTR ReqBytes$[rsp]
	mov	rax, QWORD PTR pAdl$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 2597 : 
; 2598 : 	// Compute the # of TARGET_DEVICE_INFO that can fit into the buffer
; 2599 : 	//
; 2600 : 	pAdl->DevInfoCount = (pStack->Parameters.Read.Length -
; 2601 : 		FIELD_OFFSET(ACCESS_DEVICES_LIST, TargDevVect)) / 
; 2602 : 		sizeof (TARGET_DEVICE_INFO);

	mov	rax, QWORD PTR pStack$[rsp]
	mov	eax, DWORD PTR [rax+8]
	sub	eax, 16
	mov	eax, eax
	xor	edx, edx
	mov	ecx, 1114				; 0000045aH
	div	rcx
	mov	rcx, rax
	mov	rax, QWORD PTR pAdl$[rsp]
	mov	DWORD PTR [rax+4], ecx

; 2603 : 
; 2604 : 	// If the actual # of info struct is less, return the actual count.
; 2605 : 	//
; 2606 : 	if (pAdl->DevInfoCount > pMastDevExt->FADevsCount)

	mov	rcx, QWORD PTR pAdl$[rsp]
	mov	rax, QWORD PTR pMastDevExt$[rsp]
	mov	eax, DWORD PTR [rax+40]
	cmp	DWORD PTR [rcx+4], eax
	jbe	SHORT $LN4@MADispatch

; 2607 : 		pAdl->DevInfoCount = pMastDevExt->FADevsCount;

	mov	rcx, QWORD PTR pAdl$[rsp]
	mov	rax, QWORD PTR pMastDevExt$[rsp]
	mov	eax, DWORD PTR [rax+40]
	mov	DWORD PTR [rcx+4], eax
$LN4@MADispatch:

; 2608 : 
; 2609 : 	// Compute the # of bytes transferred from the # of dev info
; 2610 : 	//
; 2611 : 	pIrp->IoStatus.Information = 
; 2612 : 		FIELD_OFFSET(ACCESS_DEVICES_LIST, TargDevVect) + 
; 2613 : 		pAdl->DevInfoCount *
; 2614 : 		sizeof (TARGET_DEVICE_INFO);

	mov	rax, QWORD PTR pAdl$[rsp]
	mov	ecx, DWORD PTR [rax+4]
	imul	rcx, 1114				; 0000045aH
	add	rcx, 16
	mov	rax, QWORD PTR pIrp$[rsp]
	mov	QWORD PTR [rax+56], rcx

; 2615 : 
; 2616 : 	PLIST_ENTRY pDevInfoLink = pMastDevExt->FADevsList.Flink;

	mov	rax, QWORD PTR pMastDevExt$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR pDevInfoLink$[rsp], rax

; 2617 : 
; 2618 : 	// Copy only the TARGET_DEVICE_INFOs that fit.
; 2619 : 	//
; 2620 : 	for (ULONG i = 0; i < pAdl->DevInfoCount; i++) {

	mov	DWORD PTR i$29110[rsp], 0
	jmp	SHORT $LN3@MADispatch
$LN2@MADispatch:
	mov	eax, DWORD PTR i$29110[rsp]
	add	eax, 1
	mov	DWORD PTR i$29110[rsp], eax
$LN3@MADispatch:
	mov	rax, QWORD PTR pAdl$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR i$29110[rsp], eax
	jae	SHORT $LN1@MADispatch

; 2621 : 		PFADEVICE_EXTENSION pFADevExt =
; 2622 : 			CONTAINING_RECORD(pDevInfoLink, FADEVICE_EXTENSION,
; 2623 : 				ListEntry);

	mov	rax, QWORD PTR pDevInfoLink$[rsp]
	sub	rax, 1144				; 00000478H
	mov	QWORD PTR pFADevExt$29114[rsp], rax

; 2624 : 		pAdl->TargDevVect[i] = pFADevExt->TargDevInfo;

	lea	rdi, QWORD PTR $T30698[rsp]
	mov	rsi, QWORD PTR pFADevExt$29114[rsp]
	add	rsi, 24
	mov	ecx, 1114				; 0000045aH
	rep movsb
	mov	ecx, DWORD PTR i$29110[rsp]
	imul	rcx, 1114				; 0000045aH
	mov	rax, QWORD PTR pAdl$[rsp]
	lea	rsi, QWORD PTR $T30698[rsp]
	lea	rdi, QWORD PTR [rax+rcx+16]
	mov	ecx, 1114				; 0000045aH
	rep movsb

; 2625 : 		pDevInfoLink = pDevInfoLink->Flink;

	mov	rax, QWORD PTR pDevInfoLink$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR pDevInfoLink$[rsp], rax

; 2626 : 	}

	jmp	SHORT $LN2@MADispatch
$LN1@MADispatch:

; 2627 : 	pIrp->IoStatus.Status = STATUS_SUCCESS;

	mov	rax, QWORD PTR pIrp$[rsp]
	mov	DWORD PTR [rax+48], 0

; 2628 : 	return STATUS_SUCCESS;

	xor	eax, eax
$LN8@MADispatch:

; 2629 : }

	add	rsp, 1224				; 000004c8H
	pop	rdi
	pop	rsi
	ret	0
?MADispatchRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ENDP ; MADispatchRead
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GetTargDevInfo@@YAJPEAU_FADEVICE_EXTENSION@@@Z DD imagerel ?GetTargDevInfo@@YAJPEAU_FADEVICE_EXTENSION@@@Z
	DD	imagerel ?GetTargDevInfo@@YAJPEAU_FADEVICE_EXTENSION@@@Z+1326
	DD	imagerel $unwind$?GetTargDevInfo@@YAJPEAU_FADEVICE_EXTENSION@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GetTargDevInfo@@YAJPEAU_FADEVICE_EXTENSION@@@Z DD 020c01H
	DD	011010cH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?GetTargDevInfo@@YAJPEAU_FADEVICE_EXTENSION@@@Z
_TEXT	SEGMENT
pFltDevExt$ = 48
pTargStack$ = 56
pStack$ = 64
IrpComplEv$ = 72
StackSize$ = 96
status$ = 100
IrpStatus$ = 104
pQueryIrp$ = 112
pFaDevExt$ = 144
?GetTargDevInfo@@YAJPEAU_FADEVICE_EXTENSION@@@Z PROC	; GetTargDevInfo, COMDAT

; 1897 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 136				; 00000088H

; 1898 : 	// We will send PNP IRPs to the target stack to query its
; 1899 : 	// information.
; 1900 : 
; 1901 : 	NTSTATUS status = STATUS_SUCCESS;

	mov	DWORD PTR status$[rsp], 0

; 1902 : 	KEVENT IrpComplEv;
; 1903 : 
; 1904 : 	// Initialize the event used to wait for IRPs to complete
; 1905 : 	//
; 1906 : 	KeInitializeEvent(&IrpComplEv, NotificationEvent, FALSE);

	xor	r8d, r8d
	xor	edx, edx
	lea	rcx, QWORD PTR IrpComplEv$[rsp]
	call	QWORD PTR __imp_KeInitializeEvent

; 1907 : 
; 1908 : 
; 1909 : 	// Get the number of stack locations needed.
; 1910 : 	//
; 1911 : 	PDEVICE_EXTENSION pFltDevExt = pFaDevExt->pFilterDevExt;

	mov	rax, QWORD PTR pFaDevExt$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR pFltDevExt$[rsp], rax

; 1912 : 	PDEVICE_OBJECT pTargStack = pFltDevExt->pTargStack;

	mov	rax, QWORD PTR pFltDevExt$[rsp]
	mov	rax, QWORD PTR [rax+288]
	mov	QWORD PTR pTargStack$[rsp], rax

; 1913 : 	CCHAR StackSize = pTargStack->StackSize;

	mov	rax, QWORD PTR pTargStack$[rsp]
	movzx	eax, BYTE PTR [rax+76]
	mov	BYTE PTR StackSize$[rsp], al

; 1914 : 
; 1915 : 	// Note on the stack size.
; 1916 : 	//
; 1917 : 	// pTargStack->StackSize gives the # of stack locations needed by
; 1918 : 	// the device below our filter.
; 1919 : 	//
; 1920 : 	// We will allocate an IRP with this number of stack locations,
; 1921 : 	// so it will not have a stack location for the filter device.
; 1922 : 	//
; 1923 : 	// We don't need it, because we only need to pass the IRP down
; 1924 : 	// the stack, with a completion routine attached, to get the
; 1925 : 	// outcome. IoSetCompletionRoutine() actually sets the routine 
; 1926 : 	// address into the stack location below the current one, so
; 1927 : 	// this call does not need a stack location for the current device.
; 1928 : 	//
; 1929 : 	// By examining IoGetCurrentIrpStackLocation(),
; 1930 : 	// IoGetNextIrpStackLocation() and IoSetNextIrpStackLocation()
; 1931 : 	// in wdm.h, we find out that the stack location for the topmost
; 1932 : 	// device is the one at the highest address.
; 1933 : 	// IoGetCurrentIrpStackLocation() returns the value of a pointer
; 1934 : 	// stored inside the IRP. Calling IoGetNextIrpStackLocation() 
; 1935 : 	// returns the address of the current SL pointer minus the size of 
; 1936 : 	// an SL, i. e., the SL for the device below us is at the next lower 
; 1937 : 	// address.
; 1938 : 	//
; 1939 : 	// We also find that IoSetNextIrpStackLocation() decrements the
; 1940 : 	// current SL pointer.
; 1941 : 	//
; 1942 : 	// We can put these facts together with how we use an IRP we 
; 1943 : 	// are setting up: after the allocation, we can immediately 
; 1944 : 	// call IoGetNextIrpStackLocation() to grab tha SL for the device
; 1945 : 	// below us and set the relevant fields. This means the current SL
; 1946 : 	// pointer has the address of the SL for the next device + the
; 1947 : 	// size of an SL, because IoGetNextIrpStackLocation() just returns
; 1948 : 	// current ptr minus SL size.
; 1949 : 	//
; 1950 : 	// Yet, since the SL for the device below us is the one at the 
; 1951 : 	// highest address (when we don't allocate an extra SL for 
; 1952 : 	// ourselves), this means the current SL pointer is actually 
; 1953 : 	// pointing outside our IRP at whatever lays after it.
; 1954 : 	//
; 1955 : 	// This is confirmed by the DDK, which states:
; 1956 : 	//
; 1957 : 	// "If a driver allocates an I/O stack location of its own in a new 
; 1958 : 	// IRP, the dispatch routine must call IoSetNextIrpStackLocation 
; 1959 : 	// before it calls IoGetCurrentIrpStackLocation to set up context in
; 1960 : 	// its own I/O stack location...".
; 1961 : 	//
; 1962 : 	// IoSetNextIrpStackLocation() just decrements the current SL 
; 1963 : 	// pointer by the size of an SL and IoGetCurrentIrpStackLocation()
; 1964 : 	// just returns the current pointer value. So, BEFORE using the
; 1965 : 	// current pointer value, we must decrement it, because it's
; 1966 : 	// pointing outside the IRP.
; 1967 : 	//
; 1968 : 	// In other words, a freshly initialized IRP has its current SL
; 1969 : 	// pointer set to an address outside the IRP. If we know we have
; 1970 : 	// reserved one extra SL for us, we can decrement it, with
; 1971 : 	// IoSet..., otherwise we are forbidden to touch the current
; 1972 : 	// SL (which actually does not exist) and must restrict ourselves
; 1973 : 	// to using the next one, returned by IoGetNext... which returns
; 1974 : 	// current ptr minus size.
; 1975 : 	//
; 1976 : 	// Probably, arraging SLs this way helps the system in detecting 
; 1977 : 	// when some code is trying to use an IRP with too few SLs for a 
; 1978 : 	// given device tree. As the IRP travels down the stack, the current
; 1979 : 	// SL ptr is decremented, so the system can detect if it bumps 
; 1980 : 	// against the beginning of the SLs array inside the IRP. If the 
; 1981 : 	// system were to increment the SL ptr, it should have kept track of 
; 1982 : 	// the SLs array size to perform the same check.
; 1983 : 
; 1984 : 	// Allocate the IRP
; 1985 : 	//
; 1986 : 	PIRP pQueryIrp = IoAllocateIrp(StackSize, FALSE);

	xor	edx, edx
	movzx	ecx, BYTE PTR StackSize$[rsp]
	call	QWORD PTR __imp_IoAllocateIrp
	mov	QWORD PTR pQueryIrp$[rsp], rax

; 1987 : 	if (pQueryIrp == NULL) return STATUS_NO_MEMORY;

	cmp	QWORD PTR pQueryIrp$[rsp], 0
	jne	SHORT $LN16@GetTargDev
	mov	eax, -1073741801			; ffffffffc0000017H
	jmp	$LN17@GetTargDev
$LN16@GetTargDev:

; 1988 : 
; 1989 : 	// Set the IRP up
; 1990 : 	//
; 1991 : 	pQueryIrp->Flags = 0;

	mov	rax, QWORD PTR pQueryIrp$[rsp]
	mov	DWORD PTR [rax+16], 0

; 1992 : 	pQueryIrp->RequestorMode = KernelMode;

	mov	rax, QWORD PTR pQueryIrp$[rsp]
	mov	BYTE PTR [rax+64], 0

; 1993 : 	pQueryIrp->Tail.Overlay.Thread = 0;

	mov	rax, QWORD PTR pQueryIrp$[rsp]
	mov	QWORD PTR [rax+152], 0

; 1994 : 	pQueryIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;

	mov	rax, QWORD PTR pQueryIrp$[rsp]
	mov	DWORD PTR [rax+48], -1073741637		; ffffffffc00000bbH

; 1995 : 
; 1996 : 	// Set the I/O stack for the IRP_MN_QUERY_DEVICE_TEXT call.
; 1997 : 	//
; 1998 : 	PIO_STACK_LOCATION pStack = IoGetNextIrpStackLocation(pQueryIrp);

	mov	rcx, QWORD PTR pQueryIrp$[rsp]
	call	IoGetNextIrpStackLocation
	mov	QWORD PTR pStack$[rsp], rax

; 1999 : 	pStack->MajorFunction = IRP_MJ_PNP;

	mov	rax, QWORD PTR pStack$[rsp]
	mov	BYTE PTR [rax], 27

; 2000 : 	pStack->MinorFunction = IRP_MN_QUERY_DEVICE_TEXT;

	mov	rax, QWORD PTR pStack$[rsp]
	mov	BYTE PTR [rax+1], 12

; 2001 : 	pStack->Flags = 0;

	mov	rax, QWORD PTR pStack$[rsp]
	mov	BYTE PTR [rax+2], 0

; 2002 : 	pStack->DeviceObject = pTargStack;

	mov	rcx, QWORD PTR pStack$[rsp]
	mov	rax, QWORD PTR pTargStack$[rsp]
	mov	QWORD PTR [rcx+40], rax

; 2003 : 
; 2004 : 	// Send the IRP. We'll wait for it to complete.
; 2005 : 	//
; 2006 : 	NTSTATUS IrpStatus = SendIrpSync(pQueryIrp, &IrpComplEv);

	lea	rdx, QWORD PTR IrpComplEv$[rsp]
	mov	rcx, QWORD PTR pQueryIrp$[rsp]
	call	?SendIrpSync@@YAJPEAU_IRP@@PEAU_KEVENT@@@Z ; SendIrpSync
	mov	DWORD PTR IrpStatus$[rsp], eax

; 2007 : 	if (NT_SUCCESS(IrpStatus)) {

	cmp	DWORD PTR IrpStatus$[rsp], 0
	jl	$LN15@GetTargDev

; 2008 : 
; 2009 : 		// Get the device text
; 2010 : 		//
; 2011 : 		if (pQueryIrp->IoStatus.Information) {

	mov	rax, QWORD PTR pQueryIrp$[rsp]
	cmp	QWORD PTR [rax+56], 0
	je	SHORT $LN14@GetTargDev

; 2012 : 			DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 2013 : 				"FLT - GetTargDevInfo - Filter: %#x, FA: %#x, "
; 2014 : 				"device text: %S\n",
; 2015 : 				pFaDevExt->pFilterDevExt->hdr.pDevice,
; 2016 : 				pFaDevExt->hdr.pDevice,
; 2017 : 				(PWCHAR) pQueryIrp->IoStatus.Information);

	mov	r9, QWORD PTR pFaDevExt$[rsp]
	mov	r9, QWORD PTR [r9+16]
	mov	rax, QWORD PTR pQueryIrp$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR pFaDevExt$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR [r9+8]
	lea	r8, OFFSET FLAT:??_C@_0DO@BAPDNIJJ@FLT?5?9?5GetTargDevInfo?5?9?5Filter?3?5?$CF@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 2018 : 			CopyWString(
; 2019 : 				(PWCHAR) &pFaDevExt->TargDevInfo.DeviceText, 
; 2020 : 				(PWCHAR) pQueryIrp->IoStatus.Information,
; 2021 : 				sizeof pFaDevExt->TargDevInfo.DeviceText);

	mov	rcx, QWORD PTR pFaDevExt$[rsp]
	add	rcx, 532				; 00000214H
	mov	r8d, 202				; 000000caH
	mov	rdx, QWORD PTR pQueryIrp$[rsp]
	mov	rdx, QWORD PTR [rdx+56]
	call	?CopyWString@@YAXPEAG0_K@Z		; CopyWString

; 2022 : 
; 2023 : 			// We must free the storage for the string allocated by the
; 2024 : 			// driver which processed our IRP, just as the I/O manager
; 2025 : 			// would do.
; 2026 : 			ExFreePool((PVOID) pQueryIrp->IoStatus.Information);

	xor	edx, edx
	mov	rcx, QWORD PTR pQueryIrp$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	call	QWORD PTR __imp_ExFreePoolWithTag
$LN14@GetTargDev:
$LN15@GetTargDev:

; 2027 : 
; 2028 : 		}
; 2029 : 	}
; 2030 : 
; 2031 : 	// The status variable stores the overall status. Update it only
; 2032 : 	// if it does not already hold an error value.
; 2033 : 	//
; 2034 : 	if (NT_SUCCESS(status)) status = IrpStatus;

	cmp	DWORD PTR status$[rsp], 0
	jl	SHORT $LN13@GetTargDev
	mov	eax, DWORD PTR IrpStatus$[rsp]
	mov	DWORD PTR status$[rsp], eax
$LN13@GetTargDev:

; 2035 : 
; 2036 : 	// Set the IRP up for th IRP_MQ_QUERY_ID/BusQueryDeviceId
; 2037 : 	//
; 2038 : 	IoReuseIrp(pQueryIrp, STATUS_NOT_SUPPORTED);

	mov	edx, -1073741637			; ffffffffc00000bbH
	mov	rcx, QWORD PTR pQueryIrp$[rsp]
	call	QWORD PTR __imp_IoReuseIrp

; 2039 : 	// IoSetNextIrpStackLocation(pQueryIrp);
; 2040 : 	pQueryIrp->Flags = 0;

	mov	r11, QWORD PTR pQueryIrp$[rsp]
	mov	DWORD PTR [r11+16], 0

; 2041 : 	pQueryIrp->RequestorMode = KernelMode;

	mov	rax, QWORD PTR pQueryIrp$[rsp]
	mov	BYTE PTR [rax+64], 0

; 2042 : 	pQueryIrp->Tail.Overlay.Thread = 0;

	mov	rax, QWORD PTR pQueryIrp$[rsp]
	mov	QWORD PTR [rax+152], 0

; 2043 : 	pStack = IoGetNextIrpStackLocation(pQueryIrp);

	mov	rcx, QWORD PTR pQueryIrp$[rsp]
	call	IoGetNextIrpStackLocation
	mov	QWORD PTR pStack$[rsp], rax

; 2044 : 	pStack->MajorFunction = IRP_MJ_PNP;

	mov	rax, QWORD PTR pStack$[rsp]
	mov	BYTE PTR [rax], 27

; 2045 : 	pStack->MinorFunction = IRP_MN_QUERY_ID;

	mov	rax, QWORD PTR pStack$[rsp]
	mov	BYTE PTR [rax+1], 19

; 2046 : 	pStack->Parameters.QueryId.IdType = BusQueryDeviceID;

	mov	rax, QWORD PTR pStack$[rsp]
	mov	DWORD PTR [rax+8], 0

; 2047 : 	pStack->Flags = 0;

	mov	rax, QWORD PTR pStack$[rsp]
	mov	BYTE PTR [rax+2], 0

; 2048 : 	pStack->DeviceObject = pTargStack;

	mov	rcx, QWORD PTR pStack$[rsp]
	mov	rax, QWORD PTR pTargStack$[rsp]
	mov	QWORD PTR [rcx+40], rax

; 2049 : 	IrpStatus = SendIrpSync(pQueryIrp, &IrpComplEv);

	lea	rdx, QWORD PTR IrpComplEv$[rsp]
	mov	rcx, QWORD PTR pQueryIrp$[rsp]
	call	?SendIrpSync@@YAJPEAU_IRP@@PEAU_KEVENT@@@Z ; SendIrpSync
	mov	DWORD PTR IrpStatus$[rsp], eax

; 2050 : 	if (NT_SUCCESS(IrpStatus)) {

	cmp	DWORD PTR IrpStatus$[rsp], 0
	jl	SHORT $LN12@GetTargDev

; 2051 : 		if (pQueryIrp->IoStatus.Information) {

	mov	rax, QWORD PTR pQueryIrp$[rsp]
	cmp	QWORD PTR [rax+56], 0
	je	SHORT $LN11@GetTargDev

; 2052 : 			CopyWString(
; 2053 : 				(PWCHAR) &pFaDevExt->TargDevInfo.DeviceId, 
; 2054 : 				(PWCHAR) pQueryIrp->IoStatus.Information,
; 2055 : 				sizeof pFaDevExt->TargDevInfo.DeviceId);

	mov	rcx, QWORD PTR pFaDevExt$[rsp]
	add	rcx, 330				; 0000014aH
	mov	r8d, 202				; 000000caH
	mov	rdx, QWORD PTR pQueryIrp$[rsp]
	mov	rdx, QWORD PTR [rdx+56]
	call	?CopyWString@@YAXPEAG0_K@Z		; CopyWString

; 2056 : 			ExFreePool((PVOID) pQueryIrp->IoStatus.Information);

	xor	edx, edx
	mov	rcx, QWORD PTR pQueryIrp$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	call	QWORD PTR __imp_ExFreePoolWithTag
$LN11@GetTargDev:
$LN12@GetTargDev:

; 2057 : 		}
; 2058 : 	}
; 2059 : 	if (NT_SUCCESS(status)) status = IrpStatus;

	cmp	DWORD PTR status$[rsp], 0
	jl	SHORT $LN10@GetTargDev
	mov	eax, DWORD PTR IrpStatus$[rsp]
	mov	DWORD PTR status$[rsp], eax
$LN10@GetTargDev:

; 2060 : 
; 2061 : 	// Set the IRP up for th IRP_MQ_QUERY_ID/BusQueryInstanceID
; 2062 : 	//
; 2063 : 	IoReuseIrp(pQueryIrp, STATUS_NOT_SUPPORTED);

	mov	edx, -1073741637			; ffffffffc00000bbH
	mov	rcx, QWORD PTR pQueryIrp$[rsp]
	call	QWORD PTR __imp_IoReuseIrp

; 2064 : 	pQueryIrp->Flags = 0;

	mov	r11, QWORD PTR pQueryIrp$[rsp]
	mov	DWORD PTR [r11+16], 0

; 2065 : 	pQueryIrp->RequestorMode = KernelMode;

	mov	rax, QWORD PTR pQueryIrp$[rsp]
	mov	BYTE PTR [rax+64], 0

; 2066 : 	pQueryIrp->Tail.Overlay.Thread = 0;

	mov	rax, QWORD PTR pQueryIrp$[rsp]
	mov	QWORD PTR [rax+152], 0

; 2067 : 	pStack = IoGetNextIrpStackLocation(pQueryIrp);

	mov	rcx, QWORD PTR pQueryIrp$[rsp]
	call	IoGetNextIrpStackLocation
	mov	QWORD PTR pStack$[rsp], rax

; 2068 : 	pStack->MajorFunction = IRP_MJ_PNP;

	mov	rax, QWORD PTR pStack$[rsp]
	mov	BYTE PTR [rax], 27

; 2069 : 	pStack->MinorFunction = IRP_MN_QUERY_ID;

	mov	rax, QWORD PTR pStack$[rsp]
	mov	BYTE PTR [rax+1], 19

; 2070 : 	pStack->Parameters.QueryId.IdType = BusQueryInstanceID;

	mov	rax, QWORD PTR pStack$[rsp]
	mov	DWORD PTR [rax+8], 3

; 2071 : 	pStack->Flags = 0;

	mov	rax, QWORD PTR pStack$[rsp]
	mov	BYTE PTR [rax+2], 0

; 2072 : 	pStack->DeviceObject = pTargStack;

	mov	rcx, QWORD PTR pStack$[rsp]
	mov	rax, QWORD PTR pTargStack$[rsp]
	mov	QWORD PTR [rcx+40], rax

; 2073 : 	IrpStatus = SendIrpSync(pQueryIrp, &IrpComplEv);

	lea	rdx, QWORD PTR IrpComplEv$[rsp]
	mov	rcx, QWORD PTR pQueryIrp$[rsp]
	call	?SendIrpSync@@YAJPEAU_IRP@@PEAU_KEVENT@@@Z ; SendIrpSync
	mov	DWORD PTR IrpStatus$[rsp], eax

; 2074 : 	if (NT_SUCCESS(IrpStatus)) {

	cmp	DWORD PTR IrpStatus$[rsp], 0
	jl	SHORT $LN9@GetTargDev

; 2075 : 		if (pQueryIrp->IoStatus.Information) {

	mov	rax, QWORD PTR pQueryIrp$[rsp]
	cmp	QWORD PTR [rax+56], 0
	je	SHORT $LN8@GetTargDev

; 2076 : 			CopyWString(
; 2077 : 				(PWCHAR) &pFaDevExt->TargDevInfo.InstanceId, 
; 2078 : 				(PWCHAR) pQueryIrp->IoStatus.Information,
; 2079 : 				sizeof pFaDevExt->TargDevInfo.InstanceId);

	mov	rcx, QWORD PTR pFaDevExt$[rsp]
	add	rcx, 936				; 000003a8H
	mov	r8d, 202				; 000000caH
	mov	rdx, QWORD PTR pQueryIrp$[rsp]
	mov	rdx, QWORD PTR [rdx+56]
	call	?CopyWString@@YAXPEAG0_K@Z		; CopyWString

; 2080 : 			ExFreePool((PVOID) pQueryIrp->IoStatus.Information);

	xor	edx, edx
	mov	rcx, QWORD PTR pQueryIrp$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	call	QWORD PTR __imp_ExFreePoolWithTag
$LN8@GetTargDev:
$LN9@GetTargDev:

; 2081 : 		}
; 2082 : 	}
; 2083 : 	if (NT_SUCCESS(status)) status = IrpStatus;

	cmp	DWORD PTR status$[rsp], 0
	jl	SHORT $LN7@GetTargDev
	mov	eax, DWORD PTR IrpStatus$[rsp]
	mov	DWORD PTR status$[rsp], eax
$LN7@GetTargDev:

; 2084 : 
; 2085 : 	// Set the IRP up for th IRP_MQ_QUERY_ID/BusQueryHardwareIDs
; 2086 : 	//
; 2087 : 	IoReuseIrp(pQueryIrp, STATUS_NOT_SUPPORTED);

	mov	edx, -1073741637			; ffffffffc00000bbH
	mov	rcx, QWORD PTR pQueryIrp$[rsp]
	call	QWORD PTR __imp_IoReuseIrp

; 2088 : 	// IoSetNextIrpStackLocation(pQueryIrp);
; 2089 : 	pQueryIrp->Flags = 0;

	mov	r11, QWORD PTR pQueryIrp$[rsp]
	mov	DWORD PTR [r11+16], 0

; 2090 : 	pQueryIrp->RequestorMode = KernelMode;

	mov	rax, QWORD PTR pQueryIrp$[rsp]
	mov	BYTE PTR [rax+64], 0

; 2091 : 	pQueryIrp->Tail.Overlay.Thread = 0;

	mov	rax, QWORD PTR pQueryIrp$[rsp]
	mov	QWORD PTR [rax+152], 0

; 2092 : 	pStack = IoGetNextIrpStackLocation(pQueryIrp);

	mov	rcx, QWORD PTR pQueryIrp$[rsp]
	call	IoGetNextIrpStackLocation
	mov	QWORD PTR pStack$[rsp], rax

; 2093 : 	pStack->MajorFunction = IRP_MJ_PNP;

	mov	rax, QWORD PTR pStack$[rsp]
	mov	BYTE PTR [rax], 27

; 2094 : 	pStack->MinorFunction = IRP_MN_QUERY_ID;

	mov	rax, QWORD PTR pStack$[rsp]
	mov	BYTE PTR [rax+1], 19

; 2095 : 	pStack->Parameters.QueryId.IdType = BusQueryHardwareIDs;

	mov	rax, QWORD PTR pStack$[rsp]
	mov	DWORD PTR [rax+8], 1

; 2096 : 	pStack->Flags = 0;

	mov	rax, QWORD PTR pStack$[rsp]
	mov	BYTE PTR [rax+2], 0

; 2097 : 	pStack->DeviceObject = pTargStack;

	mov	rcx, QWORD PTR pStack$[rsp]
	mov	rax, QWORD PTR pTargStack$[rsp]
	mov	QWORD PTR [rcx+40], rax

; 2098 : 	IrpStatus = SendIrpSync(pQueryIrp, &IrpComplEv);

	lea	rdx, QWORD PTR IrpComplEv$[rsp]
	mov	rcx, QWORD PTR pQueryIrp$[rsp]
	call	?SendIrpSync@@YAJPEAU_IRP@@PEAU_KEVENT@@@Z ; SendIrpSync
	mov	DWORD PTR IrpStatus$[rsp], eax

; 2099 : 	if (NT_SUCCESS(IrpStatus)) {

	cmp	DWORD PTR IrpStatus$[rsp], 0
	jl	SHORT $LN6@GetTargDev

; 2100 : 		if (pQueryIrp->IoStatus.Information) {

	mov	rax, QWORD PTR pQueryIrp$[rsp]
	cmp	QWORD PTR [rax+56], 0
	je	SHORT $LN5@GetTargDev

; 2101 : 			CopyMultiWString(
; 2102 : 				(PWCHAR) &pFaDevExt->TargDevInfo.HardwareIDs, 
; 2103 : 				(PWCHAR) pQueryIrp->IoStatus.Information,
; 2104 : 				sizeof pFaDevExt->TargDevInfo.HardwareIDs);

	mov	rcx, QWORD PTR pFaDevExt$[rsp]
	add	rcx, 734				; 000002deH
	mov	r8d, 202				; 000000caH
	mov	rdx, QWORD PTR pQueryIrp$[rsp]
	mov	rdx, QWORD PTR [rdx+56]
	call	?CopyMultiWString@@YAXPEAG0_K@Z		; CopyMultiWString

; 2105 : 			ExFreePool((PVOID) pQueryIrp->IoStatus.Information);

	xor	edx, edx
	mov	rcx, QWORD PTR pQueryIrp$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	call	QWORD PTR __imp_ExFreePoolWithTag
$LN5@GetTargDev:
$LN6@GetTargDev:

; 2106 : 		}
; 2107 : 	}
; 2108 : 	if (NT_SUCCESS(status)) status = IrpStatus;

	cmp	DWORD PTR status$[rsp], 0
	jl	SHORT $LN4@GetTargDev
	mov	eax, DWORD PTR IrpStatus$[rsp]
	mov	DWORD PTR status$[rsp], eax
$LN4@GetTargDev:

; 2109 : 
; 2110 : 	// Set the IRP up for th IRP_MQ_QUERY_ID/BusQueryCompatibleIDs
; 2111 : 	//
; 2112 : 	IoReuseIrp(pQueryIrp, STATUS_NOT_SUPPORTED);

	mov	edx, -1073741637			; ffffffffc00000bbH
	mov	rcx, QWORD PTR pQueryIrp$[rsp]
	call	QWORD PTR __imp_IoReuseIrp

; 2113 : 	pQueryIrp->Flags = 0;

	mov	r11, QWORD PTR pQueryIrp$[rsp]
	mov	DWORD PTR [r11+16], 0

; 2114 : 	pQueryIrp->RequestorMode = KernelMode;

	mov	rax, QWORD PTR pQueryIrp$[rsp]
	mov	BYTE PTR [rax+64], 0

; 2115 : 	pQueryIrp->Tail.Overlay.Thread = 0;

	mov	rax, QWORD PTR pQueryIrp$[rsp]
	mov	QWORD PTR [rax+152], 0

; 2116 : 	pStack = IoGetNextIrpStackLocation(pQueryIrp);

	mov	rcx, QWORD PTR pQueryIrp$[rsp]
	call	IoGetNextIrpStackLocation
	mov	QWORD PTR pStack$[rsp], rax

; 2117 : 	pStack->MajorFunction = IRP_MJ_PNP;

	mov	rax, QWORD PTR pStack$[rsp]
	mov	BYTE PTR [rax], 27

; 2118 : 	pStack->MinorFunction = IRP_MN_QUERY_ID;

	mov	rax, QWORD PTR pStack$[rsp]
	mov	BYTE PTR [rax+1], 19

; 2119 : 	pStack->Parameters.QueryId.IdType = BusQueryCompatibleIDs;

	mov	rax, QWORD PTR pStack$[rsp]
	mov	DWORD PTR [rax+8], 2

; 2120 : 	pStack->Flags = 0;

	mov	rax, QWORD PTR pStack$[rsp]
	mov	BYTE PTR [rax+2], 0

; 2121 : 	pStack->DeviceObject = pTargStack;

	mov	rcx, QWORD PTR pStack$[rsp]
	mov	rax, QWORD PTR pTargStack$[rsp]
	mov	QWORD PTR [rcx+40], rax

; 2122 : 	IrpStatus = SendIrpSync(pQueryIrp, &IrpComplEv);

	lea	rdx, QWORD PTR IrpComplEv$[rsp]
	mov	rcx, QWORD PTR pQueryIrp$[rsp]
	call	?SendIrpSync@@YAJPEAU_IRP@@PEAU_KEVENT@@@Z ; SendIrpSync
	mov	DWORD PTR IrpStatus$[rsp], eax

; 2123 : 	if (NT_SUCCESS(IrpStatus)) {

	cmp	DWORD PTR IrpStatus$[rsp], 0
	jl	SHORT $LN3@GetTargDev

; 2124 : 		if (pQueryIrp->IoStatus.Information) {

	mov	rax, QWORD PTR pQueryIrp$[rsp]
	cmp	QWORD PTR [rax+56], 0
	je	SHORT $LN2@GetTargDev

; 2125 : 			CopyMultiWString(
; 2126 : 				(PWCHAR) &pFaDevExt->TargDevInfo.CompatibleIDs, 
; 2127 : 				(PWCHAR) pQueryIrp->IoStatus.Information,
; 2128 : 				sizeof pFaDevExt->TargDevInfo.CompatibleIDs);

	mov	rcx, QWORD PTR pFaDevExt$[rsp]
	add	rcx, 128				; 00000080H
	mov	r8d, 202				; 000000caH
	mov	rdx, QWORD PTR pQueryIrp$[rsp]
	mov	rdx, QWORD PTR [rdx+56]
	call	?CopyMultiWString@@YAXPEAG0_K@Z		; CopyMultiWString

; 2129 : 			ExFreePool((PVOID) pQueryIrp->IoStatus.Information);

	xor	edx, edx
	mov	rcx, QWORD PTR pQueryIrp$[rsp]
	mov	rcx, QWORD PTR [rcx+56]
	call	QWORD PTR __imp_ExFreePoolWithTag
$LN2@GetTargDev:
$LN3@GetTargDev:

; 2130 : 		}
; 2131 : 	}
; 2132 : 	if (NT_SUCCESS(status)) status = IrpStatus;

	cmp	DWORD PTR status$[rsp], 0
	jl	SHORT $LN1@GetTargDev
	mov	eax, DWORD PTR IrpStatus$[rsp]
	mov	DWORD PTR status$[rsp], eax
$LN1@GetTargDev:

; 2133 : 
; 2134 : 	IoFreeIrp(pQueryIrp);

	mov	rcx, QWORD PTR pQueryIrp$[rsp]
	call	QWORD PTR __imp_IoFreeIrp

; 2135 : 
; 2136 : 	return status;

	mov	eax, DWORD PTR status$[rsp]
$LN17@GetTargDev:

; 2137 : }

	add	rsp, 136				; 00000088H
	ret	0
?GetTargDevInfo@@YAJPEAU_FADEVICE_EXTENSION@@@Z ENDP	; GetTargDevInfo
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FADispatchRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD imagerel ?FADispatchRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
	DD	imagerel ?FADispatchRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z+193
	DD	imagerel $unwind$?FADispatchRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FADispatchRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?FADispatchRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
_TEXT	SEGMENT
pFltExt$ = 32
LockHandle$ = 40
status$ = 64
pFaExt$ = 72
pDevObj$ = 96
pIrp$ = 104
?FADispatchRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z PROC ; FADispatchRead, COMDAT

; 1157 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1158 : 	NTSTATUS status;
; 1159 : 	status = CheckFAReadParams(pIrp);

	mov	rcx, QWORD PTR pIrp$[rsp]
	call	?CheckFAReadParams@@YAJPEAU_IRP@@@Z	; CheckFAReadParams
	mov	DWORD PTR status$[rsp], eax

; 1160 : 
; 1161 : 	if (!NT_SUCCESS(status)) return status;

	cmp	DWORD PTR status$[rsp], 0
	jge	SHORT $LN2@FADispatch@2
	mov	eax, DWORD PTR status$[rsp]
	jmp	$LN3@FADispatch@2
$LN2@FADispatch@2:

; 1162 : 
; 1163 : 	PFADEVICE_EXTENSION pFaExt = 
; 1164 : 		(PFADEVICE_EXTENSION) pDevObj->DeviceExtension;

	mov	rax, QWORD PTR pDevObj$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR pFaExt$[rsp], rax

; 1165 : 
; 1166 : 	// Get the extension of the filter device
; 1167 : 	//
; 1168 : 	PDEVICE_EXTENSION pFltExt = pFaExt->pFilterDevExt;

	mov	rax, QWORD PTR pFaExt$[rsp]
	mov	rax, QWORD PTR [rax+16]
	mov	QWORD PTR pFltExt$[rsp], rax

; 1169 : 	KLOCK_QUEUE_HANDLE	LockHandle;
; 1170 : 	KeAcquireInStackQueuedSpinLock(
; 1171 : 		&pFltExt->DataLock,
; 1172 : 		&LockHandle);

	mov	rcx, QWORD PTR pFltExt$[rsp]
	add	rcx, 136				; 00000088H
	lea	rdx, QWORD PTR LockHandle$[rsp]
	call	QWORD PTR __imp_KeAcquireInStackQueuedSpinLock

; 1173 : 
; 1174 : 	// Queue the client IRP.
; 1175 : 	//
; 1176 : 	status = QueueCltIrp(pFltExt, pIrp);

	mov	rdx, QWORD PTR pIrp$[rsp]
	mov	rcx, QWORD PTR pFltExt$[rsp]
	call	?QueueCltIrp@@YAJPEAU_DEVICE_EXTENSION@@PEAU_IRP@@@Z ; QueueCltIrp
	mov	DWORD PTR status$[rsp], eax

; 1177 : 	if (!NT_SUCCESS(status)) {

	cmp	DWORD PTR status$[rsp], 0
	jge	SHORT $LN1@FADispatch@2

; 1178 : 		KeReleaseInStackQueuedSpinLock(&LockHandle);

	lea	rcx, QWORD PTR LockHandle$[rsp]
	call	QWORD PTR __imp_KeReleaseInStackQueuedSpinLock

; 1179 : 		return status;

	mov	eax, DWORD PTR status$[rsp]
	jmp	SHORT $LN3@FADispatch@2
$LN1@FADispatch@2:

; 1180 : 	}
; 1181 : 
; 1182 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1183 : 		"FLT - FADispatchRead - Client IRP %#p queued for "
; 1184 : 		"processing\n", pIrp);

	mov	r9, QWORD PTR pIrp$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0DN@OOMCMHGN@FLT?5?9?5FADispatchRead?5?9?5Client?5IR@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 1185 : 
; 1186 : 
; 1187 : 	// Schedule the processing of the queued IRP (if there are data)
; 1188 : 	//
; 1189 : 	SendIrpDataToClt(pFltExt);

	mov	rcx, QWORD PTR pFltExt$[rsp]
	call	?SendIrpDataToClt@@YAXPEAU_DEVICE_EXTENSION@@@Z ; SendIrpDataToClt

; 1190 : 
; 1191 : 	KeReleaseInStackQueuedSpinLock(&LockHandle);

	lea	rcx, QWORD PTR LockHandle$[rsp]
	call	QWORD PTR __imp_KeReleaseInStackQueuedSpinLock

; 1192 : 
; 1193 : 	return status;

	mov	eax, DWORD PTR status$[rsp]
$LN3@FADispatch@2:

; 1194 : 
; 1195 : }

	add	rsp, 88					; 00000058H
	ret	0
?FADispatchRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ENDP ; FADispatchRead
_TEXT	ENDS
PUBLIC	__$ArrayPad$
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CreateDevice@@YAJPEAU_DRIVER_OBJECT@@PEAGKPEAPEAU_DEVICE_OBJECT@@J1@Z DD imagerel ?CreateDevice@@YAJPEAU_DRIVER_OBJECT@@PEAGKPEAPEAU_DEVICE_OBJECT@@J1@Z
	DD	imagerel ?CreateDevice@@YAJPEAU_DRIVER_OBJECT@@PEAGKPEAPEAU_DEVICE_OBJECT@@J1@Z+796
	DD	imagerel $unwind$?CreateDevice@@YAJPEAU_DRIVER_OBJECT@@PEAGKPEAPEAU_DEVICE_OBJECT@@J1@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CreateDevice@@YAJPEAU_DRIVER_OBJECT@@PEAGKPEAPEAU_DEVICE_OBJECT@@J1@Z DD 022d19H
	DD	031011bH
	DD	imagerel __GSHandlerCheck
	DD	0170H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?CreateDevice@@YAJPEAU_DRIVER_OBJECT@@PEAGKPEAPEAU_DEVICE_OBJECT@@J1@Z
_TEXT	SEGMENT
uIntName$ = 64
uSymName$ = 80
wszSymNameBuf$ = 112
pDevObj$ = 224
wszIntNameBuf$ = 240
status$ = 352
i$28637 = 356
StrCharLen$28635 = 360
__$ArrayPad$ = 368
pDriverObject$ = 400
pBaseName$ = 408
DevExtSize$ = 416
ppDev$ = 424
SeqNum$ = 432
pwszSymLink$ = 440
?CreateDevice@@YAJPEAU_DRIVER_OBJECT@@PEAGKPEAPEAU_DEVICE_OBJECT@@J1@Z PROC ; CreateDevice, COMDAT

; 916  : {

	mov	QWORD PTR [rsp+32], r9
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 392				; 00000188H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 917  : 
; 918  : 	PDEVICE_OBJECT	pDevObj = NULL;

	mov	QWORD PTR pDevObj$[rsp], 0

; 919  : 	NTSTATUS		status;
; 920  : 
; 921  : 	*ppDev = NULL;

	mov	rax, QWORD PTR ppDev$[rsp]
	mov	QWORD PTR [rax], 0

; 922  : 
; 923  : 	// Form the device name
; 924  : 	//
; 925  : 	WCHAR			wszIntNameBuf[NAME_BUF_SIZE];
; 926  : 	UNICODE_STRING	uIntName;
; 927  : 	wszIntNameBuf[0] = L'\0';

	xor	eax, eax
	mov	WORD PTR wszIntNameBuf$[rsp], ax

; 928  : 	uIntName.Length = 0;

	xor	eax, eax
	mov	WORD PTR uIntName$[rsp], ax

; 929  : 	uIntName.MaximumLength = sizeof wszIntNameBuf;

	mov	eax, 102				; 00000066H
	mov	WORD PTR uIntName$[rsp+2], ax

; 930  : 	uIntName.Buffer = wszIntNameBuf;

	lea	rax, QWORD PTR wszIntNameBuf$[rsp]
	mov	QWORD PTR uIntName$[rsp+8], rax

; 931  : 	if (SeqNum != -1) {

	cmp	DWORD PTR SeqNum$[rsp], -1
	je	SHORT $LN14@CreateDevi

; 932  : 		status = RtlUnicodeStringPrintf(
; 933  : 			&uIntName,
; 934  : 			L"\\Device\\%s%d",
; 935  : 			pBaseName,
; 936  : 			SeqNum);

	mov	r9d, DWORD PTR SeqNum$[rsp]
	mov	r8, QWORD PTR pBaseName$[rsp]
	lea	rdx, OFFSET FLAT:??_C@_1BK@BKIFJHAA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AA?$CF?$AAs?$AA?$CF?$AAd?$AA?$AA@FNODOBFM@
	lea	rcx, QWORD PTR uIntName$[rsp]
	call	RtlUnicodeStringPrintf
	mov	DWORD PTR status$[rsp], eax

; 937  : 	} else {

	jmp	SHORT $LN13@CreateDevi
$LN14@CreateDevi:

; 938  : 		status = RtlUnicodeStringPrintf(
; 939  : 			&uIntName,
; 940  : 			L"\\Device\\%s",
; 941  : 			pBaseName);

	mov	r8, QWORD PTR pBaseName$[rsp]
	lea	rdx, OFFSET FLAT:??_C@_1BG@EDLFNGEH@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@
	lea	rcx, QWORD PTR uIntName$[rsp]
	call	RtlUnicodeStringPrintf
	mov	DWORD PTR status$[rsp], eax
$LN13@CreateDevi:

; 942  : 	}
; 943  : 	if (!NT_SUCCESS(status)) return status;

	cmp	DWORD PTR status$[rsp], 0
	jge	SHORT $LN12@CreateDevi
	mov	eax, DWORD PTR status$[rsp]
	jmp	$LN15@CreateDevi
$LN12@CreateDevi:

; 944  : 
; 945  : 	// Form the symbolic link name
; 946  : 	//
; 947  : 	WCHAR			wszSymNameBuf[NAME_BUF_SIZE];
; 948  : 	UNICODE_STRING	uSymName;
; 949  : 	wszSymNameBuf[0] = L'\0';

	xor	eax, eax
	mov	WORD PTR wszSymNameBuf$[rsp], ax

; 950  : 	uSymName.Length = 0;

	xor	eax, eax
	mov	WORD PTR uSymName$[rsp], ax

; 951  : 	uSymName.MaximumLength = sizeof wszSymNameBuf;

	mov	eax, 102				; 00000066H
	mov	WORD PTR uSymName$[rsp+2], ax

; 952  : 	uSymName.Buffer = wszSymNameBuf;

	lea	rax, QWORD PTR wszSymNameBuf$[rsp]
	mov	QWORD PTR uSymName$[rsp+8], rax

; 953  : 	if (SeqNum != -1) {

	cmp	DWORD PTR SeqNum$[rsp], -1
	je	SHORT $LN11@CreateDevi

; 954  : 		status = RtlUnicodeStringPrintf(
; 955  : 			&uSymName,
; 956  : 			L"\\??\\%s%d",
; 957  : 			pBaseName,
; 958  : 			DevNumber);

	mov	r9d, DWORD PTR DevNumber
	mov	r8, QWORD PTR pBaseName$[rsp]
	lea	rdx, OFFSET FLAT:??_C@_1BC@MDHMAKOA@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$CF?$AAs?$AA?$CF?$AAd?$AA?$AA@FNODOBFM@
	lea	rcx, QWORD PTR uSymName$[rsp]
	call	RtlUnicodeStringPrintf
	mov	DWORD PTR status$[rsp], eax

; 959  : 	} else {

	jmp	SHORT $LN10@CreateDevi
$LN11@CreateDevi:

; 960  : 		status = RtlUnicodeStringPrintf(
; 961  : 			&uSymName,
; 962  : 			L"\\??\\%s",
; 963  : 			pBaseName);

	mov	r8, QWORD PTR pBaseName$[rsp]
	lea	rdx, OFFSET FLAT:??_C@_1O@PAJNNBDG@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@
	lea	rcx, QWORD PTR uSymName$[rsp]
	call	RtlUnicodeStringPrintf
	mov	DWORD PTR status$[rsp], eax
$LN10@CreateDevi:

; 964  : 	}
; 965  : 	if (!NT_SUCCESS(status)) return status;

	cmp	DWORD PTR status$[rsp], 0
	jge	SHORT $LN9@CreateDevi
	mov	eax, DWORD PTR status$[rsp]
	jmp	$LN15@CreateDevi
$LN9@CreateDevi:

; 966  : 
; 967  : 	// Copy the sym link name to the output buffer, if a buffer
; 968  : 	// has been specified
; 969  : 	//
; 970  : 	// pwszSymLink receives the sym link name. The UNICODE_STRING has a 
; 971  : 	// buffer of NAME_BUF_SIZE chars, however we are going to skip the
; 972  : 	// first 4 chars (\??\), so wszSymLink must hold NAME_BUF_SIZE - 4
; 973  : 	// chars. Furthermore, unicode strings do not have null 
; 974  : 	// terminators, but wszSymLink is a plain string, hence 
; 975  : 	// null-terminated. So wszSymLink must be NAME_BUF_SIZE - 3 chars.
; 976  : 	//
; 977  : 	if (pwszSymLink != NULL) {

	cmp	QWORD PTR pwszSymLink$[rsp], 0
	je	$LN8@CreateDevi

; 978  : 		ULONG StrCharLen = uSymName.Length / sizeof (WCHAR) - 4;

	movzx	eax, WORD PTR uSymName$[rsp]
	xor	edx, edx
	mov	ecx, 2
	div	rcx
	sub	rax, 4
	mov	DWORD PTR StrCharLen$28635[rsp], eax

; 979  : 		ULONG i = 0;

	mov	DWORD PTR i$28637[rsp], 0

; 980  : 		for (; i < StrCharLen; i++) {

	jmp	SHORT $LN7@CreateDevi
$LN6@CreateDevi:
	mov	eax, DWORD PTR i$28637[rsp]
	add	eax, 1
	mov	DWORD PTR i$28637[rsp], eax
$LN7@CreateDevi:
	mov	eax, DWORD PTR StrCharLen$28635[rsp]
	cmp	DWORD PTR i$28637[rsp], eax
	jae	SHORT $LN5@CreateDevi

; 981  : 			pwszSymLink[i] = uSymName.Buffer[i + 4];

	mov	eax, DWORD PTR i$28637[rsp]
	add	eax, 4
	mov	r8d, eax
	mov	edx, DWORD PTR i$28637[rsp]
	mov	rcx, QWORD PTR pwszSymLink$[rsp]
	mov	rax, QWORD PTR uSymName$[rsp+8]
	movzx	eax, WORD PTR [rax+r8*2]
	mov	WORD PTR [rcx+rdx*2], ax

; 982  : 		}

	jmp	SHORT $LN6@CreateDevi
$LN5@CreateDevi:

; 983  : 		pwszSymLink[i] = L'\0';

	mov	edx, DWORD PTR i$28637[rsp]
	xor	ecx, ecx
	mov	rax, QWORD PTR pwszSymLink$[rsp]
	mov	WORD PTR [rax+rdx*2], cx
$LN8@CreateDevi:

; 984  : 	}
; 985  : 	// Create the device
; 986  : 	//
; 987  : 	status =
; 988  : 		IoCreateDevice( pDriverObject,
; 989  : 						DevExtSize,
; 990  : 						&uIntName,
; 991  : 						FILE_DEVICE_UNKNOWN,
; 992  : 						0, FALSE,
; 993  : 						&pDevObj );

	lea	rax, QWORD PTR pDevObj$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	BYTE PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], 0
	mov	r9d, 34					; 00000022H
	lea	r8, QWORD PTR uIntName$[rsp]
	mov	edx, DWORD PTR DevExtSize$[rsp]
	mov	rcx, QWORD PTR pDriverObject$[rsp]
	call	QWORD PTR __imp_IoCreateDevice
	mov	DWORD PTR status$[rsp], eax

; 994  : 	if (!NT_SUCCESS(status)) {

	cmp	DWORD PTR status$[rsp], 0
	jge	SHORT $LN4@CreateDevi

; 995  : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 996  : 			"FLT - CreateDevice -  IoCreateDevice() failed with "
; 997  : 			"status %#010x\n",
; 998  : 			status);

	mov	r9d, DWORD PTR status$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0EC@EDKPLCPO@FLT?5?9?5CreateDevice?5?9?5?5IoCreateDe@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 999  : 		return status;

	mov	eax, DWORD PTR status$[rsp]
	jmp	$LN15@CreateDevi
$LN4@CreateDevi:

; 1000 : 	}
; 1001 : 
; 1002 : 	// Form the symbolic link name
; 1003 : 	status = 
; 1004 : 		IoCreateSymbolicLink( &uSymName,
; 1005 : 							  &uIntName );

	lea	rdx, QWORD PTR uIntName$[rsp]
	lea	rcx, QWORD PTR uSymName$[rsp]
	call	QWORD PTR __imp_IoCreateSymbolicLink
	mov	DWORD PTR status$[rsp], eax

; 1006 : 	if (!NT_SUCCESS(status)) {

	cmp	DWORD PTR status$[rsp], 0
	jge	SHORT $LN3@CreateDevi

; 1007 : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1008 : 			"FLT - CreateDevice - IoCreateSymbolicLink() failed "
; 1009 : 			"with status %#010x\n",
; 1010 : 			status);

	mov	r9d, DWORD PTR status$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0EH@MBIPFAHB@FLT?5?9?5CreateDevice?5?9?5IoCreateSym@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx
	jmp	SHORT $LN2@CreateDevi

; 1011 : 		goto Error_Cleanup;

	jmp	SHORT $Error_Cleanup$28647
$LN3@CreateDevi:

; 1012 : 	}
; 1013 : 
; 1014 : 	// Pass the device object ptr to the caller.
; 1015 : 	//
; 1016 : 	*ppDev = pDevObj;

	mov	rcx, QWORD PTR ppDev$[rsp]
	mov	rax, QWORD PTR pDevObj$[rsp]
	mov	QWORD PTR [rcx], rax

; 1017 : 	return STATUS_SUCCESS;

	xor	eax, eax
	jmp	SHORT $LN15@CreateDevi
$LN2@CreateDevi:
$Error_Cleanup$28647:

; 1018 : 
; 1019 : Error_Cleanup:
; 1020 : 	if (pDevObj != NULL) IoDeleteDevice(pDevObj);

	cmp	QWORD PTR pDevObj$[rsp], 0
	je	SHORT $LN1@CreateDevi
	mov	rcx, QWORD PTR pDevObj$[rsp]
	call	QWORD PTR __imp_IoDeleteDevice
$LN1@CreateDevi:

; 1021 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1022 : 		"FLT - CreateDevice - Failed. Returning status %#010x\n", 
; 1023 : 		status);

	mov	r9d, DWORD PTR status$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0DG@KJMBDFMO@FLT?5?9?5CreateDevice?5?9?5Failed?4?5Ret@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 1024 : 	return status;

	mov	eax, DWORD PTR status$[rsp]
$LN15@CreateDevi:

; 1025 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 392				; 00000188H
	ret	0
?CreateDevice@@YAJPEAU_DRIVER_OBJECT@@PEAGKPEAPEAU_DEVICE_OBJECT@@J1@Z ENDP ; CreateDevice
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
pdata	SEGMENT
$pdata$?AddDevice@@YAJPEAU_DRIVER_OBJECT@@PEAU_DEVICE_OBJECT@@@Z DD imagerel ?AddDevice@@YAJPEAU_DRIVER_OBJECT@@PEAU_DEVICE_OBJECT@@@Z
	DD	imagerel ?AddDevice@@YAJPEAU_DRIVER_OBJECT@@PEAU_DEVICE_OBJECT@@@Z+1468
	DD	imagerel $unwind$?AddDevice@@YAJPEAU_DRIVER_OBJECT@@PEAU_DEVICE_OBJECT@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?AddDevice@@YAJPEAU_DRIVER_OBJECT@@PEAU_DEVICE_OBJECT@@@Z DD 032419H
	DD	0220112H
	DD	0700bH
	DD	imagerel __GSHandlerCheck
	DD	0108H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?AddDevice@@YAJPEAU_DRIVER_OBJECT@@PEAU_DEVICE_OBJECT@@@Z
_TEXT	SEGMENT
wszSymLink$ = 64
pTagChar$ = 160
pTargStack$ = 168
pFaDevExt$ = 176
pFaDev$ = 184
status$ = 192
pFilterDev$ = 200
pDevExt$ = 208
pDataBuffer$ = 216
Tag$ = 224
hLock$ = 232
NewDevNumber$ = 256
i$28504 = 260
__$ArrayPad$ = 264
pDriverObject$ = 288
pTargDev$ = 296
?AddDevice@@YAJPEAU_DRIVER_OBJECT@@PEAU_DEVICE_OBJECT@@@Z PROC ; AddDevice, COMDAT

; 525  : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 272				; 00000110H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 526  : 	PDEVICE_OBJECT		pFaDev = NULL;

	mov	QWORD PTR pFaDev$[rsp], 0

; 527  : 	PVOID				pDataBuffer = NULL;

	mov	QWORD PTR pDataBuffer$[rsp], 0

; 528  : 	PDEVICE_EXTENSION	pDevExt;
; 529  : 	PDEVICE_OBJECT	pFilterDev = NULL;

	mov	QWORD PTR pFilterDev$[rsp], 0

; 530  : 	PDEVICE_OBJECT	pTargStack = NULL;

	mov	QWORD PTR pTargStack$[rsp], 0

; 531  : 	NTSTATUS		status;
; 532  : 
; 533  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 534  : 		"FLT - AddDevice - Entering, pTargDev: %#p\n", pTargDev);

	mov	r9, QWORD PTR pTargDev$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0CL@NAJACAOE@FLT?5?9?5AddDevice?5?9?5Entering?0?5pTar@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 535  : 
; 536  : 	// Acquire an unique device number to form the device names and
; 537  : 	// symbolic links
; 538  : 	//
; 539  : 	LONG NewDevNumber = InterlockedIncrement(&DevNumber);

	lea	rdx, OFFSET FLAT:DevNumber
	mov	eax, 1
	lock xadd DWORD PTR [rdx], eax
	add	eax, 1
	mov	DWORD PTR NewDevNumber$[rsp], eax

; 540  : 	status = CreateDevice(
; 541  : 		pDriverObject,
; 542  : 		DRV_DEVICE_NAME,
; 543  : 		sizeof (DEVICE_EXTENSION),
; 544  : 		&pFilterDev,
; 545  : 		NewDevNumber,
; 546  : 		NULL);

	mov	QWORD PTR [rsp+40], 0
	mov	eax, DWORD PTR NewDevNumber$[rsp]
	mov	DWORD PTR [rsp+32], eax
	lea	r9, QWORD PTR pFilterDev$[rsp]
	mov	r8d, 312				; 00000138H
	lea	rdx, OFFSET FLAT:??_C@_1BG@DCLHEFJL@?$AAT?$AAe?$AAs?$AAt?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AA?$AA@FNODOBFM@
	mov	rcx, QWORD PTR pDriverObject$[rsp]
	call	?CreateDevice@@YAJPEAU_DRIVER_OBJECT@@PEAGKPEAPEAU_DEVICE_OBJECT@@J1@Z ; CreateDevice
	mov	DWORD PTR status$[rsp], eax

; 547  : 	if (!NT_SUCCESS(status)) {

	cmp	DWORD PTR status$[rsp], 0
	jge	SHORT $LN14@AddDevice

; 548  : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 549  : 			"FLT - AddDevice - Failed to create filter dev with "
; 550  : 			"status: %#010x\n",
; 551  : 			status);

	mov	r9d, DWORD PTR status$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0ED@EDCCOAPN@FLT?5?9?5AddDevice?5?9?5Failed?5to?5crea@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 552  : 		return status;

	mov	eax, DWORD PTR status$[rsp]
	jmp	$LN15@AddDevice
$LN14@AddDevice:

; 553  : 	}
; 554  : 
; 555  : 	// Initialize the Device Extension
; 556  : 	//
; 557  : 	pDevExt = (PDEVICE_EXTENSION) pFilterDev->DeviceExtension;

	mov	rax, QWORD PTR pFilterDev$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR pDevExt$[rsp], rax

; 558  : 	pDevExt->hdr.DevType = DT_FILTER;

	mov	rax, QWORD PTR pDevExt$[rsp]
	mov	DWORD PTR [rax], 1

; 559  : 	pDevExt->hdr.pDevice = pFilterDev;	// back pointer

	mov	rcx, QWORD PTR pDevExt$[rsp]
	mov	rax, QWORD PTR pFilterDev$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 560  : 	pDevExt->dwFlags = 0;

	mov	rax, QWORD PTR pDevExt$[rsp]
	mov	DWORD PTR [rax+144], 0

; 561  : 	for (int i = 0; i < IRP_MJ_MAXIMUM_FUNCTION + 1; i++) 

	mov	DWORD PTR i$28504[rsp], 0
	jmp	SHORT $LN13@AddDevice
$LN12@AddDevice:
	mov	eax, DWORD PTR i$28504[rsp]
	add	eax, 1
	mov	DWORD PTR i$28504[rsp], eax
$LN13@AddDevice:
	cmp	DWORD PTR i$28504[rsp], 28
	jge	SHORT $LN11@AddDevice

; 562  : 		pDevExt->dwMJFlags[i] = MJ_FLAGS_DEFAULT;

	movsxd	rcx, DWORD PTR i$28504[rsp]
	mov	rax, QWORD PTR pDevExt$[rsp]
	mov	DWORD PTR [rax+rcx*4+148], 0
	jmp	SHORT $LN12@AddDevice
$LN11@AddDevice:

; 563  : 	KeInitializeSpinLock(&pDevExt->DataLock);

	mov	rcx, QWORD PTR pDevExt$[rsp]
	add	rcx, 136				; 00000088H
	call	KeInitializeSpinLock

; 564  : 	KeInitializeDpc(&pDevExt->ComplDpc, DpcCltIrpCompletion, pDevExt);

	mov	rcx, QWORD PTR pDevExt$[rsp]
	add	rcx, 16
	mov	r8, QWORD PTR pDevExt$[rsp]
	lea	rdx, OFFSET FLAT:?DpcCltIrpCompletion@@YAXPEAU_KDPC@@PEAX11@Z ; DpcCltIrpCompletion
	call	QWORD PTR __imp_KeInitializeDpc

; 565  : 	InitializeListHead(&pDevExt->pIrpList);

	mov	rcx, QWORD PTR pDevExt$[rsp]
	add	rcx, 272				; 00000110H
	call	InitializeListHead

; 566  : 	InitializeListHead(&pDevExt->pWaitingComplIrpList);

	mov	rcx, QWORD PTR pDevExt$[rsp]
	add	rcx, 296				; 00000128H
	call	InitializeListHead

; 567  : 	ULONG Tag;
; 568  : 	PCHAR pTagChar = (PCHAR) &Tag;

	lea	rdx, QWORD PTR Tag$[rsp]
	mov	QWORD PTR pTagChar$[rsp], rdx

; 569  : 	pTagChar[3] = 'F';

	mov	rax, QWORD PTR pTagChar$[rsp]
	mov	BYTE PTR [rax+3], 70			; 00000046H

; 570  : 	pTagChar[2] = 'i';

	mov	rax, QWORD PTR pTagChar$[rsp]
	mov	BYTE PTR [rax+2], 105			; 00000069H

; 571  : 	pTagChar[1] = 'l';

	mov	rax, QWORD PTR pTagChar$[rsp]
	mov	BYTE PTR [rax+1], 108			; 0000006cH

; 572  : 	pTagChar[0] = 't';

	mov	rax, QWORD PTR pTagChar$[rsp]
	mov	BYTE PTR [rax], 116			; 00000074H

; 573  : 	pTargStack = IoAttachDeviceToDeviceStack(
; 574  : 		pFilterDev,
; 575  : 		pTargDev);

	mov	rdx, QWORD PTR pTargDev$[rsp]
	mov	rcx, QWORD PTR pFilterDev$[rsp]
	call	QWORD PTR __imp_IoAttachDeviceToDeviceStack
	mov	QWORD PTR pTargStack$[rsp], rax

; 576  : 	if (pTargStack == NULL) {

	cmp	QWORD PTR pTargStack$[rsp], 0
	jne	SHORT $LN10@AddDevice

; 577  : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 578  : 			"FLT - AddDevice - Failed to attach filter to device %#p\n",
; 579  : 			pTargDev);

	mov	r9, QWORD PTR pTargDev$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0DJ@MNLFKKDM@FLT?5?9?5AddDevice?5?9?5Failed?5to?5atta@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 580  : 		status = STATUS_UNSUCCESSFUL;

	mov	DWORD PTR status$[rsp], -1073741823	; ffffffffc0000001H
	jmp	$LN9@AddDevice

; 581  : 		goto Error_Cleanup;

	jmp	$Error_Cleanup$28514
$LN10@AddDevice:

; 582  : 	}
; 583  : 
; 584  : 	// VERY IMPORTANT!
; 585  : 	//
; 586  : 	// Propagate the flags from the top of the filtered stack, so that the 
; 587  : 	// I/O manager will treat our filter as if it were the previous top 
; 588  : 	// device.
; 589  : 	//
; 590  : 	pFilterDev->Flags = pTargStack->Flags;

	mov	rcx, QWORD PTR pFilterDev$[rsp]
	mov	rax, QWORD PTR pTargStack$[rsp]
	mov	eax, DWORD PTR [rax+48]
	mov	DWORD PTR [rcx+48], eax

; 591  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 592  : 		"FLT - AddDevice - Attached filter\n"
; 593  : 			 "    filter:        %#p\n"
; 594  : 	         "    target device: %#p\n"
; 595  : 			 "    target stack:  %#p\n",
; 596  : 		pFilterDev,
; 597  : 		pTargDev,
; 598  : 		pTargStack);

	mov	rax, QWORD PTR pTargStack$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR pTargDev$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR pFilterDev$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0GI@HKPAOEPB@FLT?5?9?5AddDevice?5?9?5Attached?5filte@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 599  : 	pDevExt->pTargStack = pTargStack;

	mov	rdx, QWORD PTR pDevExt$[rsp]
	mov	rax, QWORD PTR pTargStack$[rsp]
	mov	QWORD PTR [rdx+288], rax

; 600  : 
; 601  : 	// Allocate the filter buffer
; 602  : 	//
; 603  : 	pDataBuffer = ExAllocatePoolWithTag(NonPagedPool, FILT_BUF_SIZE, 
; 604  : 		Tag);

	mov	r8d, DWORD PTR Tag$[rsp]
	mov	edx, 81920				; 00014000H
	xor	ecx, ecx
	call	QWORD PTR __imp_ExAllocatePoolWithTag
	mov	QWORD PTR pDataBuffer$[rsp], rax

; 605  : 	if (pDataBuffer == NULL) {

	cmp	QWORD PTR pDataBuffer$[rsp], 0
	jne	SHORT $LN8@AddDevice

; 606  : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 607  : 			"FLT - AddDevice - Failed to allocate the data "
; 608  : 			"buffer\n");

	lea	r8, OFFSET FLAT:??_C@_0DG@MKCCCIDK@FLT?5?9?5AddDevice?5?9?5Failed?5to?5allo@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 609  : 		status = STATUS_NO_MEMORY;

	mov	DWORD PTR status$[rsp], -1073741801	; ffffffffc0000017H
	jmp	$LN7@AddDevice

; 610  : 		goto Error_Cleanup;

	jmp	$Error_Cleanup$28514
$LN8@AddDevice:

; 611  : 	}
; 612  : 	CBInitBufferCtlVar(&pDevExt->DataBuffer, pDataBuffer, FILT_BUF_SIZE);

	mov	rcx, QWORD PTR pDevExt$[rsp]
	add	rcx, 80					; 00000050H
	mov	r8d, 81920				; 00014000H
	mov	rdx, QWORD PTR pDataBuffer$[rsp]
	call	?CBInitBufferCtlVar@@YAXPEAU_CIRCULAR_BUFFER@@PEAX_K@Z ; CBInitBufferCtlVar

; 613  : 
; 614  : 	// Create the filter access device
; 615  : 	//
; 616  : 	PFADEVICE_EXTENSION pFaDevExt;
; 617  : 
; 618  : 	// wszSymLink receives the sym link name. We need it to copy it
; 619  : 	// into the device extension.
; 620  : 	//
; 621  : 	WCHAR wszSymLink[NAME_BUF_SIZE - 3];
; 622  : 	status = CreateDevice(
; 623  : 		pDriverObject,
; 624  : 		FADEVICE_NAME,
; 625  : 		sizeof (FADEVICE_EXTENSION),
; 626  : 		&pFaDev,
; 627  : 		NewDevNumber,
; 628  : 		wszSymLink);

	lea	rdx, QWORD PTR wszSymLink$[rsp]
	mov	QWORD PTR [rsp+40], rdx
	mov	eax, DWORD PTR NewDevNumber$[rsp]
	mov	DWORD PTR [rsp+32], eax
	lea	r9, QWORD PTR pFaDev$[rsp]
	mov	r8d, 1160				; 00000488H
	lea	rdx, OFFSET FLAT:??_C@_1BG@BNCJKNLL@?$AAF?$AAi?$AAl?$AAt?$AAA?$AAc?$AAc?$AAe?$AAs?$AAs?$AA?$AA@FNODOBFM@
	mov	rcx, QWORD PTR pDriverObject$[rsp]
	call	?CreateDevice@@YAJPEAU_DRIVER_OBJECT@@PEAGKPEAPEAU_DEVICE_OBJECT@@J1@Z ; CreateDevice
	mov	DWORD PTR status$[rsp], eax

; 629  : 	if (!NT_SUCCESS(status)) {

	cmp	DWORD PTR status$[rsp], 0
	jge	SHORT $LN6@AddDevice

; 630  : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 631  : 			"FLT - AddDevice - Failed to create filter access dev with "
; 632  : 			"status: %#010x\n",
; 633  : 			status);

	mov	r9d, DWORD PTR status$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0EK@HBPFAIIB@FLT?5?9?5AddDevice?5?9?5Failed?5to?5crea@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx
	jmp	$LN5@AddDevice

; 634  : 		goto Error_Cleanup;

	jmp	$Error_Cleanup$28514
$LN6@AddDevice:

; 635  : 	}
; 636  : 	pFaDevExt = (PFADEVICE_EXTENSION) pFaDev->DeviceExtension;

	mov	rax, QWORD PTR pFaDev$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR pFaDevExt$[rsp], rax

; 637  : 
; 638  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 639  : 		"FLT - AddDevice - Filter access device created: %#p; dev "
; 640  : 		"ext: %#p\n",
; 641  : 		pFaDev, pFaDevExt);

	mov	rax, QWORD PTR pFaDevExt$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR pFaDev$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0ED@PAJPNGE@FLT?5?9?5AddDevice?5?9?5Filter?5access?5@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 642  : 
; 643  : 	// Initialize the device extension.
; 644  : 	//
; 645  : 	RtlZeroMemory(pFaDevExt, sizeof (PFADEVICE_EXTENSION));

	mov	rdi, QWORD PTR pFaDevExt$[rsp]
	xor	eax, eax
	mov	ecx, 8
	rep stosb

; 646  : 	pFaDevExt->hdr.DevType = DT_FILTER_ACCESS;

	mov	rax, QWORD PTR pFaDevExt$[rsp]
	mov	DWORD PTR [rax], 2

; 647  : 	pFaDevExt->hdr.pDevice = pFaDev;

	mov	rcx, QWORD PTR pFaDevExt$[rsp]
	mov	rax, QWORD PTR pFaDev$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 648  : 	pFaDevExt->pFilterDevExt = pDevExt;

	mov	rcx, QWORD PTR pFaDevExt$[rsp]
	mov	rax, QWORD PTR pDevExt$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 649  : 	CopyWString(
; 650  : 		(PWCHAR) &pFaDevExt->TargDevInfo.SymLink,
; 651  : 		(PWCHAR) wszSymLink,
; 652  : 		sizeof pFaDevExt->TargDevInfo.SymLink);

	mov	rcx, QWORD PTR pFaDevExt$[rsp]
	add	rcx, 24
	mov	r8d, 104				; 00000068H
	lea	rdx, QWORD PTR wszSymLink$[rsp]
	call	?CopyWString@@YAXPEAG0_K@Z		; CopyWString

; 653  : 
; 654  : 	// The filter access device uses direct I/O
; 655  : 	//
; 656  : 	pFaDev->Flags |= DO_DIRECT_IO;

	mov	rdx, QWORD PTR pFaDev$[rsp]
	mov	ecx, DWORD PTR [rdx+48]
	or	ecx, 16
	mov	rax, QWORD PTR pFaDev$[rsp]
	mov	DWORD PTR [rax+48], ecx

; 657  : 	pFaDev->Flags &= ~DO_DEVICE_INITIALIZING;

	mov	rax, QWORD PTR pFaDev$[rsp]
	mov	ecx, DWORD PTR [rax+48]
	and	ecx, -129				; ffffff7fH
	mov	rax, QWORD PTR pFaDev$[rsp]
	mov	DWORD PTR [rax+48], ecx

; 658  : 
; 659  : 
; 660  : 	// Set the address of the extension for the filter access dev into
; 661  : 	// the extension for the filter dev.
; 662  : 	//
; 663  : 	pDevExt->pFADevExt = pFaDevExt;

	mov	rcx, QWORD PTR pDevExt$[rsp]
	mov	rax, QWORD PTR pFaDevExt$[rsp]
	mov	QWORD PTR [rcx+264], rax

; 664  : 
; 665  : 	// Get the target device description, etc.
; 666  : 	//
; 667  : 	GetTargDevInfo(pFaDevExt);

	mov	rcx, QWORD PTR pFaDevExt$[rsp]
	call	?GetTargDevInfo@@YAJPEAU_FADEVICE_EXTENSION@@@Z ; GetTargDevInfo

; 668  : 
; 669  : 	// Add the FA device to the FA device list. The list head is stored
; 670  : 	// into the device extension of the master device 
; 671  : 	//
; 672  : 	KLOCK_QUEUE_HANDLE hLock;
; 673  : 	KeAcquireInStackQueuedSpinLock(&pMastDevExt->SyncLock,
; 674  : 		&hLock);

	mov	rcx, QWORD PTR pMastDevExt
	add	rcx, 16
	lea	rdx, QWORD PTR hLock$[rsp]
	call	QWORD PTR __imp_KeAcquireInStackQueuedSpinLock

; 675  : 	InsertTailList(
; 676  : 		&pMastDevExt->FADevsList, 
; 677  : 		&pFaDevExt->ListEntry);

	mov	rdx, QWORD PTR pFaDevExt$[rsp]
	add	rdx, 1144				; 00000478H
	mov	rcx, QWORD PTR pMastDevExt
	add	rcx, 24
	call	InsertTailList

; 678  : 	pMastDevExt->FADevsCount++;

	mov	rdx, QWORD PTR pMastDevExt
	mov	ecx, DWORD PTR [rdx+40]
	add	ecx, 1
	mov	rax, QWORD PTR pMastDevExt
	mov	DWORD PTR [rax+40], ecx

; 679  : 	KeReleaseInStackQueuedSpinLock(&hLock);

	lea	rcx, QWORD PTR hLock$[rsp]
	call	QWORD PTR __imp_KeReleaseInStackQueuedSpinLock

; 680  : 	return STATUS_SUCCESS;

	xor	eax, eax
	jmp	$LN15@AddDevice
$LN5@AddDevice:
$LN7@AddDevice:
$LN9@AddDevice:
$Error_Cleanup$28514:

; 681  : 
; 682  : Error_Cleanup:
; 683  : 	if (pFaDev != NULL) IoDeleteDevice (pFaDev);

	cmp	QWORD PTR pFaDev$[rsp], 0
	je	SHORT $LN4@AddDevice
	mov	rcx, QWORD PTR pFaDev$[rsp]
	call	QWORD PTR __imp_IoDeleteDevice
$LN4@AddDevice:

; 684  : 	if (pDataBuffer != NULL) ExFreePool(pDataBuffer);

	cmp	QWORD PTR pDataBuffer$[rsp], 0
	je	SHORT $LN3@AddDevice
	xor	edx, edx
	mov	rcx, QWORD PTR pDataBuffer$[rsp]
	call	QWORD PTR __imp_ExFreePoolWithTag
$LN3@AddDevice:

; 685  : 	if (pTargStack != NULL) IoDetachDevice(pTargStack);

	cmp	QWORD PTR pTargStack$[rsp], 0
	je	SHORT $LN2@AddDevice
	mov	rcx, QWORD PTR pTargStack$[rsp]
	call	QWORD PTR __imp_IoDetachDevice
$LN2@AddDevice:

; 686  : 	if (pFilterDev != NULL) IoDeleteDevice (pFilterDev);

	cmp	QWORD PTR pFilterDev$[rsp], 0
	je	SHORT $LN1@AddDevice
	mov	rcx, QWORD PTR pFilterDev$[rsp]
	call	QWORD PTR __imp_IoDeleteDevice
$LN1@AddDevice:

; 687  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 688  : 		"FLT - AddDevice - failed; returning status = %#010x\n", 
; 689  : 		status);

	mov	r9d, DWORD PTR status$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0DF@CEGKGNGA@FLT?5?9?5AddDevice?5?9?5failed?$DL?5return@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 690  : 	return status;

	mov	eax, DWORD PTR status$[rsp]
$LN15@AddDevice:

; 691  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 272				; 00000110H
	pop	rdi
	ret	0
?AddDevice@@YAJPEAU_DRIVER_OBJECT@@PEAU_DEVICE_OBJECT@@@Z ENDP ; AddDevice
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT pdata
pdata	SEGMENT
$pdata$?TraceIrpBasicInfo@@YAXPEAU_DEVICE_EXTENSION@@PEADPEAU_IRP@@@Z DD imagerel ?TraceIrpBasicInfo@@YAXPEAU_DEVICE_EXTENSION@@PEADPEAU_IRP@@@Z
	DD	imagerel ?TraceIrpBasicInfo@@YAXPEAU_DEVICE_EXTENSION@@PEADPEAU_IRP@@@Z+362
	DD	imagerel $unwind$?TraceIrpBasicInfo@@YAXPEAU_DEVICE_EXTENSION@@PEADPEAU_IRP@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?TraceIrpBasicInfo@@YAXPEAU_DEVICE_EXTENSION@@PEADPEAU_IRP@@@Z DD 032919H
	DD	0300117H
	DD	03010H
	DD	imagerel __GSHandlerCheck
	DD	0178H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?TraceIrpBasicInfo@@YAXPEAU_DEVICE_EXTENSION@@PEADPEAU_IRP@@@Z
_TEXT	SEGMENT
szBuf$ = 112
pwszHwID$ = 224
pwszDevText$ = 232
szBufMin$ = 240
pwszInstID$ = 352
pStack$ = 360
pTargInf$ = 368
__$ArrayPad$ = 376
pFltDevExt$ = 400
pszCallingFunction$ = 408
pIrp$ = 416
?TraceIrpBasicInfo@@YAXPEAU_DEVICE_EXTENSION@@PEADPEAU_IRP@@@Z PROC ; TraceIrpBasicInfo, COMDAT

; 3243 : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 384				; 00000180H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 3244 : 	PIO_STACK_LOCATION pStack = 
; 3245 : 		IoGetCurrentIrpStackLocation(pIrp);

	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoGetCurrentIrpStackLocation
	mov	QWORD PTR pStack$[rsp], rax

; 3246 : 	CHAR szBuf[101];
; 3247 : 	CHAR szBufMin[101];
; 3248 : 
; 3249 : 	// Retrieve the device text and IDs
; 3250 : 	//
; 3251 : 	PTARGET_DEVICE_INFO pTargInf = &pFltDevExt->pFADevExt->TargDevInfo;

	mov	rax, QWORD PTR pFltDevExt$[rsp]
	mov	rax, QWORD PTR [rax+264]
	add	rax, 24
	mov	QWORD PTR pTargInf$[rsp], rax

; 3252 : 	PWCHAR pwszDevText = pTargInf->DeviceText;

	mov	rax, QWORD PTR pTargInf$[rsp]
	add	rax, 508				; 000001fcH
	mov	QWORD PTR pwszDevText$[rsp], rax

; 3253 : 	PWCHAR pwszHwID = pTargInf->HardwareIDs;

	mov	rax, QWORD PTR pTargInf$[rsp]
	add	rax, 710				; 000002c6H
	mov	QWORD PTR pwszHwID$[rsp], rax

; 3254 : 	PWCHAR pwszInstID = pTargInf->InstanceId;

	mov	rax, QWORD PTR pTargInf$[rsp]
	add	rax, 912				; 00000390H
	mov	QWORD PTR pwszInstID$[rsp], rax

; 3255 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 3256 : 		"FLT - %s - Tracing IRP %#p\n"
; 3257 : 		"\tMajorFunction = %s\n"
; 3258 : 		"\tMinorFunction = %s\n"
; 3259 : 		"\tFilter %#p\n"
; 3260 : 		"\ttarget text    %S\n"
; 3261 : 		"\ttarget HW ID   %S\n"
; 3262 : 		"\ttarget inst ID %S\n",
; 3263 : 		pszCallingFunction,
; 3264 : 		pIrp,
; 3265 : 		MajorFunctionDes(pStack->MajorFunction, szBuf, 
; 3266 : 			sizeof szBuf), 
; 3267 : 		MinorFunctionDes(pStack->MajorFunction, 
; 3268 : 			pStack->MinorFunction, szBufMin, sizeof szBufMin),
; 3269 : 			pFltDevExt->hdr.pDevice,
; 3270 : 		pwszDevText,
; 3271 : 		pwszHwID,
; 3272 : 		pwszInstID
; 3273 : 		);

	mov	r9d, 101				; 00000065H
	lea	r8, QWORD PTR szBufMin$[rsp]
	mov	rax, QWORD PTR pStack$[rsp]
	movzx	edx, BYTE PTR [rax+1]
	mov	rax, QWORD PTR pStack$[rsp]
	movzx	ecx, BYTE PTR [rax]
	call	?MinorFunctionDes@@YAPEADEEPEAD_K@Z	; MinorFunctionDes
	mov	rbx, rax
	mov	r8d, 101				; 00000065H
	lea	rdx, QWORD PTR szBuf$[rsp]
	mov	rax, QWORD PTR pStack$[rsp]
	movzx	ecx, BYTE PTR [rax]
	call	?MajorFunctionDes@@YAPEADEPEAD_K@Z	; MajorFunctionDes
	mov	r11, rax
	mov	rax, QWORD PTR pwszInstID$[rsp]
	mov	QWORD PTR [rsp+80], rax
	mov	rax, QWORD PTR pwszHwID$[rsp]
	mov	QWORD PTR [rsp+72], rax
	mov	rax, QWORD PTR pwszDevText$[rsp]
	mov	QWORD PTR [rsp+64], rax
	mov	rax, QWORD PTR pFltDevExt$[rsp]
	mov	rax, QWORD PTR [rax+8]
	mov	QWORD PTR [rsp+56], rax
	mov	QWORD PTR [rsp+48], rbx
	mov	QWORD PTR [rsp+40], r11
	mov	rax, QWORD PTR pIrp$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR pszCallingFunction$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0IJ@HMLMAHPH@FLT?5?9?5?$CFs?5?9?5Tracing?5IRP?5?$CF?$CDp?6?7Majo@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 3274 : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 384				; 00000180H
	pop	rbx
	ret	0
?TraceIrpBasicInfo@@YAXPEAU_DEVICE_EXTENSION@@PEADPEAU_IRP@@@Z ENDP ; TraceIrpBasicInfo
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?ReadCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z DD imagerel ?ReadCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z
	DD	imagerel ?ReadCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z+244
	DD	imagerel $unwind$?ReadCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?ReadCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z DD 011301H
	DD	0c213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?ReadCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z
_TEXT	SEGMENT
pDevExt$ = 48
cbReadDataLen$29219 = 56
LockHandle$29220 = 64
pReadData$29218 = 88
pDevObj$ = 112
pIrp$ = 120
pContext$ = 128
?ReadCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z PROC ; ReadCompletion, COMDAT

; 3063 : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 3064 : 	PDEVICE_EXTENSION pDevExt = 
; 3065 : 		(PDEVICE_EXTENSION) pDevObj->DeviceExtension;

	mov	rax, QWORD PTR pDevObj$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR pDevExt$[rsp], rax

; 3066 : 
; 3067 : 	if (pDevExt->dwMJFlags[IRP_MJ_READ] & FCTL_TRACE_ON) {

	mov	rax, QWORD PTR pDevExt$[rsp]
	mov	eax, DWORD PTR [rax+160]
	and	eax, 1
	test	eax, eax
	je	$LN2@ReadComple

; 3068 : 		TraceIrpBasicInfo(pDevExt, "ReadCompletion", pIrp);

	mov	r8, QWORD PTR pIrp$[rsp]
	lea	rdx, OFFSET FLAT:??_C@_0P@HGOAEHOJ@ReadCompletion?$AA@FNODOBFM@
	mov	rcx, QWORD PTR pDevExt$[rsp]
	call	?TraceIrpBasicInfo@@YAXPEAU_DEVICE_EXTENSION@@PEADPEAU_IRP@@@Z ; TraceIrpBasicInfo

; 3069 : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 3070 : 			"\tStatus = %#010x\n"
; 3071 : 			"\tInformation = %#x\n",
; 3072 : 			pIrp->IoStatus.Status,
; 3073 : 			pIrp->IoStatus.Information);

	mov	rax, QWORD PTR pIrp$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR pIrp$[rsp]
	mov	r9d, DWORD PTR [rax+48]
	lea	r8, OFFSET FLAT:??_C@_0CF@GHKHGNKG@?7Status?5?$DN?5?$CF?$CD010x?6?7Information?5?$DN?5@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 3074 : 
; 3075 : 		// Get the IRP data, if any.
; 3076 : 		//
; 3077 : 		PVOID pReadData;
; 3078 : 		SIZE_T cbReadDataLen;
; 3079 : 		GetReadData(pIrp, pDevExt, &pReadData, &cbReadDataLen);

	lea	r9, QWORD PTR cbReadDataLen$29219[rsp]
	lea	r8, QWORD PTR pReadData$29218[rsp]
	mov	rdx, QWORD PTR pDevExt$[rsp]
	mov	rcx, QWORD PTR pIrp$[rsp]
	call	?GetReadData@@YAXPEAU_IRP@@PEAU_DEVICE_EXTENSION@@PEAPEAXPEA_K@Z ; GetReadData

; 3080 : 
; 3081 : 		KLOCK_QUEUE_HANDLE	LockHandle;
; 3082 : 		KeAcquireInStackQueuedSpinLock(
; 3083 : 			&pDevExt->DataLock,
; 3084 : 			&LockHandle);

	mov	rcx, QWORD PTR pDevExt$[rsp]
	add	rcx, 136				; 00000088H
	lea	rdx, QWORD PTR LockHandle$29220[rsp]
	call	QWORD PTR __imp_KeAcquireInStackQueuedSpinLock

; 3085 : 		InterceptIrpAndData(pIrp, pReadData, cbReadDataLen, pDevExt);

	mov	r9, QWORD PTR pDevExt$[rsp]
	mov	r8, QWORD PTR cbReadDataLen$29219[rsp]
	mov	rdx, QWORD PTR pReadData$29218[rsp]
	mov	rcx, QWORD PTR pIrp$[rsp]
	call	?InterceptIrpAndData@@YAXPEAU_IRP@@PEAX_KPEAU_DEVICE_EXTENSION@@@Z ; InterceptIrpAndData

; 3086 : 		SendIrpDataToClt(pDevExt);

	mov	rcx, QWORD PTR pDevExt$[rsp]
	call	?SendIrpDataToClt@@YAXPEAU_DEVICE_EXTENSION@@@Z ; SendIrpDataToClt

; 3087 : 		KeReleaseInStackQueuedSpinLock(&LockHandle);

	lea	rcx, QWORD PTR LockHandle$29220[rsp]
	call	QWORD PTR __imp_KeReleaseInStackQueuedSpinLock
$LN2@ReadComple:

; 3088 : 	}
; 3089 : 
; 3090 : 	if (pIrp->PendingReturned) IoMarkIrpPending(pIrp);

	mov	rax, QWORD PTR pIrp$[rsp]
	movzx	eax, BYTE PTR [rax+65]
	test	eax, eax
	je	SHORT $LN1@ReadComple
	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoMarkIrpPending
$LN1@ReadComple:

; 3091 : 	return STATUS_SUCCESS;

	xor	eax, eax

; 3092 : }

	add	rsp, 104				; 00000068H
	ret	0
?ReadCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z ENDP ; ReadCompletion
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MAMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD imagerel ?MAMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
	DD	imagerel ?MAMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z+299
	DD	imagerel $unwind$?MAMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MAMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?MAMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
_TEXT	SEGMENT
pStack$ = 48
status$ = 56
tv67 = 60
pDevObj$ = 80
pIrp$ = 88
?MAMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z PROC ; MAMainDispatch, COMDAT

; 2681 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2682 : 	NTSTATUS status;
; 2683 : 	PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoGetCurrentIrpStackLocation
	mov	QWORD PTR pStack$[rsp], rax

; 2684 : 	switch (pStack->MajorFunction) {

	mov	rax, QWORD PTR pStack$[rsp]
	mov	al, BYTE PTR [rax]
	mov	BYTE PTR tv67[rsp], al
	cmp	BYTE PTR tv67[rsp], 0
	je	SHORT $LN4@MAMainDisp
	cmp	BYTE PTR tv67[rsp], 2
	je	SHORT $LN5@MAMainDisp
	cmp	BYTE PTR tv67[rsp], 3
	je	SHORT $LN3@MAMainDisp
	cmp	BYTE PTR tv67[rsp], 18
	je	SHORT $LN6@MAMainDisp
	jmp	SHORT $LN2@MAMainDisp
$LN6@MAMainDisp:

; 2685 : 		case IRP_MJ_CLEANUP:
; 2686 : 			status = STATUS_SUCCESS;

	mov	DWORD PTR status$[rsp], 0

; 2687 : 			pIrp->IoStatus.Information = 0;

	mov	rax, QWORD PTR pIrp$[rsp]
	mov	QWORD PTR [rax+56], 0

; 2688 : 			pIrp->IoStatus.Status = status;

	mov	rcx, QWORD PTR pIrp$[rsp]
	mov	eax, DWORD PTR status$[rsp]
	mov	DWORD PTR [rcx+48], eax

; 2689 : 			break;

	jmp	SHORT $LN7@MAMainDisp
$LN5@MAMainDisp:

; 2690 : 		case IRP_MJ_CLOSE:
; 2691 : 			status = STATUS_SUCCESS;

	mov	DWORD PTR status$[rsp], 0

; 2692 : 			pIrp->IoStatus.Information = 0;

	mov	rax, QWORD PTR pIrp$[rsp]
	mov	QWORD PTR [rax+56], 0

; 2693 : 			pIrp->IoStatus.Status = status;

	mov	rcx, QWORD PTR pIrp$[rsp]
	mov	eax, DWORD PTR status$[rsp]
	mov	DWORD PTR [rcx+48], eax

; 2694 : 			break;

	jmp	SHORT $LN7@MAMainDisp
$LN4@MAMainDisp:

; 2695 : 		case IRP_MJ_CREATE:
; 2696 : 			status = STATUS_SUCCESS;

	mov	DWORD PTR status$[rsp], 0

; 2697 : 			pIrp->IoStatus.Information = 0;

	mov	rax, QWORD PTR pIrp$[rsp]
	mov	QWORD PTR [rax+56], 0

; 2698 : 			pIrp->IoStatus.Status = status;

	mov	rcx, QWORD PTR pIrp$[rsp]
	mov	eax, DWORD PTR status$[rsp]
	mov	DWORD PTR [rcx+48], eax

; 2699 : 			break;

	jmp	SHORT $LN7@MAMainDisp
$LN3@MAMainDisp:

; 2700 : 		case IRP_MJ_READ:
; 2701 : 			status = MADispatchRead(pDevObj, pIrp);

	mov	rdx, QWORD PTR pIrp$[rsp]
	mov	rcx, QWORD PTR pDevObj$[rsp]
	call	?MADispatchRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ; MADispatchRead
	mov	DWORD PTR status$[rsp], eax

; 2702 : 			break;

	jmp	SHORT $LN7@MAMainDisp
$LN2@MAMainDisp:

; 2703 : 		default:
; 2704 : 			status = STATUS_NOT_SUPPORTED;

	mov	DWORD PTR status$[rsp], -1073741637	; ffffffffc00000bbH

; 2705 : 			pIrp->IoStatus.Information = 0;

	mov	rax, QWORD PTR pIrp$[rsp]
	mov	QWORD PTR [rax+56], 0

; 2706 : 			pIrp->IoStatus.Status = status;

	mov	rcx, QWORD PTR pIrp$[rsp]
	mov	eax, DWORD PTR status$[rsp]
	mov	DWORD PTR [rcx+48], eax
$LN7@MAMainDisp:

; 2707 : 	}
; 2708 : 	if (status != STATUS_PENDING) {

	cmp	DWORD PTR status$[rsp], 259		; 00000103H
	je	SHORT $LN1@MAMainDisp

; 2709 : 		IoCompleteRequest(
; 2710 : 			pIrp, IO_NO_INCREMENT);

	xor	edx, edx
	mov	rcx, QWORD PTR pIrp$[rsp]
	call	QWORD PTR __imp_IofCompleteRequest

; 2711 : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 2712 : 			"FLT - MAMainDispatch - Client IRP %#p completed with "
; 2713 : 			"status %#010x\n", 
; 2714 : 			pIrp,
; 2715 : 			pIrp->IoStatus.Status);

	mov	r11, QWORD PTR pIrp$[rsp]
	mov	eax, DWORD PTR [r11+48]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR pIrp$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0EE@FCHCFMEI@FLT?5?9?5MAMainDispatch?5?9?5Client?5IR@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx
$LN1@MAMainDisp:

; 2716 : 	}
; 2717 : 	return status;

	mov	eax, DWORD PTR status$[rsp]

; 2718 : }

	add	rsp, 72					; 00000048H
	ret	0
?MAMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ENDP ; MAMainDispatch
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GTCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z DD imagerel ?GTCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z
	DD	imagerel ?GTCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z+239
	DD	imagerel $unwind$?GTCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GTCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z DD 011301H
	DD	0c213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?GTCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z
_TEXT	SEGMENT
pStack$ = 48
MajFun$ = 56
pDevExt$ = 64
klock$ = 72
pDevObj$ = 112
pIrp$ = 120
Context$ = 128
?GTCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z PROC ; GTCompletion, COMDAT

; 2238 : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 2239 : 	PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoGetCurrentIrpStackLocation
	mov	QWORD PTR pStack$[rsp], rax

; 2240 : 	UCHAR MajFun = pStack->MajorFunction;

	mov	rax, QWORD PTR pStack$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR MajFun$[rsp], al

; 2241 : 	PDEVICE_EXTENSION pDevExt = 
; 2242 : 		(PDEVICE_EXTENSION) Context;

	mov	rax, QWORD PTR Context$[rsp]
	mov	QWORD PTR pDevExt$[rsp], rax

; 2243 : 	TraceIrpBasicInfo(pDevExt, "GTCompletion", pIrp);

	mov	r8, QWORD PTR pIrp$[rsp]
	lea	rdx, OFFSET FLAT:??_C@_0N@IHJEBEEH@GTCompletion?$AA@FNODOBFM@
	mov	rcx, QWORD PTR pDevExt$[rsp]
	call	?TraceIrpBasicInfo@@YAXPEAU_DEVICE_EXTENSION@@PEADPEAU_IRP@@@Z ; TraceIrpBasicInfo

; 2244 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 2245 : 		"\tStatus = %#010x\n"
; 2246 : 		"\tInformation = %#x\n",
; 2247 : 		pIrp->IoStatus.Status,
; 2248 : 		pIrp->IoStatus.Information);

	mov	rax, QWORD PTR pIrp$[rsp]
	mov	rax, QWORD PTR [rax+56]
	mov	QWORD PTR [rsp+32], rax
	mov	rax, QWORD PTR pIrp$[rsp]
	mov	r9d, DWORD PTR [rax+48]
	lea	r8, OFFSET FLAT:??_C@_0CF@GHKHGNKG@?7Status?5?$DN?5?$CF?$CD010x?6?7Information?5?$DN?5@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 2249 : 
; 2250 : 	KLOCK_QUEUE_HANDLE klock;
; 2251 : 
; 2252 : 	KeAcquireInStackQueuedSpinLock(&pDevExt->DataLock, &klock);

	mov	rcx, QWORD PTR pDevExt$[rsp]
	add	rcx, 136				; 00000088H
	lea	rdx, QWORD PTR klock$[rsp]
	call	QWORD PTR __imp_KeAcquireInStackQueuedSpinLock

; 2253 : 
; 2254 : 	InterceptIrpAndData(pIrp, NULL, 0, pDevExt);

	mov	r9, QWORD PTR pDevExt$[rsp]
	xor	r8d, r8d
	xor	edx, edx
	mov	rcx, QWORD PTR pIrp$[rsp]
	call	?InterceptIrpAndData@@YAXPEAU_IRP@@PEAX_KPEAU_DEVICE_EXTENSION@@@Z ; InterceptIrpAndData

; 2255 : 	SendIrpDataToClt(pDevExt);

	mov	rcx, QWORD PTR pDevExt$[rsp]
	call	?SendIrpDataToClt@@YAXPEAU_DEVICE_EXTENSION@@@Z ; SendIrpDataToClt

; 2256 : 
; 2257 : 	KeReleaseInStackQueuedSpinLock(&klock);

	lea	rcx, QWORD PTR klock$[rsp]
	call	QWORD PTR __imp_KeReleaseInStackQueuedSpinLock

; 2258 : 
; 2259 : 	if (MajFun == IRP_MJ_POWER) PoStartNextPowerIrp(pIrp);

	movzx	eax, BYTE PTR MajFun$[rsp]
	cmp	eax, 22
	jne	SHORT $LN2@GTCompleti
	mov	rcx, QWORD PTR pIrp$[rsp]
	call	QWORD PTR __imp_PoStartNextPowerIrp
$LN2@GTCompleti:

; 2260 : 	if (pIrp->PendingReturned) IoMarkIrpPending(pIrp);

	mov	rax, QWORD PTR pIrp$[rsp]
	movzx	eax, BYTE PTR [rax+65]
	test	eax, eax
	je	SHORT $LN1@GTCompleti
	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoMarkIrpPending
$LN1@GTCompleti:

; 2261 : 	return STATUS_SUCCESS;

	xor	eax, eax

; 2262 : }

	add	rsp, 104				; 00000068H
	ret	0
?GTCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z ENDP ; GTCompletion
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?GenericTrace@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD imagerel ?GenericTrace@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
	DD	imagerel ?GenericTrace@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z+289
	DD	imagerel $unwind$?GenericTrace@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?GenericTrace@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD 010e01H
	DD	0a20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?GenericTrace@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
_TEXT	SEGMENT
pStack$ = 48
status$ = 56
MajFun$ = 60
pDevExt$ = 64
pDevObj$ = 96
pIrp$ = 104
?GenericTrace@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z PROC	; GenericTrace, COMDAT

; 1720 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 88					; 00000058H

; 1721 : 	PDEVICE_EXTENSION pDevExt = 
; 1722 : 		(PDEVICE_EXTENSION) pDevObj->DeviceExtension;

	mov	rax, QWORD PTR pDevObj$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR pDevExt$[rsp], rax

; 1723 : 	PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoGetCurrentIrpStackLocation
	mov	QWORD PTR pStack$[rsp], rax

; 1724 : 	UCHAR MajFun = pStack->MajorFunction;

	mov	rax, QWORD PTR pStack$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR MajFun$[rsp], al

; 1725 : 	NTSTATUS status = STATUS_UNSUCCESSFUL;

	mov	DWORD PTR status$[rsp], -1073741823	; ffffffffc0000001H

; 1726 : 	if (MajFun <= IRP_MJ_MAXIMUM_FUNCTION) { //One never knows...

	movzx	eax, BYTE PTR MajFun$[rsp]
	cmp	eax, 27
	jg	$LN6@GenericTra

; 1727 : 		if ((pDevExt->dwMJFlags[MajFun]) & FCTL_TRACE_ON) {

	movzx	ecx, BYTE PTR MajFun$[rsp]
	mov	rax, QWORD PTR pDevExt$[rsp]
	mov	eax, DWORD PTR [rax+rcx*4+148]
	and	eax, 1
	test	eax, eax
	je	$LN5@GenericTra

; 1728 : 			TraceIrpBasicInfo(pDevExt, "GenericTrace", pIrp);

	mov	r8, QWORD PTR pIrp$[rsp]
	lea	rdx, OFFSET FLAT:??_C@_0N@NLMLMCJE@GenericTrace?$AA@FNODOBFM@
	mov	rcx, QWORD PTR pDevExt$[rsp]
	call	?TraceIrpBasicInfo@@YAXPEAU_DEVICE_EXTENSION@@PEADPEAU_IRP@@@Z ; TraceIrpBasicInfo

; 1729 : 
; 1730 : 			// Set the completion
; 1731 : 			// routine, which will track the IRP.
; 1732 : 			//
; 1733 : 			IoCopyCurrentIrpStackLocationToNext(pIrp);

	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoCopyCurrentIrpStackLocationToNext

; 1734 : 			IoSetCompletionRoutine(pIrp, GTCompletion, pDevExt, TRUE, 
; 1735 : 				TRUE, TRUE);

	mov	BYTE PTR [rsp+40], 1
	mov	BYTE PTR [rsp+32], 1
	mov	r9b, 1
	mov	r8, QWORD PTR pDevExt$[rsp]
	lea	rdx, OFFSET FLAT:?GTCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z ; GTCompletion
	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoSetCompletionRoutine

; 1736 : 			if (MajFun == IRP_MJ_POWER) {

	movzx	eax, BYTE PTR MajFun$[rsp]
	cmp	eax, 22
	jne	SHORT $LN4@GenericTra

; 1737 : 				status = PoCallDriver(pDevExt->pTargStack, pIrp);

	mov	rdx, QWORD PTR pIrp$[rsp]
	mov	rcx, QWORD PTR pDevExt$[rsp]
	mov	rcx, QWORD PTR [rcx+288]
	call	QWORD PTR __imp_PoCallDriver
	mov	DWORD PTR status$[rsp], eax

; 1738 : 			} else {

	jmp	SHORT $LN3@GenericTra
$LN4@GenericTra:

; 1739 : 				status = IoCallDriver(pDevExt->pTargStack, pIrp);

	mov	rdx, QWORD PTR pIrp$[rsp]
	mov	rcx, QWORD PTR pDevExt$[rsp]
	mov	rcx, QWORD PTR [rcx+288]
	call	QWORD PTR __imp_IofCallDriver
	mov	DWORD PTR status$[rsp], eax
$LN3@GenericTra:

; 1740 : 			}
; 1741 : 		} else {

	jmp	SHORT $LN2@GenericTra
$LN5@GenericTra:

; 1742 : 
; 1743 : 			// Tracing is off. Just forward the IRP.
; 1744 : 			//
; 1745 : 			status = ForwardIrpOrPIrp(pDevObj, pIrp);

	mov	rdx, QWORD PTR pIrp$[rsp]
	mov	rcx, QWORD PTR pDevObj$[rsp]
	call	?ForwardIrpOrPIrp@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ; ForwardIrpOrPIrp
	mov	DWORD PTR status$[rsp], eax
$LN2@GenericTra:

; 1746 : 		}
; 1747 : 	} else {

	jmp	SHORT $LN1@GenericTra
$LN6@GenericTra:

; 1748 : 		status = ForwardIrpOrPIrp(pDevObj, pIrp);

	mov	rdx, QWORD PTR pIrp$[rsp]
	mov	rcx, QWORD PTR pDevObj$[rsp]
	call	?ForwardIrpOrPIrp@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ; ForwardIrpOrPIrp
	mov	DWORD PTR status$[rsp], eax
$LN1@GenericTra:

; 1749 : 
; 1750 : 	}
; 1751 : 	return status;

	mov	eax, DWORD PTR status$[rsp]

; 1752 : }

	add	rsp, 88					; 00000058H
	ret	0
?GenericTrace@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ENDP	; GenericTrace
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FAMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD imagerel ?FAMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
	DD	imagerel ?FAMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z+351
	DD	imagerel $unwind$?FAMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FAMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?FAMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
_TEXT	SEGMENT
pStack$ = 48
status$ = 56
tv67 = 60
pDevObj$ = 80
pIrp$ = 88
?FAMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z PROC ; FAMainDispatch, COMDAT

; 1558 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1559 : 	NTSTATUS status;
; 1560 : 	PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoGetCurrentIrpStackLocation
	mov	QWORD PTR pStack$[rsp], rax

; 1561 : 	switch (pStack->MajorFunction) {

	mov	rax, QWORD PTR pStack$[rsp]
	mov	al, BYTE PTR [rax]
	mov	BYTE PTR tv67[rsp], al
	cmp	BYTE PTR tv67[rsp], 0
	je	SHORT $LN5@FAMainDisp
	cmp	BYTE PTR tv67[rsp], 2
	je	SHORT $LN6@FAMainDisp
	cmp	BYTE PTR tv67[rsp], 3
	je	$LN3@FAMainDisp
	cmp	BYTE PTR tv67[rsp], 14
	je	SHORT $LN4@FAMainDisp
	cmp	BYTE PTR tv67[rsp], 18
	je	SHORT $LN7@FAMainDisp
	jmp	$LN2@FAMainDisp
$LN7@FAMainDisp:

; 1562 : 		case IRP_MJ_CLEANUP:
; 1563 : 			status = STATUS_SUCCESS;

	mov	DWORD PTR status$[rsp], 0

; 1564 : 			pIrp->IoStatus.Information = 0;

	mov	rax, QWORD PTR pIrp$[rsp]
	mov	QWORD PTR [rax+56], 0

; 1565 : 			pIrp->IoStatus.Status = status;

	mov	rcx, QWORD PTR pIrp$[rsp]
	mov	eax, DWORD PTR status$[rsp]
	mov	DWORD PTR [rcx+48], eax

; 1566 : 			break;

	jmp	$LN8@FAMainDisp
$LN6@FAMainDisp:

; 1567 : 		case IRP_MJ_CLOSE:
; 1568 : 			status = STATUS_SUCCESS;

	mov	DWORD PTR status$[rsp], 0

; 1569 : 			pIrp->IoStatus.Information = 0;

	mov	rax, QWORD PTR pIrp$[rsp]
	mov	QWORD PTR [rax+56], 0

; 1570 : 			pIrp->IoStatus.Status = status;

	mov	rcx, QWORD PTR pIrp$[rsp]
	mov	eax, DWORD PTR status$[rsp]
	mov	DWORD PTR [rcx+48], eax

; 1571 : 			break;

	jmp	SHORT $LN8@FAMainDisp
$LN5@FAMainDisp:

; 1572 : 		case IRP_MJ_CREATE:
; 1573 : 			status = STATUS_SUCCESS;

	mov	DWORD PTR status$[rsp], 0

; 1574 : 			pIrp->IoStatus.Information = 0;

	mov	rax, QWORD PTR pIrp$[rsp]
	mov	QWORD PTR [rax+56], 0

; 1575 : 			pIrp->IoStatus.Status = status;

	mov	rcx, QWORD PTR pIrp$[rsp]
	mov	eax, DWORD PTR status$[rsp]
	mov	DWORD PTR [rcx+48], eax

; 1576 : 			break;

	jmp	SHORT $LN8@FAMainDisp
$LN4@FAMainDisp:

; 1577 : 		case IRP_MJ_DEVICE_CONTROL:
; 1578 : 			status = FADispatchIoctl(pDevObj, pIrp);

	mov	rdx, QWORD PTR pIrp$[rsp]
	mov	rcx, QWORD PTR pDevObj$[rsp]
	call	?FADispatchIoctl@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ; FADispatchIoctl
	mov	DWORD PTR status$[rsp], eax

; 1579 : 			break;

	jmp	SHORT $LN8@FAMainDisp
$LN3@FAMainDisp:

; 1580 : 		case IRP_MJ_READ:
; 1581 : 			status = FADispatchRead(pDevObj, pIrp);

	mov	rdx, QWORD PTR pIrp$[rsp]
	mov	rcx, QWORD PTR pDevObj$[rsp]
	call	?FADispatchRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ; FADispatchRead
	mov	DWORD PTR status$[rsp], eax

; 1582 : 			break;

	jmp	SHORT $LN8@FAMainDisp
$LN2@FAMainDisp:

; 1583 : 		default:
; 1584 : 			status = STATUS_NOT_SUPPORTED;

	mov	DWORD PTR status$[rsp], -1073741637	; ffffffffc00000bbH

; 1585 : 			pIrp->IoStatus.Information = 0;

	mov	rax, QWORD PTR pIrp$[rsp]
	mov	QWORD PTR [rax+56], 0

; 1586 : 			pIrp->IoStatus.Status = status;

	mov	rcx, QWORD PTR pIrp$[rsp]
	mov	eax, DWORD PTR status$[rsp]
	mov	DWORD PTR [rcx+48], eax
$LN8@FAMainDisp:

; 1587 : 	}
; 1588 : 	if (status != STATUS_PENDING) {

	cmp	DWORD PTR status$[rsp], 259		; 00000103H
	je	SHORT $LN1@FAMainDisp

; 1589 : 
; 1590 : 		// This should not be necessary. Code paths which set a cancel
; 1591 : 		// routine either return STATUS_PENDING or remove the cancel 
; 1592 : 		// routine by themselves. We do it in case we forgot something.
; 1593 : 		//
; 1594 : 		IoSetCancelRoutine(pIrp, NULL);

	mov	rax, QWORD PTR pIrp$[rsp]
	add	rax, 104				; 00000068H
	xor	ecx, ecx
	xchg	QWORD PTR [rax], rcx

; 1595 : 		IoCompleteRequest(
; 1596 : 			pIrp, IO_NO_INCREMENT);

	xor	edx, edx
	mov	rcx, QWORD PTR pIrp$[rsp]
	call	QWORD PTR __imp_IofCompleteRequest

; 1597 : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1598 : 			"FLT - FAMainDispatch - Client IRP %#p completed with "
; 1599 : 			"status %#010x\n", 
; 1600 : 			pIrp,
; 1601 : 			pIrp->IoStatus.Status);

	mov	r11, QWORD PTR pIrp$[rsp]
	mov	eax, DWORD PTR [r11+48]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR pIrp$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0EE@ODKHGKNO@FLT?5?9?5FAMainDispatch?5?9?5Client?5IR@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx
$LN1@FAMainDisp:

; 1602 : 	}
; 1603 : 	return status;

	mov	eax, DWORD PTR status$[rsp]

; 1604 : }

	add	rsp, 72					; 00000048H
	ret	0
?FAMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ENDP ; FAMainDispatch
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DispatchFilteredWrite@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD imagerel ?DispatchFilteredWrite@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
	DD	imagerel ?DispatchFilteredWrite@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z+248
	DD	imagerel $unwind$?DispatchFilteredWrite@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DispatchFilteredWrite@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD 010e01H
	DD	0c20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?DispatchFilteredWrite@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
_TEXT	SEGMENT
pDevExt$ = 32
cbDataLen$28713 = 40
pStack$28709 = 48
LockHandle$28714 = 56
pWriteData$28712 = 80
pDevObj$ = 112
pIrp$ = 120
?DispatchFilteredWrite@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z PROC ; DispatchFilteredWrite, COMDAT

; 1267 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 1268 : 	PDEVICE_EXTENSION pDevExt = 
; 1269 : 		(PDEVICE_EXTENSION) pDevObj->DeviceExtension;

	mov	rax, QWORD PTR pDevObj$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR pDevExt$[rsp], rax

; 1270 : 	if (pDevExt->dwMJFlags[IRP_MJ_WRITE] & FCTL_TRACE_ON) {

	mov	rax, QWORD PTR pDevExt$[rsp]
	mov	eax, DWORD PTR [rax+164]
	and	eax, 1
	test	eax, eax
	je	$LN1@DispatchFi

; 1271 : 		PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoGetCurrentIrpStackLocation
	mov	QWORD PTR pStack$28709[rsp], rax

; 1272 : 		TraceIrpBasicInfo(pDevExt, "DispatchFilteredWrite", pIrp);

	mov	r8, QWORD PTR pIrp$[rsp]
	lea	rdx, OFFSET FLAT:??_C@_0BG@EAJEGOIB@DispatchFilteredWrite?$AA@FNODOBFM@
	mov	rcx, QWORD PTR pDevExt$[rsp]
	call	?TraceIrpBasicInfo@@YAXPEAU_DEVICE_EXTENSION@@PEADPEAU_IRP@@@Z ; TraceIrpBasicInfo

; 1273 : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1274 : 			"\tdata length = %#x\n", 
; 1275 : 			pStack->Parameters.Write.Length);

	mov	r11, QWORD PTR pStack$28709[rsp]
	mov	r9d, DWORD PTR [r11+8]
	lea	r8, OFFSET FLAT:??_C@_0BE@LDBPDEFD@?7data?5length?5?$DN?5?$CF?$CDx?6?$AA@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 1276 : 
; 1277 : 		// Get the IRP data, if any.
; 1278 : 		//
; 1279 : 		PVOID pWriteData;
; 1280 : 		SIZE_T cbDataLen;
; 1281 : 		GetWriteData(pIrp, pDevExt, &pWriteData, &cbDataLen);

	lea	r9, QWORD PTR cbDataLen$28713[rsp]
	lea	r8, QWORD PTR pWriteData$28712[rsp]
	mov	rdx, QWORD PTR pDevExt$[rsp]
	mov	rcx, QWORD PTR pIrp$[rsp]
	call	?GetWriteData@@YAXPEAU_IRP@@PEAU_DEVICE_EXTENSION@@PEAPEAXPEA_K@Z ; GetWriteData

; 1282 : 		KLOCK_QUEUE_HANDLE LockHandle;
; 1283 : 		KeAcquireInStackQueuedSpinLock(
; 1284 : 			&pDevExt->DataLock,
; 1285 : 			&LockHandle);

	mov	rcx, QWORD PTR pDevExt$[rsp]
	add	rcx, 136				; 00000088H
	lea	rdx, QWORD PTR LockHandle$28714[rsp]
	call	QWORD PTR __imp_KeAcquireInStackQueuedSpinLock

; 1286 : 		InterceptIrpAndData(pIrp, pWriteData, cbDataLen, pDevExt);

	mov	r9, QWORD PTR pDevExt$[rsp]
	mov	r8, QWORD PTR cbDataLen$28713[rsp]
	mov	rdx, QWORD PTR pWriteData$28712[rsp]
	mov	rcx, QWORD PTR pIrp$[rsp]
	call	?InterceptIrpAndData@@YAXPEAU_IRP@@PEAX_KPEAU_DEVICE_EXTENSION@@@Z ; InterceptIrpAndData

; 1287 : 		SendIrpDataToClt(pDevExt);

	mov	rcx, QWORD PTR pDevExt$[rsp]
	call	?SendIrpDataToClt@@YAXPEAU_DEVICE_EXTENSION@@@Z ; SendIrpDataToClt

; 1288 : 		KeReleaseInStackQueuedSpinLock(&LockHandle);

	lea	rcx, QWORD PTR LockHandle$28714[rsp]
	call	QWORD PTR __imp_KeReleaseInStackQueuedSpinLock
$LN1@DispatchFi:

; 1289 : 
; 1290 : 	}
; 1291 : 	IoSkipCurrentIrpStackLocation(pIrp);

	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoSkipCurrentIrpStackLocation

; 1292 : 	return IoCallDriver(pDevExt->pTargStack, pIrp);

	mov	rdx, QWORD PTR pIrp$[rsp]
	mov	rcx, QWORD PTR pDevExt$[rsp]
	mov	rcx, QWORD PTR [rcx+288]
	call	QWORD PTR __imp_IofCallDriver

; 1293 : 
; 1294 : 
; 1295 : 
; 1296 : }

	add	rsp, 104				; 00000068H
	ret	0
?DispatchFilteredWrite@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ENDP ; DispatchFilteredWrite
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?DispatchFilteredRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD imagerel ?DispatchFilteredRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
	DD	imagerel ?DispatchFilteredRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z+196
	DD	imagerel $unwind$?DispatchFilteredRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?DispatchFilteredRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?DispatchFilteredRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
_TEXT	SEGMENT
pDevExt$ = 48
pIrpStack$28699 = 56
pDevObj$ = 80
pIrp$ = 88
?DispatchFilteredRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z PROC ; DispatchFilteredRead, COMDAT

; 1218 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1219 : 	PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION) pDevObj->DeviceExtension;

	mov	rax, QWORD PTR pDevObj$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR pDevExt$[rsp], rax

; 1220 : 	if (pDevExt->dwMJFlags[IRP_MJ_READ] & FCTL_TRACE_ON) {

	mov	rax, QWORD PTR pDevExt$[rsp]
	mov	eax, DWORD PTR [rax+160]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN1@DispatchFi@2

; 1221 : 		PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoGetCurrentIrpStackLocation
	mov	QWORD PTR pIrpStack$28699[rsp], rax

; 1222 : 		TraceIrpBasicInfo(pDevExt, "DispatchFilteredRead", pIrp);

	mov	r8, QWORD PTR pIrp$[rsp]
	lea	rdx, OFFSET FLAT:??_C@_0BF@DHECNBIC@DispatchFilteredRead?$AA@FNODOBFM@
	mov	rcx, QWORD PTR pDevExt$[rsp]
	call	?TraceIrpBasicInfo@@YAXPEAU_DEVICE_EXTENSION@@PEADPEAU_IRP@@@Z ; TraceIrpBasicInfo

; 1223 : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1224 : 			"\toffset = %#I64x\n"
; 1225 : 			"\tlength = %#x\n",
; 1226 : 			pIrpStack->Parameters.Read.ByteOffset.QuadPart,
; 1227 : 			pIrpStack->Parameters.Read.Length
; 1228 : 		);

	mov	r11, QWORD PTR pIrpStack$28699[rsp]
	mov	eax, DWORD PTR [r11+8]
	mov	DWORD PTR [rsp+32], eax
	mov	r9, QWORD PTR pIrpStack$28699[rsp]
	mov	r9, QWORD PTR [r9+24]
	lea	r8, OFFSET FLAT:??_C@_0CA@HIAJLNEM@?7offset?5?$DN?5?$CF?$CDI64x?6?7length?5?$DN?5?$CF?$CDx?6?$AA@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx
$LN1@DispatchFi@2:

; 1229 : 	}
; 1230 : 
; 1231 : 	IoCopyCurrentIrpStackLocationToNext(pIrp);

	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoCopyCurrentIrpStackLocationToNext

; 1232 : 
; 1233 : 	// Set the completion routine which will intercept the read data.
; 1234 : 	//
; 1235 : 	IoSetCompletionRoutine(pIrp, ReadCompletion, NULL, TRUE, TRUE, TRUE);

	mov	BYTE PTR [rsp+40], 1
	mov	BYTE PTR [rsp+32], 1
	mov	r9b, 1
	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:?ReadCompletion@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@PEAX@Z ; ReadCompletion
	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoSetCompletionRoutine

; 1236 : 	return IoCallDriver(
; 1237 : 		pDevExt->pTargStack,
; 1238 : 		pIrp );

	mov	rdx, QWORD PTR pIrp$[rsp]
	mov	rcx, QWORD PTR pDevExt$[rsp]
	mov	rcx, QWORD PTR [rcx+288]
	call	QWORD PTR __imp_IofCallDriver

; 1239 : }

	add	rsp, 72					; 00000048H
	ret	0
?DispatchFilteredRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ENDP ; DispatchFilteredRead
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CreateMainDevice@@YAJPEAU_DRIVER_OBJECT@@@Z DD imagerel ?CreateMainDevice@@YAJPEAU_DRIVER_OBJECT@@@Z
	DD	imagerel ?CreateMainDevice@@YAJPEAU_DRIVER_OBJECT@@@Z+250
	DD	imagerel $unwind$?CreateMainDevice@@YAJPEAU_DRIVER_OBJECT@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CreateMainDevice@@YAJPEAU_DRIVER_OBJECT@@@Z DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?CreateMainDevice@@YAJPEAU_DRIVER_OBJECT@@@Z
_TEXT	SEGMENT
pMastDevObj$ = 48
status$ = 56
pDriverObject$ = 80
?CreateMainDevice@@YAJPEAU_DRIVER_OBJECT@@@Z PROC	; CreateMainDevice, COMDAT

; 1056 : {

	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1057 : 	NTSTATUS status;
; 1058 : 
; 1059 : 	PDEVICE_OBJECT pMastDevObj;
; 1060 : 	status = CreateDevice(
; 1061 : 		pDriverObject,
; 1062 : 		MASTER_DEVICE_NAME,
; 1063 : 		sizeof (MADEVICE_EXTENSION),
; 1064 : 		&pMastDevObj,
; 1065 : 		-1,
; 1066 : 		NULL);

	mov	QWORD PTR [rsp+40], 0
	mov	DWORD PTR [rsp+32], -1
	lea	r9, QWORD PTR pMastDevObj$[rsp]
	mov	r8d, 48					; 00000030H
	lea	rdx, OFFSET FLAT:??_C@_1CG@DPMCLGJD@?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAM?$AAa?$AAs?$AAt?$AAe?$AAr?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@
	mov	rcx, QWORD PTR pDriverObject$[rsp]
	call	?CreateDevice@@YAJPEAU_DRIVER_OBJECT@@PEAGKPEAPEAU_DEVICE_OBJECT@@J1@Z ; CreateDevice
	mov	DWORD PTR status$[rsp], eax

; 1067 : 	if (!NT_SUCCESS(status)) {

	cmp	DWORD PTR status$[rsp], 0
	jge	SHORT $LN1@CreateMain

; 1068 : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1069 : 			"FLT - Failed to create the master device.\n"); 

	lea	r8, OFFSET FLAT:??_C@_0CL@JPBGFCLD@FLT?5?9?5Failed?5to?5create?5the?5maste@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 1070 : 		return status;

	mov	eax, DWORD PTR status$[rsp]
	jmp	$LN2@CreateMain
$LN1@CreateMain:

; 1071 : 	}
; 1072 : 	pMastDevExt = (PMADEVICE_EXTENSION) pMastDevObj->DeviceExtension;

	mov	rax, QWORD PTR pMastDevObj$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR pMastDevExt, rax

; 1073 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1074 : 		"FLT - Master device created. Device object: %#p, device "
; 1075 : 		"extension: %#x\n",
; 1076 : 		pMastDevObj,
; 1077 : 		pMastDevExt);

	mov	rax, QWORD PTR pMastDevExt
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR pMastDevObj$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0EI@HJAINLCB@FLT?5?9?5Master?5device?5created?4?5Dev@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 1078 : 	pMastDevObj->Flags |= DO_DIRECT_IO;

	mov	r11, QWORD PTR pMastDevObj$[rsp]
	mov	ecx, DWORD PTR [r11+48]
	or	ecx, 16
	mov	rax, QWORD PTR pMastDevObj$[rsp]
	mov	DWORD PTR [rax+48], ecx

; 1079 : 	pMastDevExt->hdr.pDevice = pMastDevObj;

	mov	rcx, QWORD PTR pMastDevExt
	mov	rax, QWORD PTR pMastDevObj$[rsp]
	mov	QWORD PTR [rcx+8], rax

; 1080 : 	pMastDevExt->hdr.DevType = DT_MASTER;

	mov	rax, QWORD PTR pMastDevExt
	mov	DWORD PTR [rax], 0

; 1081 : 	KeInitializeSpinLock(
; 1082 : 		&pMastDevExt->SyncLock);

	mov	rcx, QWORD PTR pMastDevExt
	add	rcx, 16
	call	KeInitializeSpinLock

; 1083 : 	InitializeListHead(&pMastDevExt->FADevsList);

	mov	rcx, QWORD PTR pMastDevExt
	add	rcx, 24
	call	InitializeListHead

; 1084 : 	pMastDevExt->FADevsCount = 0;

	mov	r11, QWORD PTR pMastDevExt
	mov	DWORD PTR [r11+40], 0

; 1085 : 
; 1086 : 	return STATUS_SUCCESS;

	xor	eax, eax
$LN2@CreateMain:

; 1087 : 		
; 1088 : }

	add	rsp, 72					; 00000048H
	ret	0
?CreateMainDevice@@YAJPEAU_DRIVER_OBJECT@@@Z ENDP	; CreateMainDevice
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?FltMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD imagerel ?FltMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
	DD	imagerel ?FltMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z+123
	DD	imagerel $unwind$?FltMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?FltMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?FltMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
_TEXT	SEGMENT
MajorFunction$ = 32
pStack$ = 40
tv67 = 48
pDevObj$ = 80
pIrp$ = 88
?FltMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z PROC ; FltMainDispatch, COMDAT

; 1379 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 1380 : 	PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	rcx, QWORD PTR pIrp$[rsp]
	call	IoGetCurrentIrpStackLocation
	mov	QWORD PTR pStack$[rsp], rax

; 1381 : 	UCHAR MajorFunction = pStack->MajorFunction;

	mov	rax, QWORD PTR pStack$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR MajorFunction$[rsp], al

; 1382 : 	switch (MajorFunction) {

	mov	al, BYTE PTR MajorFunction$[rsp]
	mov	BYTE PTR tv67[rsp], al
	cmp	BYTE PTR tv67[rsp], 3
	je	SHORT $LN3@FltMainDis
	cmp	BYTE PTR tv67[rsp], 4
	je	SHORT $LN2@FltMainDis
	jmp	SHORT $LN1@FltMainDis
$LN3@FltMainDis:

; 1383 : 		case IRP_MJ_READ:
; 1384 : 			return DispatchFilteredRead(pDevObj, pIrp);

	mov	rdx, QWORD PTR pIrp$[rsp]
	mov	rcx, QWORD PTR pDevObj$[rsp]
	call	?DispatchFilteredRead@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ; DispatchFilteredRead
	jmp	SHORT $LN6@FltMainDis

; 1385 : 			break;

	jmp	SHORT $LN4@FltMainDis
$LN2@FltMainDis:

; 1386 : 		case IRP_MJ_WRITE:
; 1387 : 			return DispatchFilteredWrite(pDevObj, pIrp);

	mov	rdx, QWORD PTR pIrp$[rsp]
	mov	rcx, QWORD PTR pDevObj$[rsp]
	call	?DispatchFilteredWrite@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ; DispatchFilteredWrite
	jmp	SHORT $LN6@FltMainDis

; 1388 : 			break;

	jmp	SHORT $LN4@FltMainDis
$LN1@FltMainDis:

; 1389 : 		default:
; 1390 : 
; 1391 : 			// Common tracing and forwarding.
; 1392 : 			//
; 1393 : 			return GenericTrace(pDevObj, pIrp);

	mov	rdx, QWORD PTR pIrp$[rsp]
	mov	rcx, QWORD PTR pDevObj$[rsp]
	call	?GenericTrace@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ; GenericTrace
$LN4@FltMainDis:
$LN6@FltMainDis:

; 1394 : 	}
; 1395 : }

	add	rsp, 72					; 00000048H
	ret	0
?FltMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ENDP ; FltMainDispatch
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?MainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD imagerel ?MainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
	DD	imagerel ?MainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z+167
	DD	imagerel $unwind$?MainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?MainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?MainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z
_TEXT	SEGMENT
pDevExt$ = 40
tv65 = 48
pDevObj$ = 80
pIrp$ = 88
?MainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z PROC	; MainDispatch, COMDAT

; 2518 : {

	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 2519 : 	PDEVICE_EXTENSION	pDevExt;
; 2520 : 	PIO_STACK_LOCATION	pStack;
; 2521 : 
; 2522 : 	pDevExt = (PDEVICE_EXTENSION) pDevObj->DeviceExtension;

	mov	rax, QWORD PTR pDevObj$[rsp]
	mov	rax, QWORD PTR [rax+64]
	mov	QWORD PTR pDevExt$[rsp], rax

; 2523 : 
; 2524 : 	switch (pDevExt->hdr.DevType) {

	mov	rax, QWORD PTR pDevExt$[rsp]
	mov	eax, DWORD PTR [rax]
	mov	DWORD PTR tv65[rsp], eax
	cmp	DWORD PTR tv65[rsp], 0
	je	SHORT $LN2@MainDispat
	cmp	DWORD PTR tv65[rsp], 1
	je	SHORT $LN4@MainDispat
	cmp	DWORD PTR tv65[rsp], 2
	je	SHORT $LN3@MainDispat
	jmp	SHORT $LN1@MainDispat
$LN4@MainDispat:

; 2525 : 		case DT_FILTER:
; 2526 : 			return FltMainDispatch(pDevObj, pIrp);

	mov	rdx, QWORD PTR pIrp$[rsp]
	mov	rcx, QWORD PTR pDevObj$[rsp]
	call	?FltMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ; FltMainDispatch
	jmp	SHORT $LN7@MainDispat

; 2527 : 			break;

	jmp	SHORT $LN5@MainDispat
$LN3@MainDispat:

; 2528 : 		case DT_FILTER_ACCESS:
; 2529 : 			return FAMainDispatch(pDevObj, pIrp);

	mov	rdx, QWORD PTR pIrp$[rsp]
	mov	rcx, QWORD PTR pDevObj$[rsp]
	call	?FAMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ; FAMainDispatch
	jmp	SHORT $LN7@MainDispat

; 2530 : 			break;

	jmp	SHORT $LN5@MainDispat
$LN2@MainDispat:

; 2531 : 		 case DT_MASTER:
; 2532 : 			 return MAMainDispatch(pDevObj, pIrp);

	mov	rdx, QWORD PTR pIrp$[rsp]
	mov	rcx, QWORD PTR pDevObj$[rsp]
	call	?MAMainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ; MAMainDispatch
	jmp	SHORT $LN7@MainDispat

; 2533 : 			 break;

	jmp	SHORT $LN5@MainDispat
$LN1@MainDispat:

; 2534 : 		 default:
; 2535 : 			pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;

	mov	rax, QWORD PTR pIrp$[rsp]
	mov	DWORD PTR [rax+48], -1073741637		; ffffffffc00000bbH

; 2536 : 			pIrp->IoStatus.Information = 0;

	mov	rax, QWORD PTR pIrp$[rsp]
	mov	QWORD PTR [rax+56], 0

; 2537 : 			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

	xor	edx, edx
	mov	rcx, QWORD PTR pIrp$[rsp]
	call	QWORD PTR __imp_IofCompleteRequest

; 2538 : 			return STATUS_NOT_SUPPORTED;

	mov	eax, -1073741637			; ffffffffc00000bbH
$LN5@MainDispat:
$LN7@MainDispat:

; 2539 : 	}
; 2540 : }

	add	rsp, 72					; 00000048H
	ret	0
?MainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ENDP	; MainDispatch
_TEXT	ENDS
PUBLIC	DriverEntry
;	COMDAT pdata
pdata	SEGMENT
$pdata$DriverEntry DD imagerel $LN7
	DD	imagerel $LN7+192
	DD	imagerel $unwind$DriverEntry
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DriverEntry DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT DriverEntry
_TEXT	SEGMENT
i$ = 48
status$ = 52
pDriverObject$ = 80
pRegistryPath$ = 88
DriverEntry PROC					; COMDAT

; 468  : 			IN PUNICODE_STRING pRegistryPath	) {

$LN7:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 469  : 	INT					i;
; 470  : 	PDEVICE_EXTENSION	pDevExt;
; 471  : 
; 472  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 473  : 		"\n\nFLT - DriverEntry - Test filter driver, compiled "
; 474  : 		"%s %s\n\n",__DATE__, __TIME__);

	lea	rax, OFFSET FLAT:??_C@_08EEFIHIAN@11?308?319?$AA@FNODOBFM@
	mov	QWORD PTR [rsp+32], rax
	lea	r9, OFFSET FLAT:??_C@_0M@DJNHNKNB@May?5?51?52013?$AA@FNODOBFM@
	lea	r8, OFFSET FLAT:??_C@_0DL@ENFACENM@?6?6FLT?5?9?5DriverEntry?5?9?5Test?5filte@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 475  : 
; 476  : 	// The filter will be loaded by the system and stay loaded,
; 477  : 	// so we don't have an unload routine.
; 478  : 	//
; 479  : 	pDriverObject->DriverUnload = NULL;

	mov	r11, QWORD PTR pDriverObject$[rsp]
	mov	QWORD PTR [r11+104], 0

; 480  : 	pDriverObject->DriverExtension->AddDevice = AddDevice;

	mov	rcx, QWORD PTR pDriverObject$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	lea	rax, OFFSET FLAT:?AddDevice@@YAJPEAU_DRIVER_OBJECT@@PEAU_DEVICE_OBJECT@@@Z ; AddDevice
	mov	QWORD PTR [rcx+8], rax

; 481  : 
; 482  : 	// Announce entry points for all the function
; 483  : 	// codes, so that the filter can be transparent.
; 484  : 	//
; 485  : 	for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION + 1; i++) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN4@DriverEntr
$LN3@DriverEntr:
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 1
	mov	DWORD PTR i$[rsp], eax
$LN4@DriverEntr:
	cmp	DWORD PTR i$[rsp], 28
	jge	SHORT $LN2@DriverEntr

; 486  : 		pDriverObject->MajorFunction[i] =
; 487  : 				MainDispatch;

	movsxd	rdx, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR pDriverObject$[rsp]
	lea	rax, OFFSET FLAT:?MainDispatch@@YAJPEAU_DEVICE_OBJECT@@PEAU_IRP@@@Z ; MainDispatch
	mov	QWORD PTR [rcx+rdx*8+112], rax

; 488  : 	}

	jmp	SHORT $LN3@DriverEntr
$LN2@DriverEntr:

; 489  : 
; 490  : 	// Create and initialize the main device.
; 491  : 	//
; 492  : 	NTSTATUS status = CreateMainDevice(pDriverObject);

	mov	rcx, QWORD PTR pDriverObject$[rsp]
	call	?CreateMainDevice@@YAJPEAU_DRIVER_OBJECT@@@Z ; CreateMainDevice
	mov	DWORD PTR status$[rsp], eax

; 493  : 	if (!NT_SUCCESS(status)) return status;

	cmp	DWORD PTR status$[rsp], 0
	jge	SHORT $LN1@DriverEntr
	mov	eax, DWORD PTR status$[rsp]
	jmp	SHORT $LN5@DriverEntr
$LN1@DriverEntr:

; 494  : 
; 495  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 496  : 		"FLT - DriverEntry - Test filter driver succesfully "
; 497  : 		"loaded.\n");

	lea	r8, OFFSET FLAT:??_C@_0DM@IFCHACPO@FLT?5?9?5DriverEntry?5?9?5Test?5filter?5@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 498  : 
; 499  : 	return STATUS_SUCCESS;

	xor	eax, eax
$LN5@DriverEntr:

; 500  : }

	add	rsp, 72					; 00000048H
	ret	0
DriverEntry ENDP
_TEXT	ENDS
END
