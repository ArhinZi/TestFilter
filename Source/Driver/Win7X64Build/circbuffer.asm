; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0FJ@FNHANJDH@CB?5?9?5CBAllocateBlock?5?9?5Allocatin@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CN@GKLFJEPI@CB?5?9?5CBAllocateBlock?5?9?5Bytes?5rem@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DG@NHBGMIEE@CB?5?9?5CBFreeOldestDataBlock?5?9?5Ava@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0FP@GOPFBPAP@CB?5?9?5CBFreeOldestDataBlock?5?9?5Dis@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DG@LDFCLJFD@CB?5?9?5CBFreeOldestDataBlock?5?9?5Ava@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CO@PDHPHBOO@CB?5?9?5CBInitBufferCtlVar?5?9?5Buffer@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BD@PFLOOKJ@?5?5?5?5start?3?5?5?5?5?$CF?$CDp?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BD@OONIOHJ@?5?5?5?5end?3?5?5?5?5?5?5?$CF?$CDp?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BD@EPPMMNOE@?5?5?5?5size?3?5?5?5?5?5?$CF?$CDx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0MI@BMMJCGO@CB?5?9?5CBStore?5?9?5Storing?4?6?5?5?5?5Curr@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0NE@DJKLCAIL@CB?5?9?5CBXtractFromStart?5?9?5Xtracti@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0NE@DJKLCAIL@CB?5?9?5CBXtractFromStart?5?9?5Xtracti@FNODOBFM@
text$s	SEGMENT
??_C@_0NE@DJKLCAIL@CB?5?9?5CBXtractFromStart?5?9?5Xtracti@FNODOBFM@ DB 'C'
	DB	'B - CBXtractFromStart - Xtracting.', 0aH, '    current block '
	DB	'start:       %#p', 0aH, '    length (not counting hdr): %#x', 0aH
	DB	'    source:                    %#p', 0aH, '    dest:         '
	DB	'             %#p', 0aH, '    len:                       %#x', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0MI@BMMJCGO@CB?5?9?5CBStore?5?9?5Storing?4?6?5?5?5?5Curr@FNODOBFM@
text$s	SEGMENT
??_C@_0MI@BMMJCGO@CB?5?9?5CBStore?5?9?5Storing?4?6?5?5?5?5Curr@FNODOBFM@ DB 'C'
	DB	'B - CBStore - Storing.', 0aH, '    Current block start:      '
	DB	' %#p', 0aH, '    length (not counting hdr): %#x', 0aH, '    s'
	DB	'tore addr:                %#p', 0aH, '    store length:      '
	DB	'        %#x', 0aH, '    src addr:                  %#p', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BD@EPPMMNOE@?5?5?5?5size?3?5?5?5?5?5?$CF?$CDx?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BD@EPPMMNOE@?5?5?5?5size?3?5?5?5?5?5?$CF?$CDx?6?$AA@FNODOBFM@ DB ' '
	DB	'   size:     %#x', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BD@OONIOHJ@?5?5?5?5end?3?5?5?5?5?5?5?$CF?$CDp?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BD@OONIOHJ@?5?5?5?5end?3?5?5?5?5?5?5?$CF?$CDp?6?$AA@FNODOBFM@ DB ' '
	DB	'   end:      %#p', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BD@PFLOOKJ@?5?5?5?5start?3?5?5?5?5?$CF?$CDp?6?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BD@PFLOOKJ@?5?5?5?5start?3?5?5?5?5?$CF?$CDp?6?$AA@FNODOBFM@ DB '  '
	DB	'  start:    %#p', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CO@PDHPHBOO@CB?5?9?5CBInitBufferCtlVar?5?9?5Buffer@FNODOBFM@
text$s	SEGMENT
??_C@_0CO@PDHPHBOO@CB?5?9?5CBInitBufferCtlVar?5?9?5Buffer@FNODOBFM@ DB 'C'
	DB	'B - CBInitBufferCtlVar - Buffer initialized', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DG@LDFCLJFD@CB?5?9?5CBFreeOldestDataBlock?5?9?5Ava@FNODOBFM@
text$s	SEGMENT
??_C@_0DG@LDFCLJFD@CB?5?9?5CBFreeOldestDataBlock?5?9?5Ava@FNODOBFM@ DB 'C'
	DB	'B - CBFreeOldestDataBlock - Avail bytes after:  %#x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0FP@GOPFBPAP@CB?5?9?5CBFreeOldestDataBlock?5?9?5Dis@FNODOBFM@
text$s	SEGMENT
??_C@_0FP@GOPFBPAP@CB?5?9?5CBFreeOldestDataBlock?5?9?5Dis@FNODOBFM@ DB 'C'
	DB	'B - CBFreeOldestDataBlock - Discarding block: start %#p, leng'
	DB	'th (not counting hdr) %#x bytes', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DG@NHBGMIEE@CB?5?9?5CBFreeOldestDataBlock?5?9?5Ava@FNODOBFM@
text$s	SEGMENT
??_C@_0DG@NHBGMIEE@CB?5?9?5CBFreeOldestDataBlock?5?9?5Ava@FNODOBFM@ DB 'C'
	DB	'B - CBFreeOldestDataBlock - Avail bytes before: %#x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CN@GKLFJEPI@CB?5?9?5CBAllocateBlock?5?9?5Bytes?5rem@FNODOBFM@
text$s	SEGMENT
??_C@_0CN@GKLFJEPI@CB?5?9?5CBAllocateBlock?5?9?5Bytes?5rem@FNODOBFM@ DB 'C'
	DB	'B - CBAllocateBlock - Bytes remaining: %#x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0FJ@FNHANJDH@CB?5?9?5CBAllocateBlock?5?9?5Allocatin@FNODOBFM@
text$s	SEGMENT
??_C@_0FJ@FNHANJDH@CB?5?9?5CBAllocateBlock?5?9?5Allocatin@FNODOBFM@ DB 'C'
	DB	'B - CBAllocateBlock - Allocating block: start %#p, length (no'
	DB	't counting hdr) %#x bytes', 0aH, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
PUBLIC	?CBMovePtrForward@@YAJPEAU_CIRCULAR_BUFFER@@PEAPEAD_K@Z ; CBMovePtrForward
;	COMDAT pdata
; File b:\programm\wntsys\testfilter\release\1_1\source\driver\circbuffer.cpp
pdata	SEGMENT
$pdata$?CBMovePtrForward@@YAJPEAU_CIRCULAR_BUFFER@@PEAPEAD_K@Z DD imagerel $LN7
	DD	imagerel $LN7+172
	DD	imagerel $unwind$?CBMovePtrForward@@YAJPEAU_CIRCULAR_BUFFER@@PEAPEAD_K@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CBMovePtrForward@@YAJPEAU_CIRCULAR_BUFFER@@PEAPEAD_K@Z DD 011301H
	DD	02213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?CBMovePtrForward@@YAJPEAU_CIRCULAR_BUFFER@@PEAPEAD_K@Z
_TEXT	SEGMENT
cbOverflow$28607 = 0
pBufCtl$ = 32
ppAddress$ = 40
cbBytes$ = 48
?CBMovePtrForward@@YAJPEAU_CIRCULAR_BUFFER@@PEAPEAD_K@Z PROC ; CBMovePtrForward, COMDAT

; 172  : {

$LN7:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 173  : 	if (ppAddress == NULL) return STATUS_INVALID_PARAMETER;

	cmp	QWORD PTR ppAddress$[rsp], 0
	jne	SHORT $LN4@CBMovePtrF
	mov	eax, -1073741811			; ffffffffc000000dH
	jmp	$LN5@CBMovePtrF
$LN4@CBMovePtrF:

; 174  : 
; 175  : 	if ((*ppAddress < pBufCtl->pBufStartAddr) ||
; 176  : 		(*ppAddress >= pBufCtl->pBufEndAddr)) 

	mov	rcx, QWORD PTR ppAddress$[rsp]
	mov	rax, QWORD PTR pBufCtl$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR [rcx], rax
	jb	SHORT $LN2@CBMovePtrF
	mov	rcx, QWORD PTR ppAddress$[rsp]
	mov	rax, QWORD PTR pBufCtl$[rsp]
	mov	rax, QWORD PTR [rax+8]
	cmp	QWORD PTR [rcx], rax
	jb	SHORT $LN3@CBMovePtrF
$LN2@CBMovePtrF:

; 177  : 		return STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; ffffffffc000000dH
	jmp	SHORT $LN5@CBMovePtrF
$LN3@CBMovePtrF:

; 178  : 
; 179  : 	*ppAddress += cbBytes;

	mov	rcx, QWORD PTR ppAddress$[rsp]
	mov	rcx, QWORD PTR [rcx]
	add	rcx, QWORD PTR cbBytes$[rsp]
	mov	rax, QWORD PTR ppAddress$[rsp]
	mov	QWORD PTR [rax], rcx

; 180  : 	if (*ppAddress >= pBufCtl->pBufEndAddr) {

	mov	rcx, QWORD PTR ppAddress$[rsp]
	mov	rax, QWORD PTR pBufCtl$[rsp]
	mov	rax, QWORD PTR [rax+8]
	cmp	QWORD PTR [rcx], rax
	jb	SHORT $LN1@CBMovePtrF

; 181  : 		SIZE_T cbOverflow = *ppAddress - 
; 182  : 			pBufCtl->pBufEndAddr;

	mov	rax, QWORD PTR ppAddress$[rsp]
	mov	rcx, QWORD PTR pBufCtl$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	mov	rax, QWORD PTR [rax]
	sub	rax, rcx
	mov	QWORD PTR cbOverflow$28607[rsp], rax

; 183  : 		// cbOverflow is the number of bytes that would fall past the 
; 184  : 		// end of the buffer.
; 185  : 
; 186  : 		*ppAddress = pBufCtl->pBufStartAddr + cbOverflow;

	mov	rcx, QWORD PTR pBufCtl$[rsp]
	mov	rcx, QWORD PTR [rcx]
	add	rcx, QWORD PTR cbOverflow$28607[rsp]
	mov	rax, QWORD PTR ppAddress$[rsp]
	mov	QWORD PTR [rax], rcx
$LN1@CBMovePtrF:

; 187  : 	}
; 188  : 	return STATUS_SUCCESS;

	xor	eax, eax
$LN5@CBMovePtrF:

; 189  : }

	add	rsp, 24
	ret	0
?CBMovePtrForward@@YAJPEAU_CIRCULAR_BUFFER@@PEAPEAD_K@Z ENDP ; CBMovePtrForward
_TEXT	ENDS
PUBLIC	?CBInitBufferCtlVar@@YAXPEAU_CIRCULAR_BUFFER@@PEAX_K@Z ; CBInitBufferCtlVar
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CBInitBufferCtlVar@@YAXPEAU_CIRCULAR_BUFFER@@PEAX_K@Z DD imagerel $LN3
	DD	imagerel $LN3+221
	DD	imagerel $unwind$?CBInitBufferCtlVar@@YAXPEAU_CIRCULAR_BUFFER@@PEAX_K@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CBInitBufferCtlVar@@YAXPEAU_CIRCULAR_BUFFER@@PEAX_K@Z DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?CBInitBufferCtlVar@@YAXPEAU_CIRCULAR_BUFFER@@PEAX_K@Z
_TEXT	SEGMENT
pBufCtl$ = 48
pBufAddr$ = 56
cbBufSize$ = 64
?CBInitBufferCtlVar@@YAXPEAU_CIRCULAR_BUFFER@@PEAX_K@Z PROC ; CBInitBufferCtlVar, COMDAT

; 147  : {

$LN3:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 148  : 	pBufCtl->pBufStartAddr = (PCHAR) pBufAddr;

	mov	rcx, QWORD PTR pBufCtl$[rsp]
	mov	rax, QWORD PTR pBufAddr$[rsp]
	mov	QWORD PTR [rcx], rax

; 149  : 	pBufCtl->pBufEndAddr = ((PCHAR) pBufAddr) + cbBufSize;

	mov	rax, QWORD PTR cbBufSize$[rsp]
	mov	rcx, QWORD PTR pBufAddr$[rsp]
	add	rcx, rax
	mov	rax, QWORD PTR pBufCtl$[rsp]
	mov	QWORD PTR [rax+8], rcx

; 150  : 	pBufCtl->cbBufSize = cbBufSize;

	mov	rcx, QWORD PTR pBufCtl$[rsp]
	mov	rax, QWORD PTR cbBufSize$[rsp]
	mov	QWORD PTR [rcx+16], rax

; 151  : 	pBufCtl->pDataStart = (PCHAR) pBufAddr;

	mov	rcx, QWORD PTR pBufCtl$[rsp]
	mov	rax, QWORD PTR pBufAddr$[rsp]
	mov	QWORD PTR [rcx+24], rax

; 152  : 	pBufCtl->pDataEnd = (PCHAR) pBufAddr;

	mov	rcx, QWORD PTR pBufCtl$[rsp]
	mov	rax, QWORD PTR pBufAddr$[rsp]
	mov	QWORD PTR [rcx+32], rax

; 153  : 	pBufCtl->cbAvailable = cbBufSize;

	mov	rcx, QWORD PTR pBufCtl$[rsp]
	mov	rax, QWORD PTR cbBufSize$[rsp]
	mov	QWORD PTR [rcx+48], rax

; 154  : 
; 155  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 156  : 		"CB - CBInitBufferCtlVar - Buffer initialized\n");

	lea	r8, OFFSET FLAT:??_C@_0CO@PDHPHBOO@CB?5?9?5CBInitBufferCtlVar?5?9?5Buffer@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 157  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 158  : 		"    start:    %#p\n", pBufCtl->pBufStartAddr);

	mov	r9, QWORD PTR pBufCtl$[rsp]
	mov	r9, QWORD PTR [r9]
	lea	r8, OFFSET FLAT:??_C@_0BD@PFLOOKJ@?5?5?5?5start?3?5?5?5?5?$CF?$CDp?6?$AA@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 159  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 160  : 		"    end:      %#p\n", pBufCtl->pBufEndAddr);

	mov	r9, QWORD PTR pBufCtl$[rsp]
	mov	r9, QWORD PTR [r9+8]
	lea	r8, OFFSET FLAT:??_C@_0BD@OONIOHJ@?5?5?5?5end?3?5?5?5?5?5?5?$CF?$CDp?6?$AA@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 161  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 162  : 		"    size:     %#x\n", pBufCtl->cbBufSize);

	mov	r9, QWORD PTR pBufCtl$[rsp]
	mov	r9, QWORD PTR [r9+16]
	lea	r8, OFFSET FLAT:??_C@_0BD@EPPMMNOE@?5?5?5?5size?3?5?5?5?5?5?$CF?$CDx?6?$AA@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 163  : 
; 164  : }

	add	rsp, 40					; 00000028H
	ret	0
?CBInitBufferCtlVar@@YAXPEAU_CIRCULAR_BUFFER@@PEAX_K@Z ENDP ; CBInitBufferCtlVar
_TEXT	ENDS
PUBLIC	?CBFreeOldestDataBlock@@YAXPEAU_CIRCULAR_BUFFER@@@Z ; CBFreeOldestDataBlock
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CBFreeOldestDataBlock@@YAXPEAU_CIRCULAR_BUFFER@@@Z DD imagerel $LN6
	DD	imagerel $LN6+272
	DD	imagerel $unwind$?CBFreeOldestDataBlock@@YAXPEAU_CIRCULAR_BUFFER@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CBFreeOldestDataBlock@@YAXPEAU_CIRCULAR_BUFFER@@@Z DD 010901H
	DD	0c209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?CBFreeOldestDataBlock@@YAXPEAU_CIRCULAR_BUFFER@@@Z
_TEXT	SEGMENT
pHdr$ = 48
cbBytesFreed$ = 56
OldestHdr$ = 64
pHdrVar$ = 72
i$28575 = 80
pBufCtl$ = 112
?CBFreeOldestDataBlock@@YAXPEAU_CIRCULAR_BUFFER@@@Z PROC ; CBFreeOldestDataBlock, COMDAT

; 110  : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 111  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 112  : 		"CB - CBFreeOldestDataBlock - Avail bytes before: %#x\n",
; 113  : 		pBufCtl->cbAvailable);

	mov	r9, QWORD PTR pBufCtl$[rsp]
	mov	r9, QWORD PTR [r9+48]
	lea	r8, OFFSET FLAT:??_C@_0DG@NHBGMIEE@CB?5?9?5CBFreeOldestDataBlock?5?9?5Ava@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 114  : 	CB_BLOCK_HEADER OldestHdr;
; 115  : 
; 116  : 	// Extract the block header. Keep in mind that it can wrap
; 117  : 	// around the end.
; 118  : 	//
; 119  : 	PCHAR pHdrVar = (PCHAR) &OldestHdr;

	lea	r11, QWORD PTR OldestHdr$[rsp]
	mov	QWORD PTR pHdrVar$[rsp], r11

; 120  : 	PCHAR pHdr = pBufCtl->pDataStart;

	mov	rax, QWORD PTR pBufCtl$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR pHdr$[rsp], rax

; 121  : 	for (INT i = 0; i < sizeof OldestHdr; i++) {

	mov	DWORD PTR i$28575[rsp], 0
	jmp	SHORT $LN3@CBFreeOlde
$LN2@CBFreeOlde:
	mov	eax, DWORD PTR i$28575[rsp]
	add	eax, 1
	mov	DWORD PTR i$28575[rsp], eax
$LN3@CBFreeOlde:
	movsxd	rax, DWORD PTR i$28575[rsp]
	cmp	rax, 8
	jae	SHORT $LN1@CBFreeOlde

; 122  : 		*(pHdrVar + i) = *pHdr;

	movsxd	rdx, DWORD PTR i$28575[rsp]
	mov	rcx, QWORD PTR pHdrVar$[rsp]
	mov	rax, QWORD PTR pHdr$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx+rdx], al

; 123  : 		CBMovePtrForward(pBufCtl, &pHdr, 1);

	mov	r8d, 1
	lea	rdx, QWORD PTR pHdr$[rsp]
	mov	rcx, QWORD PTR pBufCtl$[rsp]
	call	?CBMovePtrForward@@YAJPEAU_CIRCULAR_BUFFER@@PEAPEAD_K@Z ; CBMovePtrForward

; 124  : 	}

	jmp	SHORT $LN2@CBFreeOlde
$LN1@CBFreeOlde:

; 125  : 
; 126  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 127  : 		"CB - CBFreeOldestDataBlock - Discarding block: start %#p, "
; 128  : 		"length (not counting "
; 129  : 		"hdr) %#x bytes\n", pBufCtl->pDataStart, OldestHdr.cbSize);

	mov	rax, QWORD PTR OldestHdr$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR pBufCtl$[rsp]
	mov	r9, QWORD PTR [r9+24]
	lea	r8, OFFSET FLAT:??_C@_0FP@GOPFBPAP@CB?5?9?5CBFreeOldestDataBlock?5?9?5Dis@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 130  : 
; 131  : 	SIZE_T cbBytesFreed = OldestHdr.cbSize + sizeof (CB_BLOCK_HEADER);

	mov	rax, QWORD PTR OldestHdr$[rsp]
	add	rax, 8
	mov	QWORD PTR cbBytesFreed$[rsp], rax

; 132  : 	CBMovePtrForward(pBufCtl, &pBufCtl->pDataStart, cbBytesFreed);

	mov	rdx, QWORD PTR pBufCtl$[rsp]
	add	rdx, 24
	mov	r8, QWORD PTR cbBytesFreed$[rsp]
	mov	rcx, QWORD PTR pBufCtl$[rsp]
	call	?CBMovePtrForward@@YAJPEAU_CIRCULAR_BUFFER@@PEAPEAD_K@Z ; CBMovePtrForward

; 133  : 	pBufCtl->cbAvailable += cbBytesFreed;

	mov	rcx, QWORD PTR pBufCtl$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	add	rcx, QWORD PTR cbBytesFreed$[rsp]
	mov	rax, QWORD PTR pBufCtl$[rsp]
	mov	QWORD PTR [rax+48], rcx

; 134  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 135  : 		"CB - CBFreeOldestDataBlock - Avail bytes after:  %#x\n",
; 136  : 		pBufCtl->cbAvailable);

	mov	r9, QWORD PTR pBufCtl$[rsp]
	mov	r9, QWORD PTR [r9+48]
	lea	r8, OFFSET FLAT:??_C@_0DG@LDFCLJFD@CB?5?9?5CBFreeOldestDataBlock?5?9?5Ava@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 137  : 	return;
; 138  : }

	add	rsp, 104				; 00000068H
	ret	0
?CBFreeOldestDataBlock@@YAXPEAU_CIRCULAR_BUFFER@@@Z ENDP ; CBFreeOldestDataBlock
_TEXT	ENDS
PUBLIC	?CBDataBufferEmpty@@YAEPEAU_CIRCULAR_BUFFER@@@Z	; CBDataBufferEmpty
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CBDataBufferEmpty@@YAEPEAU_CIRCULAR_BUFFER@@@Z DD imagerel $LN5
	DD	imagerel $LN5+47
	DD	imagerel $unwind$?CBDataBufferEmpty@@YAEPEAU_CIRCULAR_BUFFER@@@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CBDataBufferEmpty@@YAEPEAU_CIRCULAR_BUFFER@@@Z DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?CBDataBufferEmpty@@YAEPEAU_CIRCULAR_BUFFER@@@Z
_TEXT	SEGMENT
tv67 = 0
pBufCtl$ = 32
?CBDataBufferEmpty@@YAEPEAU_CIRCULAR_BUFFER@@@Z PROC	; CBDataBufferEmpty, COMDAT

; 102  : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 103  : 	return (pBufCtl->pDataStart == pBufCtl->pDataEnd);

	mov	rcx, QWORD PTR pBufCtl$[rsp]
	mov	rax, QWORD PTR pBufCtl$[rsp]
	mov	rax, QWORD PTR [rax+32]
	cmp	QWORD PTR [rcx+24], rax
	jne	SHORT $LN3@CBDataBuff
	mov	BYTE PTR tv67[rsp], 1
	jmp	SHORT $LN4@CBDataBuff
$LN3@CBDataBuff:
	mov	BYTE PTR tv67[rsp], 0
$LN4@CBDataBuff:
	mov	al, BYTE PTR tv67[rsp]

; 104  : }

	add	rsp, 24
	ret	0
?CBDataBufferEmpty@@YAEPEAU_CIRCULAR_BUFFER@@@Z ENDP	; CBDataBufferEmpty
_TEXT	ENDS
PUBLIC	?CBAllocateBlock@@YAJPEAU_CIRCULAR_BUFFER@@_K@Z	; CBAllocateBlock
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CBAllocateBlock@@YAJPEAU_CIRCULAR_BUFFER@@_K@Z DD imagerel $LN9
	DD	imagerel $LN9+354
	DD	imagerel $unwind$?CBAllocateBlock@@YAJPEAU_CIRCULAR_BUFFER@@_K@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CBAllocateBlock@@YAJPEAU_CIRCULAR_BUFFER@@_K@Z DD 010e01H
	DD	0c20eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?CBAllocateBlock@@YAJPEAU_CIRCULAR_BUFFER@@_K@Z
_TEXT	SEGMENT
pHdr$ = 48
cbBytesNeeded$ = 56
pBlockStart$ = 64
blockHdr$ = 72
status$ = 80
i$28559 = 84
pBufCtl$ = 112
cbBlockSize$ = 120
?CBAllocateBlock@@YAJPEAU_CIRCULAR_BUFFER@@_K@Z PROC	; CBAllocateBlock, COMDAT

; 46   : {

$LN9:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 104				; 00000068H

; 47   : 	SIZE_T cbBytesNeeded = cbBlockSize + sizeof(CB_BLOCK_HEADER);

	mov	rax, QWORD PTR cbBlockSize$[rsp]
	add	rax, 8
	mov	QWORD PTR cbBytesNeeded$[rsp], rax

; 48   : 
; 49   : 	// Ensure that the block can fit into the buffer.
; 50   : 	//
; 51   : 	if (cbBytesNeeded > pBufCtl->cbBufSize) {

	mov	rax, QWORD PTR pBufCtl$[rsp]
	mov	rax, QWORD PTR [rax+16]
	cmp	QWORD PTR cbBytesNeeded$[rsp], rax
	jbe	SHORT $LN6@CBAllocate

; 52   : 		return STATUS_NO_MEMORY;

	mov	eax, -1073741801			; ffffffffc0000017H
	jmp	$LN7@CBAllocate
$LN6@CBAllocate:

; 53   : 	}
; 54   : 	NTSTATUS status = STATUS_SUCCESS;

	mov	DWORD PTR status$[rsp], 0
$LN5@CBAllocate:

; 55   : 
; 56   : 	// Discard data if the available space is not enough.
; 57   : 	//
; 58   : 	while (pBufCtl->cbAvailable < cbBytesNeeded) {

	mov	rcx, QWORD PTR pBufCtl$[rsp]
	mov	rax, QWORD PTR cbBytesNeeded$[rsp]
	cmp	QWORD PTR [rcx+48], rax
	jae	SHORT $LN4@CBAllocate

; 59   : 		CBFreeOldestDataBlock(pBufCtl);

	mov	rcx, QWORD PTR pBufCtl$[rsp]
	call	?CBFreeOldestDataBlock@@YAXPEAU_CIRCULAR_BUFFER@@@Z ; CBFreeOldestDataBlock

; 60   : 		status = CB_STATUS_WARN_DATA_LOST;

	mov	DWORD PTR status$[rsp], -1610612735	; ffffffffa0000001H

; 61   : 	}

	jmp	SHORT $LN5@CBAllocate
$LN4@CBAllocate:

; 62   : 	PCHAR pBlockStart = pBufCtl->pDataEnd;

	mov	rax, QWORD PTR pBufCtl$[rsp]
	mov	rax, QWORD PTR [rax+32]
	mov	QWORD PTR pBlockStart$[rsp], rax

; 63   : 
; 64   : 	// Note on pDataStart (buffer ctl structure): if the buffer is not 
; 65   : 	// empty, the new block is not the beginning of the data.
; 66   : 	// pDataStart already points to the beginning of the data and needs 
; 67   : 	// not to be updated.
; 68   : 	//
; 69   : 	// If the buffer is empty, the new block is also the beginning
; 70   : 	// of the data and pDataStart must point to it, however, given that 
; 71   : 	// for an empty buffer pDataStart = pDataEnd, it already has the 
; 72   : 	// correct address.
; 73   : 	//
; 74   : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 75   : 		"CB - CBAllocateBlock - Allocating block: start %#p, length "
; 76   : 		"(not counting hdr) %#x bytes\n", pBlockStart, cbBlockSize);

	mov	rax, QWORD PTR cbBlockSize$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR pBlockStart$[rsp]
	lea	r8, OFFSET FLAT:??_C@_0FJ@FNHANJDH@CB?5?9?5CBAllocateBlock?5?9?5Allocatin@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 77   : 
; 78   : 	CBMovePtrForward(pBufCtl, &pBufCtl->pDataEnd, cbBytesNeeded);

	mov	rdx, QWORD PTR pBufCtl$[rsp]
	add	rdx, 32					; 00000020H
	mov	r8, QWORD PTR cbBytesNeeded$[rsp]
	mov	rcx, QWORD PTR pBufCtl$[rsp]
	call	?CBMovePtrForward@@YAJPEAU_CIRCULAR_BUFFER@@PEAPEAD_K@Z ; CBMovePtrForward

; 79   : 	pBufCtl->cbAvailable -= cbBytesNeeded;

	mov	rcx, QWORD PTR pBufCtl$[rsp]
	mov	rax, QWORD PTR cbBytesNeeded$[rsp]
	mov	rcx, QWORD PTR [rcx+48]
	sub	rcx, rax
	mov	rax, QWORD PTR pBufCtl$[rsp]
	mov	QWORD PTR [rax+48], rcx

; 80   : 	pBufCtl->pCurrentBlock = pBlockStart;

	mov	rcx, QWORD PTR pBufCtl$[rsp]
	mov	rax, QWORD PTR pBlockStart$[rsp]
	mov	QWORD PTR [rcx+40], rax

; 81   : 
; 82   : 	// Write the data block header at the block starting address
; 83   : 	//
; 84   : 	CB_BLOCK_HEADER blockHdr = {0};

	mov	QWORD PTR blockHdr$[rsp], 0

; 85   : 	blockHdr.cbSize = cbBlockSize;

	mov	rax, QWORD PTR cbBlockSize$[rsp]
	mov	QWORD PTR blockHdr$[rsp], rax

; 86   : 	PCHAR pHdr = (PCHAR) &blockHdr;

	lea	rax, QWORD PTR blockHdr$[rsp]
	mov	QWORD PTR pHdr$[rsp], rax

; 87   : 	for (INT i = 0; i < sizeof blockHdr; i++) {

	mov	DWORD PTR i$28559[rsp], 0
	jmp	SHORT $LN3@CBAllocate
$LN2@CBAllocate:
	mov	eax, DWORD PTR i$28559[rsp]
	add	eax, 1
	mov	DWORD PTR i$28559[rsp], eax
$LN3@CBAllocate:
	movsxd	rax, DWORD PTR i$28559[rsp]
	cmp	rax, 8
	jae	SHORT $LN1@CBAllocate

; 88   : 		*pBlockStart = *(pHdr + i);

	movsxd	rdx, DWORD PTR i$28559[rsp]
	mov	rcx, QWORD PTR pBlockStart$[rsp]
	mov	rax, QWORD PTR pHdr$[rsp]
	movzx	eax, BYTE PTR [rax+rdx]
	mov	BYTE PTR [rcx], al

; 89   : 		CBMovePtrForward(pBufCtl, &pBlockStart, 1);

	mov	r8d, 1
	lea	rdx, QWORD PTR pBlockStart$[rsp]
	mov	rcx, QWORD PTR pBufCtl$[rsp]
	call	?CBMovePtrForward@@YAJPEAU_CIRCULAR_BUFFER@@PEAPEAD_K@Z ; CBMovePtrForward

; 90   : 	}

	jmp	SHORT $LN2@CBAllocate
$LN1@CBAllocate:

; 91   : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 92   : 		"CB - CBAllocateBlock - Bytes remaining: %#x\n",
; 93   : 		pBufCtl->cbAvailable);

	mov	r9, QWORD PTR pBufCtl$[rsp]
	mov	r9, QWORD PTR [r9+48]
	lea	r8, OFFSET FLAT:??_C@_0CN@GKLFJEPI@CB?5?9?5CBAllocateBlock?5?9?5Bytes?5rem@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 94   : 
; 95   : 	return status;

	mov	eax, DWORD PTR status$[rsp]
$LN7@CBAllocate:

; 96   : }

	add	rsp, 104				; 00000068H
	ret	0
?CBAllocateBlock@@YAJPEAU_CIRCULAR_BUFFER@@_K@Z ENDP	; CBAllocateBlock
PUBLIC	?CBXtractFromStart@@YAJPEAU_CIRCULAR_BUFFER@@PEA_KPEAPEAD111@Z ; CBXtractFromStart
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CBXtractFromStart@@YAJPEAU_CIRCULAR_BUFFER@@PEA_KPEAPEAD111@Z DD imagerel $LN18
	DD	imagerel $LN18+791
	DD	imagerel $unwind$?CBXtractFromStart@@YAJPEAU_CIRCULAR_BUFFER@@PEA_KPEAPEAD111@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CBXtractFromStart@@YAJPEAU_CIRCULAR_BUFFER@@PEA_KPEAPEAD111@Z DD 041d01H
	DD	013011dH
	DD	060157016H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?CBXtractFromStart@@YAJPEAU_CIRCULAR_BUFFER@@PEA_KPEAPEAD111@Z
_TEXT	SEGMENT
pHdr$ = 64
cbAvailLen$ = 72
block2ndChunkLen$ = 80
pXStart$ = 88
cbXLen$ = 96
blkHdr$ = 104
pHdrVar$ = 112
cbContiguous$ = 120
i$28654 = 128
tv82 = 136
pBufCtl$ = 176
pcbXtractOffset$ = 184
ppDest$ = 192
pcbDestFree$ = 200
pcbBytesToRead$ = 208
pcbBytesRead$ = 216
?CBXtractFromStart@@YAJPEAU_CIRCULAR_BUFFER@@PEA_KPEAPEAD111@Z PROC ; CBXtractFromStart, COMDAT

; 285  : {

$LN18:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 152				; 00000098H

; 286  : 	if (CBDataBufferEmpty(pBufCtl)) {

	mov	rcx, QWORD PTR pBufCtl$[rsp]
	call	?CBDataBufferEmpty@@YAEPEAU_CIRCULAR_BUFFER@@@Z ; CBDataBufferEmpty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@CBXtractFr

; 287  : 		return STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; ffffffffc000000dH
	jmp	$LN14@CBXtractFr
$LN13@CBXtractFr:

; 288  : 	}
; 289  : 
; 290  : 	// Check that the offset is valid.
; 291  : 	//
; 292  : 	CB_BLOCK_HEADER blkHdr;
; 293  : 
; 294  : 	// Extract the block header. The pointer into the buffer is
; 295  : 	// advanced calling CBMovePtrForward to account for the fact that 
; 296  : 	// the header could wrap around the buffer end.
; 297  : 	//
; 298  : 	PCHAR pHdrVar = (PCHAR) &blkHdr;

	lea	rax, QWORD PTR blkHdr$[rsp]
	mov	QWORD PTR pHdrVar$[rsp], rax

; 299  : 	PCHAR pHdr = pBufCtl->pDataStart;

	mov	rax, QWORD PTR pBufCtl$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR pHdr$[rsp], rax

; 300  : 	for (INT i = 0; i < sizeof blkHdr; i++) {

	mov	DWORD PTR i$28654[rsp], 0
	jmp	SHORT $LN12@CBXtractFr
$LN11@CBXtractFr:
	mov	eax, DWORD PTR i$28654[rsp]
	add	eax, 1
	mov	DWORD PTR i$28654[rsp], eax
$LN12@CBXtractFr:
	movsxd	rax, DWORD PTR i$28654[rsp]
	cmp	rax, 8
	jae	SHORT $LN10@CBXtractFr

; 301  : 		*(pHdrVar + i) = *pHdr;

	movsxd	rdx, DWORD PTR i$28654[rsp]
	mov	rcx, QWORD PTR pHdrVar$[rsp]
	mov	rax, QWORD PTR pHdr$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx+rdx], al

; 302  : 		CBMovePtrForward(pBufCtl, &pHdr, 1);

	mov	r8d, 1
	lea	rdx, QWORD PTR pHdr$[rsp]
	mov	rcx, QWORD PTR pBufCtl$[rsp]
	call	?CBMovePtrForward@@YAJPEAU_CIRCULAR_BUFFER@@PEAPEAD_K@Z ; CBMovePtrForward

; 303  : 	}

	jmp	SHORT $LN11@CBXtractFr
$LN10@CBXtractFr:

; 304  : 
; 305  : 	if (*pcbXtractOffset >= blkHdr.cbSize) 

	mov	rcx, QWORD PTR pcbXtractOffset$[rsp]
	mov	rax, QWORD PTR blkHdr$[rsp]
	cmp	QWORD PTR [rcx], rax
	jb	SHORT $LN9@CBXtractFr

; 306  : 		return STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; ffffffffc000000dH
	jmp	$LN14@CBXtractFr
$LN9@CBXtractFr:

; 307  : 	// Compute the amount of data requested. cbXLen will be the 
; 308  : 	// extraction length, cbAvailLen the available bytes from
; 309  : 	// the offset to the block end.
; 310  : 	//
; 311  : 	SIZE_T cbXLen;
; 312  : 	SIZE_T cbAvailLen = blkHdr.cbSize - *pcbXtractOffset;

	mov	rcx, QWORD PTR pcbXtractOffset$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR blkHdr$[rsp]
	sub	rax, rcx
	mov	QWORD PTR cbAvailLen$[rsp], rax

; 313  : 	if (pcbBytesToRead == NULL) {

	cmp	QWORD PTR pcbBytesToRead$[rsp], 0
	jne	SHORT $LN8@CBXtractFr

; 314  : 
; 315  : 		// NULL means up to the end of the block.
; 316  : 		//
; 317  : 		cbXLen = cbAvailLen;

	mov	rax, QWORD PTR cbAvailLen$[rsp]
	mov	QWORD PTR cbXLen$[rsp], rax
	jmp	SHORT $LN7@CBXtractFr
$LN8@CBXtractFr:

; 318  : 	} else if (*pcbBytesToRead > cbAvailLen) {

	mov	rcx, QWORD PTR pcbBytesToRead$[rsp]
	mov	rax, QWORD PTR cbAvailLen$[rsp]
	cmp	QWORD PTR [rcx], rax
	jbe	SHORT $LN6@CBXtractFr

; 319  : 		cbXLen = cbAvailLen;

	mov	rax, QWORD PTR cbAvailLen$[rsp]
	mov	QWORD PTR cbXLen$[rsp], rax

; 320  : 	} else {

	jmp	SHORT $LN5@CBXtractFr
$LN6@CBXtractFr:

; 321  : 		cbXLen = *pcbBytesToRead;

	mov	rax, QWORD PTR pcbBytesToRead$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR cbXLen$[rsp], rax
$LN5@CBXtractFr:
$LN7@CBXtractFr:

; 322  : 	}
; 323  : 
; 324  : 	// Limit the amount of data based on *pcbDestFree.
; 325  : 	//
; 326  : 	cbXLen = (cbXLen < *pcbDestFree ? cbXLen : *pcbDestFree);

	mov	rax, QWORD PTR pcbDestFree$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR cbXLen$[rsp], rax
	jae	SHORT $LN16@CBXtractFr
	mov	rax, QWORD PTR cbXLen$[rsp]
	mov	QWORD PTR tv82[rsp], rax
	jmp	SHORT $LN17@CBXtractFr
$LN16@CBXtractFr:
	mov	rax, QWORD PTR pcbDestFree$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv82[rsp], rax
$LN17@CBXtractFr:
	mov	rax, QWORD PTR tv82[rsp]
	mov	QWORD PTR cbXLen$[rsp], rax

; 327  : 
; 328  : 	// Compute the start address skipping the header and taking the
; 329  : 	// offset into account. Use CBMovePtrForward(), because we might
; 330  : 	// be crossing the end of the buffer.
; 331  : 	//
; 332  : 	PCHAR pXStart = pBufCtl->pDataStart;

	mov	rax, QWORD PTR pBufCtl$[rsp]
	mov	rax, QWORD PTR [rax+24]
	mov	QWORD PTR pXStart$[rsp], rax

; 333  : 	CBMovePtrForward(pBufCtl, &pXStart, sizeof (CB_BLOCK_HEADER) +
; 334  : 		*pcbXtractOffset);

	mov	r8, QWORD PTR pcbXtractOffset$[rsp]
	mov	r8, QWORD PTR [r8]
	add	r8, 8
	lea	rdx, QWORD PTR pXStart$[rsp]
	mov	rcx, QWORD PTR pBufCtl$[rsp]
	call	?CBMovePtrForward@@YAJPEAU_CIRCULAR_BUFFER@@PEAPEAD_K@Z ; CBMovePtrForward

; 335  : 
; 336  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 337  : 		"CB - CBXtractFromStart - Xtracting.\n"
; 338  : 		"    current block start:       %#p\n"
; 339  : 		"    length (not counting hdr): %#x\n"
; 340  : 		"    source:                    %#p\n"
; 341  : 		"    dest:                      %#p\n"
; 342  : 		"    len:                       %#x\n", 
; 343  : 		pBufCtl->pDataStart, 
; 344  : 		blkHdr.cbSize,
; 345  : 		pXStart,
; 346  : 		*ppDest,
; 347  : 		cbXLen);

	mov	rdx, QWORD PTR cbXLen$[rsp]
	mov	QWORD PTR [rsp+56], rdx
	mov	rax, QWORD PTR ppDest$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR pXStart$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR blkHdr$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR pBufCtl$[rsp]
	mov	r9, QWORD PTR [r9+24]
	lea	r8, OFFSET FLAT:??_C@_0NE@DJKLCAIL@CB?5?9?5CBXtractFromStart?5?9?5Xtracti@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 348  : 
; 349  : 	// Return the data, accounting for the fact that it may wrap around
; 350  : 	// the buffer end.
; 351  : 	//
; 352  : 	// cbContiguous = length of the contiguous data area from pXStart up
; 353  : 	// to the buffer end.
; 354  : 	//
; 355  : 	SIZE_T cbContiguous = pBufCtl->pBufEndAddr - pXStart;

	mov	rax, QWORD PTR pBufCtl$[rsp]
	mov	rcx, QWORD PTR pXStart$[rsp]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, rcx
	mov	QWORD PTR cbContiguous$[rsp], rax

; 356  : 	SSIZE_T block2ndChunkLen = cbXLen - cbContiguous;

	mov	rcx, QWORD PTR cbContiguous$[rsp]
	mov	rax, QWORD PTR cbXLen$[rsp]
	sub	rax, rcx
	mov	QWORD PTR block2ndChunkLen$[rsp], rax

; 357  : 
; 358  : 	// Note: if there are other data blocks before the buffer end 
; 359  : 	// address, cbContiguous > cbXLen for sure, because we have already
; 360  : 	// limited cbXLen inside the current block.
; 361  : 
; 362  : 	if (block2ndChunkLen > 0) {

	cmp	QWORD PTR block2ndChunkLen$[rsp], 0
	jle	SHORT $LN4@CBXtractFr

; 363  : 
; 364  : 		// The data wraps around => two data tansfers.
; 365  : 		//
; 366  : 		RtlCopyMemory(*ppDest, pXStart, cbContiguous);

	mov	rdi, QWORD PTR ppDest$[rsp]
	mov	rdi, QWORD PTR [rdi]
	mov	rsi, QWORD PTR pXStart$[rsp]
	mov	rcx, QWORD PTR cbContiguous$[rsp]
	rep movsb

; 367  : 		RtlCopyMemory((*ppDest) + cbContiguous, pBufCtl->pBufStartAddr,
; 368  : 			block2ndChunkLen);

	mov	rdi, QWORD PTR ppDest$[rsp]
	mov	rdi, QWORD PTR [rdi]
	add	rdi, QWORD PTR cbContiguous$[rsp]
	mov	rsi, QWORD PTR pBufCtl$[rsp]
	mov	rsi, QWORD PTR [rsi]
	mov	rcx, QWORD PTR block2ndChunkLen$[rsp]
	rep movsb

; 369  : 	} else {

	jmp	SHORT $LN3@CBXtractFr
$LN4@CBXtractFr:

; 370  : 		RtlCopyMemory(*ppDest, pXStart, cbXLen);

	mov	rdi, QWORD PTR ppDest$[rsp]
	mov	rdi, QWORD PTR [rdi]
	mov	rsi, QWORD PTR pXStart$[rsp]
	mov	rcx, QWORD PTR cbXLen$[rsp]
	rep movsb
$LN3@CBXtractFr:

; 371  : 	}
; 372  : 	*pcbXtractOffset += cbXLen;

	mov	rcx, QWORD PTR pcbXtractOffset$[rsp]
	mov	rcx, QWORD PTR [rcx]
	add	rcx, QWORD PTR cbXLen$[rsp]
	mov	rax, QWORD PTR pcbXtractOffset$[rsp]
	mov	QWORD PTR [rax], rcx

; 373  : 	*ppDest += cbXLen;

	mov	rcx, QWORD PTR ppDest$[rsp]
	mov	rcx, QWORD PTR [rcx]
	add	rcx, QWORD PTR cbXLen$[rsp]
	mov	rax, QWORD PTR ppDest$[rsp]
	mov	QWORD PTR [rax], rcx

; 374  : 	*pcbDestFree -= cbXLen;

	mov	rcx, QWORD PTR pcbDestFree$[rsp]
	mov	rax, QWORD PTR cbXLen$[rsp]
	mov	rcx, QWORD PTR [rcx]
	sub	rcx, rax
	mov	rax, QWORD PTR pcbDestFree$[rsp]
	mov	QWORD PTR [rax], rcx

; 375  : 	if (pcbBytesToRead != NULL) *pcbBytesToRead -= cbXLen;

	cmp	QWORD PTR pcbBytesToRead$[rsp], 0
	je	SHORT $LN2@CBXtractFr
	mov	rcx, QWORD PTR pcbBytesToRead$[rsp]
	mov	rax, QWORD PTR cbXLen$[rsp]
	mov	rcx, QWORD PTR [rcx]
	sub	rcx, rax
	mov	rax, QWORD PTR pcbBytesToRead$[rsp]
	mov	QWORD PTR [rax], rcx
$LN2@CBXtractFr:

; 376  : 	if (pcbBytesRead != NULL) *pcbBytesRead = cbXLen;

	cmp	QWORD PTR pcbBytesRead$[rsp], 0
	je	SHORT $LN1@CBXtractFr
	mov	rcx, QWORD PTR pcbBytesRead$[rsp]
	mov	rax, QWORD PTR cbXLen$[rsp]
	mov	QWORD PTR [rcx], rax
$LN1@CBXtractFr:

; 377  : 	return STATUS_SUCCESS;

	xor	eax, eax
$LN14@CBXtractFr:

; 378  : }

	add	rsp, 152				; 00000098H
	pop	rdi
	pop	rsi
	ret	0
?CBXtractFromStart@@YAJPEAU_CIRCULAR_BUFFER@@PEA_KPEAPEAD111@Z ENDP ; CBXtractFromStart
_TEXT	ENDS
PUBLIC	?CBStore@@YAJPEAU_CIRCULAR_BUFFER@@PEAPEADPEA_K22@Z ; CBStore
;	COMDAT pdata
pdata	SEGMENT
$pdata$?CBStore@@YAJPEAU_CIRCULAR_BUFFER@@PEAPEADPEA_K22@Z DD imagerel $LN14
	DD	imagerel $LN14+706
	DD	imagerel $unwind$?CBStore@@YAJPEAU_CIRCULAR_BUFFER@@PEAPEADPEA_K22@Z
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?CBStore@@YAJPEAU_CIRCULAR_BUFFER@@PEAPEADPEA_K22@Z DD 041d01H
	DD	013011dH
	DD	060157016H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT ?CBStore@@YAJPEAU_CIRCULAR_BUFFER@@PEAPEADPEA_K22@Z
_TEXT	SEGMENT
cbMaxStoreLen$ = 64
pHdr$ = 72
curBlockHdr$ = 80
block2ndChunkLen$ = 88
cbStoreLen$ = 96
pStoreAddr$ = 104
pHdrVar$ = 112
cbContiguous$ = 120
i$28622 = 128
tv85 = 136
pBuf$ = 176
ppData$ = 184
pcbLen$ = 192
pcbOffset$ = 200
pcbBytesStored$ = 208
?CBStore@@YAJPEAU_CIRCULAR_BUFFER@@PEAPEADPEA_K22@Z PROC ; CBStore, COMDAT

; 200  : {

$LN14:
	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	sub	rsp, 152				; 00000098H

; 201  : 	if (CBDataBufferEmpty(pBuf)) return STATUS_NO_MEMORY;

	mov	rcx, QWORD PTR pBuf$[rsp]
	call	?CBDataBufferEmpty@@YAEPEAU_CIRCULAR_BUFFER@@@Z ; CBDataBufferEmpty
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@CBStore
	mov	eax, -1073741801			; ffffffffc0000017H
	jmp	$LN10@CBStore
$LN9@CBStore:

; 202  : 
; 203  : 	CB_BLOCK_HEADER curBlockHdr;
; 204  : 
; 205  : 	// Extract the current block header. Advance a pointer into
; 206  : 	// the buffer with CBMovePtrForward, because the header can cross
; 207  : 	// the buffer end.
; 208  : 	//
; 209  : 	PCHAR pHdrVar = (PCHAR) &curBlockHdr;

	lea	rax, QWORD PTR curBlockHdr$[rsp]
	mov	QWORD PTR pHdrVar$[rsp], rax

; 210  : 	PCHAR pHdr = pBuf->pCurrentBlock;

	mov	rax, QWORD PTR pBuf$[rsp]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR pHdr$[rsp], rax

; 211  : 	for (INT i = 0; i < sizeof curBlockHdr; i++) {

	mov	DWORD PTR i$28622[rsp], 0
	jmp	SHORT $LN8@CBStore
$LN7@CBStore:
	mov	eax, DWORD PTR i$28622[rsp]
	add	eax, 1
	mov	DWORD PTR i$28622[rsp], eax
$LN8@CBStore:
	movsxd	rax, DWORD PTR i$28622[rsp]
	cmp	rax, 8
	jae	SHORT $LN6@CBStore

; 212  : 		*(pHdrVar + i) = *pHdr;

	movsxd	rdx, DWORD PTR i$28622[rsp]
	mov	rcx, QWORD PTR pHdrVar$[rsp]
	mov	rax, QWORD PTR pHdr$[rsp]
	movzx	eax, BYTE PTR [rax]
	mov	BYTE PTR [rcx+rdx], al

; 213  : 		CBMovePtrForward(pBuf, &pHdr, 1);

	mov	r8d, 1
	lea	rdx, QWORD PTR pHdr$[rsp]
	mov	rcx, QWORD PTR pBuf$[rsp]
	call	?CBMovePtrForward@@YAJPEAU_CIRCULAR_BUFFER@@PEAPEAD_K@Z ; CBMovePtrForward

; 214  : 	}

	jmp	SHORT $LN7@CBStore
$LN6@CBStore:

; 215  : 
; 216  : 	if (*pcbOffset >= curBlockHdr.cbSize) 

	mov	rcx, QWORD PTR pcbOffset$[rsp]
	mov	rax, QWORD PTR curBlockHdr$[rsp]
	cmp	QWORD PTR [rcx], rax
	jb	SHORT $LN5@CBStore

; 217  : 		return STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; ffffffffc000000dH
	jmp	$LN10@CBStore
$LN5@CBStore:

; 218  : 	// Compute the store address skipping the header and accounting for
; 219  : 	// the offset. Use CBMovePtrForward because we might be crossing
; 220  : 	// the buffer end.
; 221  : 	//
; 222  : 	PCHAR pStoreAddr = pBuf->pCurrentBlock;

	mov	rax, QWORD PTR pBuf$[rsp]
	mov	rax, QWORD PTR [rax+40]
	mov	QWORD PTR pStoreAddr$[rsp], rax

; 223  : 	CBMovePtrForward(pBuf, &pStoreAddr, sizeof (CB_BLOCK_HEADER) +
; 224  : 		*pcbOffset);

	mov	r8, QWORD PTR pcbOffset$[rsp]
	mov	r8, QWORD PTR [r8]
	add	r8, 8
	lea	rdx, QWORD PTR pStoreAddr$[rsp]
	mov	rcx, QWORD PTR pBuf$[rsp]
	call	?CBMovePtrForward@@YAJPEAU_CIRCULAR_BUFFER@@PEAPEAD_K@Z ; CBMovePtrForward

; 225  : 	SIZE_T cbMaxStoreLen = curBlockHdr.cbSize - *pcbOffset;

	mov	rcx, QWORD PTR pcbOffset$[rsp]
	mov	rcx, QWORD PTR [rcx]
	mov	rax, QWORD PTR curBlockHdr$[rsp]
	sub	rax, rcx
	mov	QWORD PTR cbMaxStoreLen$[rsp], rax

; 226  : 	SIZE_T cbStoreLen = 
; 227  : 		*pcbLen < cbMaxStoreLen ? *pcbLen : cbMaxStoreLen ;

	mov	rcx, QWORD PTR pcbLen$[rsp]
	mov	rax, QWORD PTR cbMaxStoreLen$[rsp]
	cmp	QWORD PTR [rcx], rax
	jae	SHORT $LN12@CBStore
	mov	rax, QWORD PTR pcbLen$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR tv85[rsp], rax
	jmp	SHORT $LN13@CBStore
$LN12@CBStore:
	mov	rax, QWORD PTR cbMaxStoreLen$[rsp]
	mov	QWORD PTR tv85[rsp], rax
$LN13@CBStore:
	mov	rax, QWORD PTR tv85[rsp]
	mov	QWORD PTR cbStoreLen$[rsp], rax

; 228  : 
; 229  : 
; 230  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 231  : 		     "CB - CBStore - Storing.\n"
; 232  : 	         "    Current block start:       %#p\n"
; 233  : 			 "    length (not counting hdr): %#x\n"
; 234  : 			 "    store addr:                %#p\n"
; 235  : 			 "    store length:              %#x\n"
; 236  : 			 "    src addr:                  %#p\n",
; 237  : 		pBuf->pCurrentBlock,
; 238  : 		curBlockHdr.cbSize, 
; 239  : 		pStoreAddr, 
; 240  : 		cbStoreLen, 
; 241  : 		*ppData);

	mov	rax, QWORD PTR ppData$[rsp]
	mov	rax, QWORD PTR [rax]
	mov	QWORD PTR [rsp+56], rax
	mov	rax, QWORD PTR cbStoreLen$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	rax, QWORD PTR pStoreAddr$[rsp]
	mov	QWORD PTR [rsp+40], rax
	mov	rax, QWORD PTR curBlockHdr$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR pBuf$[rsp]
	mov	r9, QWORD PTR [r9+40]
	lea	r8, OFFSET FLAT:??_C@_0MI@BMMJCGO@CB?5?9?5CBStore?5?9?5Storing?4?6?5?5?5?5Curr@FNODOBFM@
	xor	edx, edx
	mov	ecx, 77					; 0000004dH
	call	QWORD PTR __imp_DbgPrintEx

; 242  : 
; 243  : 	// Store the data, accounting for the fact that it may wrap around
; 244  : 	// the buffer end.
; 245  : 	//
; 246  : 	// cbContiguous = length of the contiguous data area from pStoreAddr
; 247  : 	// up to the buffer end.
; 248  : 	//
; 249  : 	SIZE_T cbContiguous = pBuf->pBufEndAddr - pStoreAddr;

	mov	rax, QWORD PTR pBuf$[rsp]
	mov	rcx, QWORD PTR pStoreAddr$[rsp]
	mov	rax, QWORD PTR [rax+8]
	sub	rax, rcx
	mov	QWORD PTR cbContiguous$[rsp], rax

; 250  : 	SSIZE_T block2ndChunkLen = cbStoreLen - cbContiguous;

	mov	rcx, QWORD PTR cbContiguous$[rsp]
	mov	rax, QWORD PTR cbStoreLen$[rsp]
	sub	rax, rcx
	mov	QWORD PTR block2ndChunkLen$[rsp], rax

; 251  : 
; 252  : 	// Note: if there are other data blocks before the buffer end 
; 253  : 	// address, cbContiguous > cbStoreLen for sure, because we have 
; 254  : 	// already limited cbStoreLen inside the current block.
; 255  : 
; 256  : 	if (block2ndChunkLen > 0) {

	cmp	QWORD PTR block2ndChunkLen$[rsp], 0
	jle	SHORT $LN4@CBStore

; 257  : 
; 258  : 		// The data wraps around => two data tansfers.
; 259  : 		//
; 260  : 		RtlCopyMemory(pStoreAddr, *ppData, cbContiguous);

	mov	rsi, QWORD PTR ppData$[rsp]
	mov	rdi, QWORD PTR pStoreAddr$[rsp]
	mov	rsi, QWORD PTR [rsi]
	mov	rcx, QWORD PTR cbContiguous$[rsp]
	rep movsb

; 261  : 		RtlCopyMemory(pBuf->pBufStartAddr, (*ppData) + cbContiguous,
; 262  : 			block2ndChunkLen);

	mov	rsi, QWORD PTR ppData$[rsp]
	mov	rsi, QWORD PTR [rsi]
	add	rsi, QWORD PTR cbContiguous$[rsp]
	mov	rdi, QWORD PTR pBuf$[rsp]
	mov	rdi, QWORD PTR [rdi]
	mov	rcx, QWORD PTR block2ndChunkLen$[rsp]
	rep movsb

; 263  : 	} else {

	jmp	SHORT $LN3@CBStore
$LN4@CBStore:

; 264  : 		RtlCopyMemory(pStoreAddr, *ppData, cbStoreLen);

	mov	rsi, QWORD PTR ppData$[rsp]
	mov	rdi, QWORD PTR pStoreAddr$[rsp]
	mov	rsi, QWORD PTR [rsi]
	mov	rcx, QWORD PTR cbStoreLen$[rsp]
	rep movsb
$LN3@CBStore:

; 265  : 	}
; 266  : 	*ppData += cbStoreLen;

	mov	rcx, QWORD PTR ppData$[rsp]
	mov	rcx, QWORD PTR [rcx]
	add	rcx, QWORD PTR cbStoreLen$[rsp]
	mov	rax, QWORD PTR ppData$[rsp]
	mov	QWORD PTR [rax], rcx

; 267  : 	*pcbLen -= cbStoreLen;

	mov	rcx, QWORD PTR pcbLen$[rsp]
	mov	rax, QWORD PTR cbStoreLen$[rsp]
	mov	rcx, QWORD PTR [rcx]
	sub	rcx, rax
	mov	rax, QWORD PTR pcbLen$[rsp]
	mov	QWORD PTR [rax], rcx

; 268  : 	*pcbOffset += cbStoreLen;

	mov	rcx, QWORD PTR pcbOffset$[rsp]
	mov	rcx, QWORD PTR [rcx]
	add	rcx, QWORD PTR cbStoreLen$[rsp]
	mov	rax, QWORD PTR pcbOffset$[rsp]
	mov	QWORD PTR [rax], rcx

; 269  : 	if (pcbBytesStored != NULL) *pcbBytesStored = cbStoreLen;

	cmp	QWORD PTR pcbBytesStored$[rsp], 0
	je	SHORT $LN2@CBStore
	mov	rcx, QWORD PTR pcbBytesStored$[rsp]
	mov	rax, QWORD PTR cbStoreLen$[rsp]
	mov	QWORD PTR [rcx], rax
$LN2@CBStore:

; 270  : 
; 271  : 	if (cbStoreLen < *pcbLen) return CB_STATUS_WARN_DATA_LOST;

	mov	rax, QWORD PTR pcbLen$[rsp]
	mov	rax, QWORD PTR [rax]
	cmp	QWORD PTR cbStoreLen$[rsp], rax
	jae	SHORT $LN1@CBStore
	mov	eax, -1610612735			; ffffffffa0000001H
	jmp	SHORT $LN10@CBStore
$LN1@CBStore:

; 272  : 
; 273  : 	return STATUS_SUCCESS;

	xor	eax, eax
$LN10@CBStore:

; 274  : }

	add	rsp, 152				; 00000098H
	pop	rdi
	pop	rsi
	ret	0
?CBStore@@YAJPEAU_CIRCULAR_BUFFER@@PEAPEADPEA_K22@Z ENDP ; CBStore
END
