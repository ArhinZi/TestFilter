; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.207 

	TITLE	b:\programm\wntsys\testfilter\release\1_1\source\driver\drvmain.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@NCBACJCG@IRP_MN_QUERY_POWER?$AA@	; `string'
PUBLIC	??_C@_0BB@MOFGLKAE@IRP_MN_SET_POWER?$AA@	; `string'
PUBLIC	??_C@_0BG@HJCHODFP@IRP_MN_POWER_SEQUENCE?$AA@	; `string'
PUBLIC	??_C@_0BB@KEEBPEDL@IRP_MN_WAIT_WAKE?$AA@	; `string'
PUBLIC	??_C@_0BI@JJMGKCHF@IRP_MN_SURPRISE_REMOVAL?$AA@	; `string'
PUBLIC	??_C@_0CB@EEGIBKLH@IRP_MN_DEVICE_USAGE_NOTIFICATION@ ; `string'
PUBLIC	??_C@_0BN@FKLLPNEA@IRP_MN_QUERY_BUS_INFORMATION?$AA@ ; `string'
PUBLIC	??_C@_0BO@CLJGNPDL@IRP_MN_QUERY_PNP_DEVICE_STATE?$AA@ ; `string'
PUBLIC	??_C@_0BA@MPOLLMHD@IRP_MN_QUERY_ID?$AA@		; `string'
PUBLIC	??_C@_0BA@JCIHPHAO@IRP_MN_SET_LOCK?$AA@		; `string'
PUBLIC	??_C@_0N@KBDCJDGM@IRP_MN_EJECT?$AA@		; `string'
PUBLIC	??_C@_0BE@MNGKLJHO@IRP_MN_WRITE_CONFIG?$AA@	; `string'
PUBLIC	??_C@_0BD@KCLCONNF@IRP_MN_READ_CONFIG?$AA@	; `string'
PUBLIC	??_C@_07CIFAGBMG@unknown?$AA@			; `string'
PUBLIC	??_C@_0CE@FFGNIHMK@IRP_MN_FILTER_RESOURCE_REQUIREME@ ; `string'
PUBLIC	??_C@_0BJ@KBKMPMKH@IRP_MN_QUERY_DEVICE_TEXT?$AA@ ; `string'
PUBLIC	??_C@_0CD@MPPOHAEF@IRP_MN_QUERY_RESOURCE_REQUIREMEN@ ; `string'
PUBLIC	??_C@_0BH@BAILDNEP@IRP_MN_QUERY_RESOURCES?$AA@	; `string'
PUBLIC	??_C@_0BK@FNPJPCCF@IRP_MN_QUERY_CAPABILITIES?$AA@ ; `string'
PUBLIC	??_C@_0BH@NJFMIPMO@IRP_MN_QUERY_INTERFACE?$AA@	; `string'
PUBLIC	??_C@_0BO@EDNJKJCF@IRP_MN_QUERY_DEVICE_RELATIONS?$AA@ ; `string'
PUBLIC	??_C@_0BK@IHBBLJPI@IRP_MN_CANCEL_STOP_DEVICE?$AA@ ; `string'
PUBLIC	??_C@_0BJ@DBBODAKD@IRP_MN_QUERY_STOP_DEVICE?$AA@ ; `string'
PUBLIC	??_C@_0BD@OKOEKPNG@IRP_MN_STOP_DEVICE?$AA@	; `string'
PUBLIC	??_C@_0BM@NHOBKHFC@IRP_MN_CANCEL_REMOVE_DEVICE?$AA@ ; `string'
PUBLIC	??_C@_0BF@CIDCHGNK@IRP_MN_REMOVE_DEVICE?$AA@	; `string'
PUBLIC	??_C@_0BL@BKMKKOEG@IRP_MN_QUERY_REMOVE_DEVICE?$AA@ ; `string'
PUBLIC	??_C@_0BE@LNOGIHJB@IRP_MN_START_DEVICE?$AA@	; `string'
PUBLIC	??_C@_0L@EACGAIIF@IRP_MJ_PNP?$AA@		; `string'
PUBLIC	??_C@_0BB@MFPKCKFI@IRP_MJ_SET_QUOTA?$AA@	; `string'
PUBLIC	??_C@_0BD@MDBGANBO@IRP_MJ_QUERY_QUOTA?$AA@	; `string'
PUBLIC	??_C@_0BF@HOMHCDN@IRP_MJ_DEVICE_CHANGE?$AA@	; `string'
PUBLIC	??_C@_0BG@JHIMGJML@IRP_MJ_SYSTEM_CONTROL?$AA@	; `string'
PUBLIC	??_C@_0N@BGEEMFOO@IRP_MJ_POWER?$AA@		; `string'
PUBLIC	??_C@_0BE@MPINJCAP@IRP_MJ_SET_SECURITY?$AA@	; `string'
PUBLIC	??_C@_0BG@MIODHPEN@IRP_MJ_QUERY_SECURITY?$AA@	; `string'
PUBLIC	??_C@_0BH@CKPKPKHL@IRP_MJ_CREATE_MAILSLOT?$AA@	; `string'
PUBLIC	??_C@_0P@JJLCIODE@IRP_MJ_CLEANUP?$AA@		; `string'
PUBLIC	??_C@_0BE@LODBBEFP@IRP_MJ_LOCK_CONTROL?$AA@	; `string'
PUBLIC	??_C@_0BA@CDMDNOAC@IRP_MJ_SHUTDOWN?$AA@		; `string'
PUBLIC	??_C@_0BP@ODEFGAEK@IRP_MJ_INTERNAL_DEVICE_CONTROL?$AA@ ; `string'
PUBLIC	??_C@_0BG@HAFCIBGJ@IRP_MJ_DEVICE_CONTROL?$AA@	; `string'
PUBLIC	??_C@_0BL@MFHGBIDL@IRP_MJ_FILE_SYSTEM_CONTROL?$AA@ ; `string'
PUBLIC	??_C@_0BJ@NCGIANAN@IRP_MJ_DIRECTORY_CONTROL?$AA@ ; `string'
PUBLIC	??_C@_0BO@CJJMMMF@IRP_MJ_SET_VOLUME_INFORMATION?$AA@ ; `string'
PUBLIC	??_C@_0CA@FDGJPBOD@IRP_MJ_QUERY_VOLUME_INFORMATION?$AA@ ; `string'
PUBLIC	??_C@_0BF@CBDAKCPM@IRP_MJ_FLUSH_BUFFERS?$AA@	; `string'
PUBLIC	??_C@_0O@FPNILENL@IRP_MJ_SET_EA?$AA@		; `string'
PUBLIC	??_C@_0BA@LFPMCNA@IRP_MJ_QUERY_EA?$AA@		; `string'
PUBLIC	??_C@_0BH@GNAPBNMO@IRP_MJ_SET_INFORMATION?$AA@	; `string'
PUBLIC	??_C@_0BJ@FPMLIFJJ@IRP_MJ_QUERY_INFORMATION?$AA@ ; `string'
PUBLIC	??_C@_0N@DLJAMLBI@IRP_MJ_WRITE?$AA@		; `string'
PUBLIC	??_C@_0M@LJKCMGIA@IRP_MJ_READ?$AA@		; `string'
PUBLIC	??_C@_0N@FMCDOLCP@IRP_MJ_CLOSE?$AA@		; `string'
PUBLIC	??_C@_0BJ@MMKIHFHH@IRP_MJ_CREATE_NAMED_PIPE?$AA@ ; `string'
PUBLIC	??_C@_0O@LCBLIIOL@IRP_MJ_CREATE?$AA@		; `string'
PUBLIC	?pszMajorFunctionV@@3PAPADA			; pszMajorFunctionV
PUBLIC	?pszPnpMinorFunctionV@@3PAPADA			; pszPnpMinorFunctionV
PUBLIC	?pszPowerMinorFunctionV@@3PAPADA		; pszPowerMinorFunctionV
_BSS	SEGMENT
_DevNumber DD	01H DUP (?)
_pMastDevExt DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BD@NCBACJCG@IRP_MN_QUERY_POWER?$AA@
CONST	SEGMENT
??_C@_0BD@NCBACJCG@IRP_MN_QUERY_POWER?$AA@ DB 'IRP_MN_QUERY_POWER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MOFGLKAE@IRP_MN_SET_POWER?$AA@
CONST	SEGMENT
??_C@_0BB@MOFGLKAE@IRP_MN_SET_POWER?$AA@ DB 'IRP_MN_SET_POWER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HJCHODFP@IRP_MN_POWER_SEQUENCE?$AA@
CONST	SEGMENT
??_C@_0BG@HJCHODFP@IRP_MN_POWER_SEQUENCE?$AA@ DB 'IRP_MN_POWER_SEQUENCE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KEEBPEDL@IRP_MN_WAIT_WAKE?$AA@
CONST	SEGMENT
??_C@_0BB@KEEBPEDL@IRP_MN_WAIT_WAKE?$AA@ DB 'IRP_MN_WAIT_WAKE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@JJMGKCHF@IRP_MN_SURPRISE_REMOVAL?$AA@
CONST	SEGMENT
??_C@_0BI@JJMGKCHF@IRP_MN_SURPRISE_REMOVAL?$AA@ DB 'IRP_MN_SURPRISE_REMOV'
	DB	'AL', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@EEGIBKLH@IRP_MN_DEVICE_USAGE_NOTIFICATION@
CONST	SEGMENT
??_C@_0CB@EEGIBKLH@IRP_MN_DEVICE_USAGE_NOTIFICATION@ DB 'IRP_MN_DEVICE_US'
	DB	'AGE_NOTIFICATION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@FKLLPNEA@IRP_MN_QUERY_BUS_INFORMATION?$AA@
CONST	SEGMENT
??_C@_0BN@FKLLPNEA@IRP_MN_QUERY_BUS_INFORMATION?$AA@ DB 'IRP_MN_QUERY_BUS'
	DB	'_INFORMATION', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CLJGNPDL@IRP_MN_QUERY_PNP_DEVICE_STATE?$AA@
CONST	SEGMENT
??_C@_0BO@CLJGNPDL@IRP_MN_QUERY_PNP_DEVICE_STATE?$AA@ DB 'IRP_MN_QUERY_PN'
	DB	'P_DEVICE_STATE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MPOLLMHD@IRP_MN_QUERY_ID?$AA@
CONST	SEGMENT
??_C@_0BA@MPOLLMHD@IRP_MN_QUERY_ID?$AA@ DB 'IRP_MN_QUERY_ID', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JCIHPHAO@IRP_MN_SET_LOCK?$AA@
CONST	SEGMENT
??_C@_0BA@JCIHPHAO@IRP_MN_SET_LOCK?$AA@ DB 'IRP_MN_SET_LOCK', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KBDCJDGM@IRP_MN_EJECT?$AA@
CONST	SEGMENT
??_C@_0N@KBDCJDGM@IRP_MN_EJECT?$AA@ DB 'IRP_MN_EJECT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MNGKLJHO@IRP_MN_WRITE_CONFIG?$AA@
CONST	SEGMENT
??_C@_0BE@MNGKLJHO@IRP_MN_WRITE_CONFIG?$AA@ DB 'IRP_MN_WRITE_CONFIG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KCLCONNF@IRP_MN_READ_CONFIG?$AA@
CONST	SEGMENT
??_C@_0BD@KCLCONNF@IRP_MN_READ_CONFIG?$AA@ DB 'IRP_MN_READ_CONFIG', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07CIFAGBMG@unknown?$AA@
CONST	SEGMENT
??_C@_07CIFAGBMG@unknown?$AA@ DB 'unknown', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FFGNIHMK@IRP_MN_FILTER_RESOURCE_REQUIREME@
CONST	SEGMENT
??_C@_0CE@FFGNIHMK@IRP_MN_FILTER_RESOURCE_REQUIREME@ DB 'IRP_MN_FILTER_RE'
	DB	'SOURCE_REQUIREMENTS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@KBKMPMKH@IRP_MN_QUERY_DEVICE_TEXT?$AA@
CONST	SEGMENT
??_C@_0BJ@KBKMPMKH@IRP_MN_QUERY_DEVICE_TEXT?$AA@ DB 'IRP_MN_QUERY_DEVICE_'
	DB	'TEXT', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@MPPOHAEF@IRP_MN_QUERY_RESOURCE_REQUIREMEN@
CONST	SEGMENT
??_C@_0CD@MPPOHAEF@IRP_MN_QUERY_RESOURCE_REQUIREMEN@ DB 'IRP_MN_QUERY_RES'
	DB	'OURCE_REQUIREMENTS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BAILDNEP@IRP_MN_QUERY_RESOURCES?$AA@
CONST	SEGMENT
??_C@_0BH@BAILDNEP@IRP_MN_QUERY_RESOURCES?$AA@ DB 'IRP_MN_QUERY_RESOURCES'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@FNPJPCCF@IRP_MN_QUERY_CAPABILITIES?$AA@
CONST	SEGMENT
??_C@_0BK@FNPJPCCF@IRP_MN_QUERY_CAPABILITIES?$AA@ DB 'IRP_MN_QUERY_CAPABI'
	DB	'LITIES', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@NJFMIPMO@IRP_MN_QUERY_INTERFACE?$AA@
CONST	SEGMENT
??_C@_0BH@NJFMIPMO@IRP_MN_QUERY_INTERFACE?$AA@ DB 'IRP_MN_QUERY_INTERFACE'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EDNJKJCF@IRP_MN_QUERY_DEVICE_RELATIONS?$AA@
CONST	SEGMENT
??_C@_0BO@EDNJKJCF@IRP_MN_QUERY_DEVICE_RELATIONS?$AA@ DB 'IRP_MN_QUERY_DE'
	DB	'VICE_RELATIONS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@IHBBLJPI@IRP_MN_CANCEL_STOP_DEVICE?$AA@
CONST	SEGMENT
??_C@_0BK@IHBBLJPI@IRP_MN_CANCEL_STOP_DEVICE?$AA@ DB 'IRP_MN_CANCEL_STOP_'
	DB	'DEVICE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DBBODAKD@IRP_MN_QUERY_STOP_DEVICE?$AA@
CONST	SEGMENT
??_C@_0BJ@DBBODAKD@IRP_MN_QUERY_STOP_DEVICE?$AA@ DB 'IRP_MN_QUERY_STOP_DE'
	DB	'VICE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OKOEKPNG@IRP_MN_STOP_DEVICE?$AA@
CONST	SEGMENT
??_C@_0BD@OKOEKPNG@IRP_MN_STOP_DEVICE?$AA@ DB 'IRP_MN_STOP_DEVICE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@NHOBKHFC@IRP_MN_CANCEL_REMOVE_DEVICE?$AA@
CONST	SEGMENT
??_C@_0BM@NHOBKHFC@IRP_MN_CANCEL_REMOVE_DEVICE?$AA@ DB 'IRP_MN_CANCEL_REM'
	DB	'OVE_DEVICE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CIDCHGNK@IRP_MN_REMOVE_DEVICE?$AA@
CONST	SEGMENT
??_C@_0BF@CIDCHGNK@IRP_MN_REMOVE_DEVICE?$AA@ DB 'IRP_MN_REMOVE_DEVICE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@BKMKKOEG@IRP_MN_QUERY_REMOVE_DEVICE?$AA@
CONST	SEGMENT
??_C@_0BL@BKMKKOEG@IRP_MN_QUERY_REMOVE_DEVICE?$AA@ DB 'IRP_MN_QUERY_REMOV'
	DB	'E_DEVICE', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LNOGIHJB@IRP_MN_START_DEVICE?$AA@
CONST	SEGMENT
??_C@_0BE@LNOGIHJB@IRP_MN_START_DEVICE?$AA@ DB 'IRP_MN_START_DEVICE', 00H ; `string'
CONST	ENDS
_DATA	SEGMENT
?pszMajorFunctionV@@3PAPADA DD FLAT:??_C@_0O@LCBLIIOL@IRP_MJ_CREATE?$AA@ ; pszMajorFunctionV
	DD	FLAT:??_C@_0BJ@MMKIHFHH@IRP_MJ_CREATE_NAMED_PIPE?$AA@
	DD	FLAT:??_C@_0N@FMCDOLCP@IRP_MJ_CLOSE?$AA@
	DD	FLAT:??_C@_0M@LJKCMGIA@IRP_MJ_READ?$AA@
	DD	FLAT:??_C@_0N@DLJAMLBI@IRP_MJ_WRITE?$AA@
	DD	FLAT:??_C@_0BJ@FPMLIFJJ@IRP_MJ_QUERY_INFORMATION?$AA@
	DD	FLAT:??_C@_0BH@GNAPBNMO@IRP_MJ_SET_INFORMATION?$AA@
	DD	FLAT:??_C@_0BA@LFPMCNA@IRP_MJ_QUERY_EA?$AA@
	DD	FLAT:??_C@_0O@FPNILENL@IRP_MJ_SET_EA?$AA@
	DD	FLAT:??_C@_0BF@CBDAKCPM@IRP_MJ_FLUSH_BUFFERS?$AA@
	DD	FLAT:??_C@_0CA@FDGJPBOD@IRP_MJ_QUERY_VOLUME_INFORMATION?$AA@
	DD	FLAT:??_C@_0BO@CJJMMMF@IRP_MJ_SET_VOLUME_INFORMATION?$AA@
	DD	FLAT:??_C@_0BJ@NCGIANAN@IRP_MJ_DIRECTORY_CONTROL?$AA@
	DD	FLAT:??_C@_0BL@MFHGBIDL@IRP_MJ_FILE_SYSTEM_CONTROL?$AA@
	DD	FLAT:??_C@_0BG@HAFCIBGJ@IRP_MJ_DEVICE_CONTROL?$AA@
	DD	FLAT:??_C@_0BP@ODEFGAEK@IRP_MJ_INTERNAL_DEVICE_CONTROL?$AA@
	DD	FLAT:??_C@_0BA@CDMDNOAC@IRP_MJ_SHUTDOWN?$AA@
	DD	FLAT:??_C@_0BE@LODBBEFP@IRP_MJ_LOCK_CONTROL?$AA@
	DD	FLAT:??_C@_0P@JJLCIODE@IRP_MJ_CLEANUP?$AA@
	DD	FLAT:??_C@_0BH@CKPKPKHL@IRP_MJ_CREATE_MAILSLOT?$AA@
	DD	FLAT:??_C@_0BG@MIODHPEN@IRP_MJ_QUERY_SECURITY?$AA@
	DD	FLAT:??_C@_0BE@MPINJCAP@IRP_MJ_SET_SECURITY?$AA@
	DD	FLAT:??_C@_0N@BGEEMFOO@IRP_MJ_POWER?$AA@
	DD	FLAT:??_C@_0BG@JHIMGJML@IRP_MJ_SYSTEM_CONTROL?$AA@
	DD	FLAT:??_C@_0BF@HOMHCDN@IRP_MJ_DEVICE_CHANGE?$AA@
	DD	FLAT:??_C@_0BD@MDBGANBO@IRP_MJ_QUERY_QUOTA?$AA@
	DD	FLAT:??_C@_0BB@MFPKCKFI@IRP_MJ_SET_QUOTA?$AA@
	DD	FLAT:??_C@_0L@EACGAIIF@IRP_MJ_PNP?$AA@
?pszPnpMinorFunctionV@@3PAPADA DD FLAT:??_C@_0BE@LNOGIHJB@IRP_MN_START_DEVICE?$AA@ ; pszPnpMinorFunctionV
	DD	FLAT:??_C@_0BL@BKMKKOEG@IRP_MN_QUERY_REMOVE_DEVICE?$AA@
	DD	FLAT:??_C@_0BF@CIDCHGNK@IRP_MN_REMOVE_DEVICE?$AA@
	DD	FLAT:??_C@_0BM@NHOBKHFC@IRP_MN_CANCEL_REMOVE_DEVICE?$AA@
	DD	FLAT:??_C@_0BD@OKOEKPNG@IRP_MN_STOP_DEVICE?$AA@
	DD	FLAT:??_C@_0BJ@DBBODAKD@IRP_MN_QUERY_STOP_DEVICE?$AA@
	DD	FLAT:??_C@_0BK@IHBBLJPI@IRP_MN_CANCEL_STOP_DEVICE?$AA@
	DD	FLAT:??_C@_0BO@EDNJKJCF@IRP_MN_QUERY_DEVICE_RELATIONS?$AA@
	DD	FLAT:??_C@_0BH@NJFMIPMO@IRP_MN_QUERY_INTERFACE?$AA@
	DD	FLAT:??_C@_0BK@FNPJPCCF@IRP_MN_QUERY_CAPABILITIES?$AA@
	DD	FLAT:??_C@_0BH@BAILDNEP@IRP_MN_QUERY_RESOURCES?$AA@
	DD	FLAT:??_C@_0CD@MPPOHAEF@IRP_MN_QUERY_RESOURCE_REQUIREMEN@
	DD	FLAT:??_C@_0BJ@KBKMPMKH@IRP_MN_QUERY_DEVICE_TEXT?$AA@
	DD	FLAT:??_C@_0CE@FFGNIHMK@IRP_MN_FILTER_RESOURCE_REQUIREME@
	DD	FLAT:??_C@_07CIFAGBMG@unknown?$AA@
	DD	FLAT:??_C@_0BD@KCLCONNF@IRP_MN_READ_CONFIG?$AA@
	DD	FLAT:??_C@_0BE@MNGKLJHO@IRP_MN_WRITE_CONFIG?$AA@
	DD	FLAT:??_C@_0N@KBDCJDGM@IRP_MN_EJECT?$AA@
	DD	FLAT:??_C@_0BA@JCIHPHAO@IRP_MN_SET_LOCK?$AA@
	DD	FLAT:??_C@_0BA@MPOLLMHD@IRP_MN_QUERY_ID?$AA@
	DD	FLAT:??_C@_0BO@CLJGNPDL@IRP_MN_QUERY_PNP_DEVICE_STATE?$AA@
	DD	FLAT:??_C@_0BN@FKLLPNEA@IRP_MN_QUERY_BUS_INFORMATION?$AA@
	DD	FLAT:??_C@_0CB@EEGIBKLH@IRP_MN_DEVICE_USAGE_NOTIFICATION@
	DD	FLAT:??_C@_0BI@JJMGKCHF@IRP_MN_SURPRISE_REMOVAL?$AA@
?pszPowerMinorFunctionV@@3PAPADA DD FLAT:??_C@_0BB@KEEBPEDL@IRP_MN_WAIT_WAKE?$AA@ ; pszPowerMinorFunctionV
	DD	FLAT:??_C@_0BG@HJCHODFP@IRP_MN_POWER_SEQUENCE?$AA@
	DD	FLAT:??_C@_0BB@MOFGLKAE@IRP_MN_SET_POWER?$AA@
	DD	FLAT:??_C@_0BD@NCBACJCG@IRP_MN_QUERY_POWER?$AA@
_DATA	ENDS
;	COMDAT ??_C@_0L@EACGAIIF@IRP_MJ_PNP?$AA@
CONST	SEGMENT
??_C@_0L@EACGAIIF@IRP_MJ_PNP?$AA@ DB 'IRP_MJ_PNP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MFPKCKFI@IRP_MJ_SET_QUOTA?$AA@
CONST	SEGMENT
??_C@_0BB@MFPKCKFI@IRP_MJ_SET_QUOTA?$AA@ DB 'IRP_MJ_SET_QUOTA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MDBGANBO@IRP_MJ_QUERY_QUOTA?$AA@
CONST	SEGMENT
??_C@_0BD@MDBGANBO@IRP_MJ_QUERY_QUOTA?$AA@ DB 'IRP_MJ_QUERY_QUOTA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@HOMHCDN@IRP_MJ_DEVICE_CHANGE?$AA@
CONST	SEGMENT
??_C@_0BF@HOMHCDN@IRP_MJ_DEVICE_CHANGE?$AA@ DB 'IRP_MJ_DEVICE_CHANGE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JHIMGJML@IRP_MJ_SYSTEM_CONTROL?$AA@
CONST	SEGMENT
??_C@_0BG@JHIMGJML@IRP_MJ_SYSTEM_CONTROL?$AA@ DB 'IRP_MJ_SYSTEM_CONTROL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BGEEMFOO@IRP_MJ_POWER?$AA@
CONST	SEGMENT
??_C@_0N@BGEEMFOO@IRP_MJ_POWER?$AA@ DB 'IRP_MJ_POWER', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MPINJCAP@IRP_MJ_SET_SECURITY?$AA@
CONST	SEGMENT
??_C@_0BE@MPINJCAP@IRP_MJ_SET_SECURITY?$AA@ DB 'IRP_MJ_SET_SECURITY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@MIODHPEN@IRP_MJ_QUERY_SECURITY?$AA@
CONST	SEGMENT
??_C@_0BG@MIODHPEN@IRP_MJ_QUERY_SECURITY?$AA@ DB 'IRP_MJ_QUERY_SECURITY', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CKPKPKHL@IRP_MJ_CREATE_MAILSLOT?$AA@
CONST	SEGMENT
??_C@_0BH@CKPKPKHL@IRP_MJ_CREATE_MAILSLOT?$AA@ DB 'IRP_MJ_CREATE_MAILSLOT'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JJLCIODE@IRP_MJ_CLEANUP?$AA@
CONST	SEGMENT
??_C@_0P@JJLCIODE@IRP_MJ_CLEANUP?$AA@ DB 'IRP_MJ_CLEANUP', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LODBBEFP@IRP_MJ_LOCK_CONTROL?$AA@
CONST	SEGMENT
??_C@_0BE@LODBBEFP@IRP_MJ_LOCK_CONTROL?$AA@ DB 'IRP_MJ_LOCK_CONTROL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@CDMDNOAC@IRP_MJ_SHUTDOWN?$AA@
CONST	SEGMENT
??_C@_0BA@CDMDNOAC@IRP_MJ_SHUTDOWN?$AA@ DB 'IRP_MJ_SHUTDOWN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@ODEFGAEK@IRP_MJ_INTERNAL_DEVICE_CONTROL?$AA@
CONST	SEGMENT
??_C@_0BP@ODEFGAEK@IRP_MJ_INTERNAL_DEVICE_CONTROL?$AA@ DB 'IRP_MJ_INTERNA'
	DB	'L_DEVICE_CONTROL', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HAFCIBGJ@IRP_MJ_DEVICE_CONTROL?$AA@
CONST	SEGMENT
??_C@_0BG@HAFCIBGJ@IRP_MJ_DEVICE_CONTROL?$AA@ DB 'IRP_MJ_DEVICE_CONTROL', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MFHGBIDL@IRP_MJ_FILE_SYSTEM_CONTROL?$AA@
CONST	SEGMENT
??_C@_0BL@MFHGBIDL@IRP_MJ_FILE_SYSTEM_CONTROL?$AA@ DB 'IRP_MJ_FILE_SYSTEM'
	DB	'_CONTROL', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NCGIANAN@IRP_MJ_DIRECTORY_CONTROL?$AA@
CONST	SEGMENT
??_C@_0BJ@NCGIANAN@IRP_MJ_DIRECTORY_CONTROL?$AA@ DB 'IRP_MJ_DIRECTORY_CON'
	DB	'TROL', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CJJMMMF@IRP_MJ_SET_VOLUME_INFORMATION?$AA@
CONST	SEGMENT
??_C@_0BO@CJJMMMF@IRP_MJ_SET_VOLUME_INFORMATION?$AA@ DB 'IRP_MJ_SET_VOLUM'
	DB	'E_INFORMATION', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FDGJPBOD@IRP_MJ_QUERY_VOLUME_INFORMATION?$AA@
CONST	SEGMENT
??_C@_0CA@FDGJPBOD@IRP_MJ_QUERY_VOLUME_INFORMATION?$AA@ DB 'IRP_MJ_QUERY_'
	DB	'VOLUME_INFORMATION', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@CBDAKCPM@IRP_MJ_FLUSH_BUFFERS?$AA@
CONST	SEGMENT
??_C@_0BF@CBDAKCPM@IRP_MJ_FLUSH_BUFFERS?$AA@ DB 'IRP_MJ_FLUSH_BUFFERS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@FPNILENL@IRP_MJ_SET_EA?$AA@
CONST	SEGMENT
??_C@_0O@FPNILENL@IRP_MJ_SET_EA?$AA@ DB 'IRP_MJ_SET_EA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LFPMCNA@IRP_MJ_QUERY_EA?$AA@
CONST	SEGMENT
??_C@_0BA@LFPMCNA@IRP_MJ_QUERY_EA?$AA@ DB 'IRP_MJ_QUERY_EA', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GNAPBNMO@IRP_MJ_SET_INFORMATION?$AA@
CONST	SEGMENT
??_C@_0BH@GNAPBNMO@IRP_MJ_SET_INFORMATION?$AA@ DB 'IRP_MJ_SET_INFORMATION'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@FPMLIFJJ@IRP_MJ_QUERY_INFORMATION?$AA@
CONST	SEGMENT
??_C@_0BJ@FPMLIFJJ@IRP_MJ_QUERY_INFORMATION?$AA@ DB 'IRP_MJ_QUERY_INFORMA'
	DB	'TION', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DLJAMLBI@IRP_MJ_WRITE?$AA@
CONST	SEGMENT
??_C@_0N@DLJAMLBI@IRP_MJ_WRITE?$AA@ DB 'IRP_MJ_WRITE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@LJKCMGIA@IRP_MJ_READ?$AA@
CONST	SEGMENT
??_C@_0M@LJKCMGIA@IRP_MJ_READ?$AA@ DB 'IRP_MJ_READ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@FMCDOLCP@IRP_MJ_CLOSE?$AA@
CONST	SEGMENT
??_C@_0N@FMCDOLCP@IRP_MJ_CLOSE?$AA@ DB 'IRP_MJ_CLOSE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MMKIHFHH@IRP_MJ_CREATE_NAMED_PIPE?$AA@
CONST	SEGMENT
??_C@_0BJ@MMKIHFHH@IRP_MJ_CREATE_NAMED_PIPE?$AA@ DB 'IRP_MJ_CREATE_NAMED_'
	DB	'PIPE', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LCBLIIOL@IRP_MJ_CREATE?$AA@
CONST	SEGMENT
??_C@_0O@LCBLIIOL@IRP_MJ_CREATE?$AA@ DB 'IRP_MJ_CREATE', 00H ; `string'
CONST	ENDS
PUBLIC	??_C@_0DM@IFCHACPO@FLT?5?9?5DriverEntry?5?9?5Test?5filter?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DL@ENFACENM@?6?6FLT?5?9?5DriverEntry?5?9?5Test?5filte@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0M@DJNHNKNB@May?5?51?52013?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_08HPPDJDFG@11?309?349?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	_DriverEntry@8
EXTRN	__imp__DbgPrintEx:PROC
;	COMDAT ??_C@_0DM@IFCHACPO@FLT?5?9?5DriverEntry?5?9?5Test?5filter?5@FNODOBFM@
; File b:\programm\wntsys\testfilter\release\1_1\source\driver\drvmain.cpp
text$s	SEGMENT
??_C@_0DM@IFCHACPO@FLT?5?9?5DriverEntry?5?9?5Test?5filter?5@FNODOBFM@ DB 'F'
	DB	'LT - DriverEntry - Test filter driver succesfully loaded.', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DL@ENFACENM@?6?6FLT?5?9?5DriverEntry?5?9?5Test?5filte@FNODOBFM@
text$s	SEGMENT
??_C@_0DL@ENFACENM@?6?6FLT?5?9?5DriverEntry?5?9?5Test?5filte@FNODOBFM@ DB 0aH
	DB	0aH, 'FLT - DriverEntry - Test filter driver, compiled %s %s', 0aH
	DB	0aH, 00H					;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0M@DJNHNKNB@May?5?51?52013?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0M@DJNHNKNB@May?5?51?52013?$AA@FNODOBFM@ DB 'May  1 2013', 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_08HPPDJDFG@11?309?349?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_08HPPDJDFG@11?309?349?$AA@FNODOBFM@ DB '11:09:49', 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _DriverEntry@8
_TEXT	SEGMENT
_status$ = -8						; size = 4
_i$ = -4						; size = 4
_pDriverObject$ = 8					; size = 4
_pRegistryPath$ = 12					; size = 4
_DriverEntry@8 PROC					; COMDAT

; 468  : 			IN PUNICODE_STRING pRegistryPath	) {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 469  : 	INT					i;
; 470  : 	PDEVICE_EXTENSION	pDevExt;
; 471  : 
; 472  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 473  : 		"\n\nFLT - DriverEntry - Test filter driver, compiled "
; 474  : 		"%s %s\n\n",__DATE__, __TIME__);

	push	OFFSET ??_C@_08HPPDJDFG@11?309?349?$AA@FNODOBFM@
	push	OFFSET ??_C@_0M@DJNHNKNB@May?5?51?52013?$AA@FNODOBFM@
	push	OFFSET ??_C@_0DL@ENFACENM@?6?6FLT?5?9?5DriverEntry?5?9?5Test?5filte@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 20					; 00000014H

; 475  : 
; 476  : 	// The filter will be loaded by the system and stay loaded,
; 477  : 	// so we don't have an unload routine.
; 478  : 	//
; 479  : 	pDriverObject->DriverUnload = NULL;

	mov	eax, DWORD PTR _pDriverObject$[ebp]
	mov	DWORD PTR [eax+52], 0

; 480  : 	pDriverObject->DriverExtension->AddDevice = AddDevice;

	mov	ecx, DWORD PTR _pDriverObject$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [edx+4], OFFSET ?AddDevice@@YGJPAU_DRIVER_OBJECT@@PAU_DEVICE_OBJECT@@@Z ; AddDevice

; 481  : 
; 482  : 	// Announce entry points for all the function
; 483  : 	// codes, so that the filter can be transparent.
; 484  : 	//
; 485  : 	for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION + 1; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN4@DriverEntr
$LN3@DriverEntr:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN4@DriverEntr:
	cmp	DWORD PTR _i$[ebp], 28			; 0000001cH
	jge	SHORT $LN2@DriverEntr

; 486  : 		pDriverObject->MajorFunction[i] =
; 487  : 				MainDispatch;

	mov	ecx, DWORD PTR _i$[ebp]
	mov	edx, DWORD PTR _pDriverObject$[ebp]
	mov	DWORD PTR [edx+ecx*4+56], OFFSET ?MainDispatch@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ; MainDispatch

; 488  : 	}

	jmp	SHORT $LN3@DriverEntr
$LN2@DriverEntr:

; 489  : 
; 490  : 	// Create and initialize the main device.
; 491  : 	//
; 492  : 	NTSTATUS status = CreateMainDevice(pDriverObject);

	mov	eax, DWORD PTR _pDriverObject$[ebp]
	push	eax
	call	?CreateMainDevice@@YGJPAU_DRIVER_OBJECT@@@Z ; CreateMainDevice
	mov	DWORD PTR _status$[ebp], eax

; 493  : 	if (!NT_SUCCESS(status)) return status;

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN1@DriverEntr
	mov	eax, DWORD PTR _status$[ebp]
	jmp	SHORT $LN5@DriverEntr
$LN1@DriverEntr:

; 494  : 
; 495  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 496  : 		"FLT - DriverEntry - Test filter driver succesfully "
; 497  : 		"loaded.\n");

	push	OFFSET ??_C@_0DM@IFCHACPO@FLT?5?9?5DriverEntry?5?9?5Test?5filter?5@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 12					; 0000000cH

; 498  : 
; 499  : 	return STATUS_SUCCESS;

	xor	eax, eax
$LN5@DriverEntr:

; 500  : }

	mov	esp, ebp
	pop	ebp
	ret	8
_DriverEntry@8 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DF@CEGKGNGA@FLT?5?9?5AddDevice?5?9?5failed?$DL?5return@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_InsertTailList@8
PUBLIC	??_C@_0ED@PAJPNGE@FLT?5?9?5AddDevice?5?9?5Filter?5access?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EK@HBPFAIIB@FLT?5?9?5AddDevice?5?9?5Failed?5to?5crea@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BG@BNCJKNLL@?$AAF?$AAi?$AAl?$AAt?$AAA?$AAc?$AAc?$AAe?$AAs?$AAs?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DG@MKCCCIDK@FLT?5?9?5AddDevice?5?9?5Failed?5to?5allo@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0GI@HKPAOEPB@FLT?5?9?5AddDevice?5?9?5Attached?5filte@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DJ@MNLFKKDM@FLT?5?9?5AddDevice?5?9?5Failed?5to?5atta@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_InitializeListHead@4
PUBLIC	_KeInitializeSpinLock@4
PUBLIC	??_C@_0ED@EDCCOAPN@FLT?5?9?5AddDevice?5?9?5Failed?5to?5crea@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BG@DCLHEFJL@?$AAT?$AAe?$AAs?$AAt?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CL@NAJACAOE@FLT?5?9?5AddDevice?5?9?5Entering?0?5pTar@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	__$ArrayPad$
EXTRN	__imp__IoDetachDevice@4:PROC
EXTRN	__imp__ExFreePoolWithTag@8:PROC
EXTRN	__imp__IoDeleteDevice@4:PROC
EXTRN	__imp_@KeReleaseInStackQueuedSpinLock@4:PROC
EXTRN	__imp_@KeAcquireInStackQueuedSpinLock@8:PROC
EXTRN	?CBInitBufferCtlVar@@YGXPAU_CIRCULAR_BUFFER@@PAXK@Z:PROC ; CBInitBufferCtlVar
EXTRN	__imp__ExAllocatePoolWithTag@12:PROC
EXTRN	__imp__IoAttachDeviceToDeviceStack@8:PROC
EXTRN	__imp__KeInitializeDpc@12:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ??_C@_0DF@CEGKGNGA@FLT?5?9?5AddDevice?5?9?5failed?$DL?5return@FNODOBFM@
text$s	SEGMENT
??_C@_0DF@CEGKGNGA@FLT?5?9?5AddDevice?5?9?5failed?$DL?5return@FNODOBFM@ DB 'F'
	DB	'LT - AddDevice - failed; returning status = %#010x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0ED@PAJPNGE@FLT?5?9?5AddDevice?5?9?5Filter?5access?5@FNODOBFM@
text$s	SEGMENT
??_C@_0ED@PAJPNGE@FLT?5?9?5AddDevice?5?9?5Filter?5access?5@FNODOBFM@ DB 'F'
	DB	'LT - AddDevice - Filter access device created: %#p; dev ext: '
	DB	'%#p', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EK@HBPFAIIB@FLT?5?9?5AddDevice?5?9?5Failed?5to?5crea@FNODOBFM@
text$s	SEGMENT
??_C@_0EK@HBPFAIIB@FLT?5?9?5AddDevice?5?9?5Failed?5to?5crea@FNODOBFM@ DB 'F'
	DB	'LT - AddDevice - Failed to create filter access dev with stat'
	DB	'us: %#010x', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BG@BNCJKNLL@?$AAF?$AAi?$AAl?$AAt?$AAA?$AAc?$AAc?$AAe?$AAs?$AAs?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BG@BNCJKNLL@?$AAF?$AAi?$AAl?$AAt?$AAA?$AAc?$AAc?$AAe?$AAs?$AAs?$AA?$AA@FNODOBFM@ DB 'F'
	DB	00H, 'i', 00H, 'l', 00H, 't', 00H, 'A', 00H, 'c', 00H, 'c', 00H
	DB	'e', 00H, 's', 00H, 's', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DG@MKCCCIDK@FLT?5?9?5AddDevice?5?9?5Failed?5to?5allo@FNODOBFM@
text$s	SEGMENT
??_C@_0DG@MKCCCIDK@FLT?5?9?5AddDevice?5?9?5Failed?5to?5allo@FNODOBFM@ DB 'F'
	DB	'LT - AddDevice - Failed to allocate the data buffer', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0GI@HKPAOEPB@FLT?5?9?5AddDevice?5?9?5Attached?5filte@FNODOBFM@
text$s	SEGMENT
??_C@_0GI@HKPAOEPB@FLT?5?9?5AddDevice?5?9?5Attached?5filte@FNODOBFM@ DB 'F'
	DB	'LT - AddDevice - Attached filter', 0aH, '    filter:        %'
	DB	'#p', 0aH, '    target device: %#p', 0aH, '    target stack:  '
	DB	'%#p', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DJ@MNLFKKDM@FLT?5?9?5AddDevice?5?9?5Failed?5to?5atta@FNODOBFM@
text$s	SEGMENT
??_C@_0DJ@MNLFKKDM@FLT?5?9?5AddDevice?5?9?5Failed?5to?5atta@FNODOBFM@ DB 'F'
	DB	'LT - AddDevice - Failed to attach filter to device %#p', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0ED@EDCCOAPN@FLT?5?9?5AddDevice?5?9?5Failed?5to?5crea@FNODOBFM@
text$s	SEGMENT
??_C@_0ED@EDCCOAPN@FLT?5?9?5AddDevice?5?9?5Failed?5to?5crea@FNODOBFM@ DB 'F'
	DB	'LT - AddDevice - Failed to create filter dev with status: %#0'
	DB	'10x', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BG@DCLHEFJL@?$AAT?$AAe?$AAs?$AAt?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BG@DCLHEFJL@?$AAT?$AAe?$AAs?$AAt?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AA?$AA@FNODOBFM@ DB 'T'
	DB	00H, 'e', 00H, 's', 00H, 't', 00H, 'F', 00H, 'i', 00H, 'l', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CL@NAJACAOE@FLT?5?9?5AddDevice?5?9?5Entering?0?5pTar@FNODOBFM@
text$s	SEGMENT
??_C@_0CL@NAJACAOE@FLT?5?9?5AddDevice?5?9?5Entering?0?5pTar@FNODOBFM@ DB 'F'
	DB	'LT - AddDevice - Entering, pTargDev: %#p', 0aH, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?AddDevice@@YGJPAU_DRIVER_OBJECT@@PAU_DEVICE_OBJECT@@@Z
_TEXT	SEGMENT
_i$26200 = -160						; size = 4
_NewDevNumber$ = -156					; size = 4
_hLock$ = -152						; size = 12
_Tag$ = -140						; size = 4
_pDataBuffer$ = -136					; size = 4
_pDevExt$ = -132					; size = 4
_pFilterDev$ = -128					; size = 4
_status$ = -124						; size = 4
_pFaDev$ = -120						; size = 4
_pFaDevExt$ = -116					; size = 4
_pTargStack$ = -112					; size = 4
_pTagChar$ = -108					; size = 4
_wszSymLink$ = -104					; size = 96
__$ArrayPad$ = -4					; size = 4
_pDriverObject$ = 8					; size = 4
_pTargDev$ = 12						; size = 4
?AddDevice@@YGJPAU_DRIVER_OBJECT@@PAU_DEVICE_OBJECT@@@Z PROC ; AddDevice, COMDAT

; 525  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 526  : 	PDEVICE_OBJECT		pFaDev = NULL;

	mov	DWORD PTR _pFaDev$[ebp], 0

; 527  : 	PVOID				pDataBuffer = NULL;

	mov	DWORD PTR _pDataBuffer$[ebp], 0

; 528  : 	PDEVICE_EXTENSION	pDevExt;
; 529  : 	PDEVICE_OBJECT	pFilterDev = NULL;

	mov	DWORD PTR _pFilterDev$[ebp], 0

; 530  : 	PDEVICE_OBJECT	pTargStack = NULL;

	mov	DWORD PTR _pTargStack$[ebp], 0

; 531  : 	NTSTATUS		status;
; 532  : 
; 533  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 534  : 		"FLT - AddDevice - Entering, pTargDev: %#p\n", pTargDev);

	mov	eax, DWORD PTR _pTargDev$[ebp]
	push	eax
	push	OFFSET ??_C@_0CL@NAJACAOE@FLT?5?9?5AddDevice?5?9?5Entering?0?5pTar@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 16					; 00000010H

; 535  : 
; 536  : 	// Acquire an unique device number to form the device names and
; 537  : 	// symbolic links
; 538  : 	//
; 539  : 	LONG NewDevNumber = InterlockedIncrement(&DevNumber);

	mov	ecx, OFFSET _DevNumber
	mov	edx, 1
	lock	 xadd	 DWORD PTR [ecx], edx
	inc	edx
	mov	DWORD PTR _NewDevNumber$[ebp], edx

; 540  : 	status = CreateDevice(
; 541  : 		pDriverObject,
; 542  : 		DRV_DEVICE_NAME,
; 543  : 		sizeof (DEVICE_EXTENSION),
; 544  : 		&pFilterDev,
; 545  : 		NewDevNumber,
; 546  : 		NULL);

	push	0
	mov	eax, DWORD PTR _NewDevNumber$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pFilterDev$[ebp]
	push	ecx
	push	216					; 000000d8H
	push	OFFSET ??_C@_1BG@DCLHEFJL@?$AAT?$AAe?$AAs?$AAt?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AA?$AA@FNODOBFM@
	mov	edx, DWORD PTR _pDriverObject$[ebp]
	push	edx
	call	?CreateDevice@@YGJPAU_DRIVER_OBJECT@@PAGKPAPAU_DEVICE_OBJECT@@J1@Z ; CreateDevice
	mov	DWORD PTR _status$[ebp], eax

; 547  : 	if (!NT_SUCCESS(status)) {

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN14@AddDevice

; 548  : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 549  : 			"FLT - AddDevice - Failed to create filter dev with "
; 550  : 			"status: %#010x\n",
; 551  : 			status);

	mov	eax, DWORD PTR _status$[ebp]
	push	eax
	push	OFFSET ??_C@_0ED@EDCCOAPN@FLT?5?9?5AddDevice?5?9?5Failed?5to?5crea@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 16					; 00000010H

; 552  : 		return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	$LN15@AddDevice
$LN14@AddDevice:

; 553  : 	}
; 554  : 
; 555  : 	// Initialize the Device Extension
; 556  : 	//
; 557  : 	pDevExt = (PDEVICE_EXTENSION) pFilterDev->DeviceExtension;

	mov	ecx, DWORD PTR _pFilterDev$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR _pDevExt$[ebp], edx

; 558  : 	pDevExt->hdr.DevType = DT_FILTER;

	mov	eax, DWORD PTR _pDevExt$[ebp]
	mov	DWORD PTR [eax], 1

; 559  : 	pDevExt->hdr.pDevice = pFilterDev;	// back pointer

	mov	ecx, DWORD PTR _pDevExt$[ebp]
	mov	edx, DWORD PTR _pFilterDev$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 560  : 	pDevExt->dwFlags = 0;

	mov	eax, DWORD PTR _pDevExt$[ebp]
	mov	DWORD PTR [eax+72], 0

; 561  : 	for (int i = 0; i < IRP_MJ_MAXIMUM_FUNCTION + 1; i++) 

	mov	DWORD PTR _i$26200[ebp], 0
	jmp	SHORT $LN13@AddDevice
$LN12@AddDevice:
	mov	ecx, DWORD PTR _i$26200[ebp]
	add	ecx, 1
	mov	DWORD PTR _i$26200[ebp], ecx
$LN13@AddDevice:
	cmp	DWORD PTR _i$26200[ebp], 28		; 0000001cH
	jge	SHORT $LN11@AddDevice

; 562  : 		pDevExt->dwMJFlags[i] = MJ_FLAGS_DEFAULT;

	mov	edx, DWORD PTR _i$26200[ebp]
	mov	eax, DWORD PTR _pDevExt$[ebp]
	mov	DWORD PTR [eax+edx*4+76], 0
	jmp	SHORT $LN12@AddDevice
$LN11@AddDevice:

; 563  : 	KeInitializeSpinLock(&pDevExt->DataLock);

	mov	ecx, DWORD PTR _pDevExt$[ebp]
	add	ecx, 68					; 00000044H
	push	ecx
	call	_KeInitializeSpinLock@4

; 564  : 	KeInitializeDpc(&pDevExt->ComplDpc, DpcCltIrpCompletion, pDevExt);

	mov	edx, DWORD PTR _pDevExt$[ebp]
	push	edx
	push	OFFSET ?DpcCltIrpCompletion@@YGXPAU_KDPC@@PAX11@Z ; DpcCltIrpCompletion
	mov	eax, DWORD PTR _pDevExt$[ebp]
	add	eax, 8
	push	eax
	call	DWORD PTR __imp__KeInitializeDpc@12

; 565  : 	InitializeListHead(&pDevExt->pIrpList);

	mov	ecx, DWORD PTR _pDevExt$[ebp]
	add	ecx, 196				; 000000c4H
	push	ecx
	call	_InitializeListHead@4

; 566  : 	InitializeListHead(&pDevExt->pWaitingComplIrpList);

	mov	edx, DWORD PTR _pDevExt$[ebp]
	add	edx, 208				; 000000d0H
	push	edx
	call	_InitializeListHead@4

; 567  : 	ULONG Tag;
; 568  : 	PCHAR pTagChar = (PCHAR) &Tag;

	lea	eax, DWORD PTR _Tag$[ebp]
	mov	DWORD PTR _pTagChar$[ebp], eax

; 569  : 	pTagChar[3] = 'F';

	mov	ecx, DWORD PTR _pTagChar$[ebp]
	mov	BYTE PTR [ecx+3], 70			; 00000046H

; 570  : 	pTagChar[2] = 'i';

	mov	edx, DWORD PTR _pTagChar$[ebp]
	mov	BYTE PTR [edx+2], 105			; 00000069H

; 571  : 	pTagChar[1] = 'l';

	mov	eax, DWORD PTR _pTagChar$[ebp]
	mov	BYTE PTR [eax+1], 108			; 0000006cH

; 572  : 	pTagChar[0] = 't';

	mov	ecx, DWORD PTR _pTagChar$[ebp]
	mov	BYTE PTR [ecx], 116			; 00000074H

; 573  : 	pTargStack = IoAttachDeviceToDeviceStack(
; 574  : 		pFilterDev,
; 575  : 		pTargDev);

	mov	edx, DWORD PTR _pTargDev$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFilterDev$[ebp]
	push	eax
	call	DWORD PTR __imp__IoAttachDeviceToDeviceStack@8
	mov	DWORD PTR _pTargStack$[ebp], eax

; 576  : 	if (pTargStack == NULL) {

	cmp	DWORD PTR _pTargStack$[ebp], 0
	jne	SHORT $LN10@AddDevice

; 577  : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 578  : 			"FLT - AddDevice - Failed to attach filter to device %#p\n",
; 579  : 			pTargDev);

	mov	ecx, DWORD PTR _pTargDev$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DJ@MNLFKKDM@FLT?5?9?5AddDevice?5?9?5Failed?5to?5atta@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 16					; 00000010H

; 580  : 		status = STATUS_UNSUCCESSFUL;

	mov	DWORD PTR _status$[ebp], -1073741823	; c0000001H
	jmp	$Error_Cleanup$26210

; 581  : 		goto Error_Cleanup;

	jmp	$Error_Cleanup$26210
$LN10@AddDevice:

; 582  : 	}
; 583  : 
; 584  : 	// VERY IMPORTANT!
; 585  : 	//
; 586  : 	// Propagate the flags from the top of the filtered stack, so that the 
; 587  : 	// I/O manager will treat our filter as if it were the previous top 
; 588  : 	// device.
; 589  : 	//
; 590  : 	pFilterDev->Flags = pTargStack->Flags;

	mov	edx, DWORD PTR _pFilterDev$[ebp]
	mov	eax, DWORD PTR _pTargStack$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR [edx+28], ecx

; 591  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 592  : 		"FLT - AddDevice - Attached filter\n"
; 593  : 			 "    filter:        %#p\n"
; 594  : 	         "    target device: %#p\n"
; 595  : 			 "    target stack:  %#p\n",
; 596  : 		pFilterDev,
; 597  : 		pTargDev,
; 598  : 		pTargStack);

	mov	edx, DWORD PTR _pTargStack$[ebp]
	push	edx
	mov	eax, DWORD PTR _pTargDev$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pFilterDev$[ebp]
	push	ecx
	push	OFFSET ??_C@_0GI@HKPAOEPB@FLT?5?9?5AddDevice?5?9?5Attached?5filte@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 24					; 00000018H

; 599  : 	pDevExt->pTargStack = pTargStack;

	mov	edx, DWORD PTR _pDevExt$[ebp]
	mov	eax, DWORD PTR _pTargStack$[ebp]
	mov	DWORD PTR [edx+204], eax

; 600  : 
; 601  : 	// Allocate the filter buffer
; 602  : 	//
; 603  : 	pDataBuffer = ExAllocatePoolWithTag(NonPagedPool, FILT_BUF_SIZE, 
; 604  : 		Tag);

	mov	ecx, DWORD PTR _Tag$[ebp]
	push	ecx
	push	81920					; 00014000H
	push	0
	call	DWORD PTR __imp__ExAllocatePoolWithTag@12
	mov	DWORD PTR _pDataBuffer$[ebp], eax

; 605  : 	if (pDataBuffer == NULL) {

	cmp	DWORD PTR _pDataBuffer$[ebp], 0
	jne	SHORT $LN8@AddDevice

; 606  : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 607  : 			"FLT - AddDevice - Failed to allocate the data "
; 608  : 			"buffer\n");

	push	OFFSET ??_C@_0DG@MKCCCIDK@FLT?5?9?5AddDevice?5?9?5Failed?5to?5allo@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 12					; 0000000cH

; 609  : 		status = STATUS_NO_MEMORY;

	mov	DWORD PTR _status$[ebp], -1073741801	; c0000017H
	jmp	$Error_Cleanup$26210

; 610  : 		goto Error_Cleanup;

	jmp	$Error_Cleanup$26210
$LN8@AddDevice:

; 611  : 	}
; 612  : 	CBInitBufferCtlVar(&pDevExt->DataBuffer, pDataBuffer, FILT_BUF_SIZE);

	push	81920					; 00014000H
	mov	edx, DWORD PTR _pDataBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDevExt$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	call	?CBInitBufferCtlVar@@YGXPAU_CIRCULAR_BUFFER@@PAXK@Z ; CBInitBufferCtlVar

; 613  : 
; 614  : 	// Create the filter access device
; 615  : 	//
; 616  : 	PFADEVICE_EXTENSION pFaDevExt;
; 617  : 
; 618  : 	// wszSymLink receives the sym link name. We need it to copy it
; 619  : 	// into the device extension.
; 620  : 	//
; 621  : 	WCHAR wszSymLink[NAME_BUF_SIZE - 3];
; 622  : 	status = CreateDevice(
; 623  : 		pDriverObject,
; 624  : 		FADEVICE_NAME,
; 625  : 		sizeof (FADEVICE_EXTENSION),
; 626  : 		&pFaDev,
; 627  : 		NewDevNumber,
; 628  : 		wszSymLink);

	lea	ecx, DWORD PTR _wszSymLink$[ebp]
	push	ecx
	mov	edx, DWORD PTR _NewDevNumber$[ebp]
	push	edx
	lea	eax, DWORD PTR _pFaDev$[ebp]
	push	eax
	push	1136					; 00000470H
	push	OFFSET ??_C@_1BG@BNCJKNLL@?$AAF?$AAi?$AAl?$AAt?$AAA?$AAc?$AAc?$AAe?$AAs?$AAs?$AA?$AA@FNODOBFM@
	mov	ecx, DWORD PTR _pDriverObject$[ebp]
	push	ecx
	call	?CreateDevice@@YGJPAU_DRIVER_OBJECT@@PAGKPAPAU_DEVICE_OBJECT@@J1@Z ; CreateDevice
	mov	DWORD PTR _status$[ebp], eax

; 629  : 	if (!NT_SUCCESS(status)) {

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN6@AddDevice

; 630  : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 631  : 			"FLT - AddDevice - Failed to create filter access dev with "
; 632  : 			"status: %#010x\n",
; 633  : 			status);

	mov	edx, DWORD PTR _status$[ebp]
	push	edx
	push	OFFSET ??_C@_0EK@HBPFAIIB@FLT?5?9?5AddDevice?5?9?5Failed?5to?5crea@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 16					; 00000010H
	jmp	$Error_Cleanup$26210

; 634  : 		goto Error_Cleanup;

	jmp	$Error_Cleanup$26210
$LN6@AddDevice:

; 635  : 	}
; 636  : 	pFaDevExt = (PFADEVICE_EXTENSION) pFaDev->DeviceExtension;

	mov	eax, DWORD PTR _pFaDev$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _pFaDevExt$[ebp], ecx

; 637  : 
; 638  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 639  : 		"FLT - AddDevice - Filter access device created: %#p; dev "
; 640  : 		"ext: %#p\n",
; 641  : 		pFaDev, pFaDevExt);

	mov	edx, DWORD PTR _pFaDevExt$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFaDev$[ebp]
	push	eax
	push	OFFSET ??_C@_0ED@PAJPNGE@FLT?5?9?5AddDevice?5?9?5Filter?5access?5@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 20					; 00000014H

; 642  : 
; 643  : 	// Initialize the device extension.
; 644  : 	//
; 645  : 	RtlZeroMemory(pFaDevExt, sizeof (PFADEVICE_EXTENSION));

	xor	ecx, ecx
	mov	edx, DWORD PTR _pFaDevExt$[ebp]
	mov	DWORD PTR [edx], ecx

; 646  : 	pFaDevExt->hdr.DevType = DT_FILTER_ACCESS;

	mov	eax, DWORD PTR _pFaDevExt$[ebp]
	mov	DWORD PTR [eax], 2

; 647  : 	pFaDevExt->hdr.pDevice = pFaDev;

	mov	ecx, DWORD PTR _pFaDevExt$[ebp]
	mov	edx, DWORD PTR _pFaDev$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 648  : 	pFaDevExt->pFilterDevExt = pDevExt;

	mov	eax, DWORD PTR _pFaDevExt$[ebp]
	mov	ecx, DWORD PTR _pDevExt$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 649  : 	CopyWString(
; 650  : 		(PWCHAR) &pFaDevExt->TargDevInfo.SymLink,
; 651  : 		(PWCHAR) wszSymLink,
; 652  : 		sizeof pFaDevExt->TargDevInfo.SymLink);

	push	104					; 00000068H
	lea	edx, DWORD PTR _wszSymLink$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFaDevExt$[ebp]
	add	eax, 12					; 0000000cH
	push	eax
	call	?CopyWString@@YGXPAG0K@Z		; CopyWString

; 653  : 
; 654  : 	// The filter access device uses direct I/O
; 655  : 	//
; 656  : 	pFaDev->Flags |= DO_DIRECT_IO;

	mov	ecx, DWORD PTR _pFaDev$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	or	edx, 16					; 00000010H
	mov	eax, DWORD PTR _pFaDev$[ebp]
	mov	DWORD PTR [eax+28], edx

; 657  : 	pFaDev->Flags &= ~DO_DEVICE_INITIALIZING;

	mov	ecx, DWORD PTR _pFaDev$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	and	edx, -129				; ffffff7fH
	mov	eax, DWORD PTR _pFaDev$[ebp]
	mov	DWORD PTR [eax+28], edx

; 658  : 
; 659  : 
; 660  : 	// Set the address of the extension for the filter access dev into
; 661  : 	// the extension for the filter dev.
; 662  : 	//
; 663  : 	pDevExt->pFADevExt = pFaDevExt;

	mov	ecx, DWORD PTR _pDevExt$[ebp]
	mov	edx, DWORD PTR _pFaDevExt$[ebp]
	mov	DWORD PTR [ecx+192], edx

; 664  : 
; 665  : 	// Get the target device description, etc.
; 666  : 	//
; 667  : 	GetTargDevInfo(pFaDevExt);

	mov	eax, DWORD PTR _pFaDevExt$[ebp]
	push	eax
	call	?GetTargDevInfo@@YGJPAU_FADEVICE_EXTENSION@@@Z ; GetTargDevInfo

; 668  : 
; 669  : 	// Add the FA device to the FA device list. The list head is stored
; 670  : 	// into the device extension of the master device 
; 671  : 	//
; 672  : 	KLOCK_QUEUE_HANDLE hLock;
; 673  : 	KeAcquireInStackQueuedSpinLock(&pMastDevExt->SyncLock,
; 674  : 		&hLock);

	mov	ecx, DWORD PTR _pMastDevExt
	add	ecx, 8
	lea	edx, DWORD PTR _hLock$[ebp]
	call	DWORD PTR __imp_@KeAcquireInStackQueuedSpinLock@8

; 675  : 	InsertTailList(
; 676  : 		&pMastDevExt->FADevsList, 
; 677  : 		&pFaDevExt->ListEntry);

	mov	ecx, DWORD PTR _pFaDevExt$[ebp]
	add	ecx, 1128				; 00000468H
	push	ecx
	mov	edx, DWORD PTR _pMastDevExt
	add	edx, 12					; 0000000cH
	push	edx
	call	_InsertTailList@8

; 678  : 	pMastDevExt->FADevsCount++;

	mov	eax, DWORD PTR _pMastDevExt
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, 1
	mov	edx, DWORD PTR _pMastDevExt
	mov	DWORD PTR [edx+20], ecx

; 679  : 	KeReleaseInStackQueuedSpinLock(&hLock);

	lea	ecx, DWORD PTR _hLock$[ebp]
	call	DWORD PTR __imp_@KeReleaseInStackQueuedSpinLock@4

; 680  : 	return STATUS_SUCCESS;

	xor	eax, eax
	jmp	SHORT $LN15@AddDevice
$Error_Cleanup$26210:

; 681  : 
; 682  : Error_Cleanup:
; 683  : 	if (pFaDev != NULL) IoDeleteDevice (pFaDev);

	cmp	DWORD PTR _pFaDev$[ebp], 0
	je	SHORT $LN4@AddDevice
	mov	eax, DWORD PTR _pFaDev$[ebp]
	push	eax
	call	DWORD PTR __imp__IoDeleteDevice@4
$LN4@AddDevice:

; 684  : 	if (pDataBuffer != NULL) ExFreePool(pDataBuffer);

	cmp	DWORD PTR _pDataBuffer$[ebp], 0
	je	SHORT $LN3@AddDevice
	push	0
	mov	ecx, DWORD PTR _pDataBuffer$[ebp]
	push	ecx
	call	DWORD PTR __imp__ExFreePoolWithTag@8
$LN3@AddDevice:

; 685  : 	if (pTargStack != NULL) IoDetachDevice(pTargStack);

	cmp	DWORD PTR _pTargStack$[ebp], 0
	je	SHORT $LN2@AddDevice
	mov	edx, DWORD PTR _pTargStack$[ebp]
	push	edx
	call	DWORD PTR __imp__IoDetachDevice@4
$LN2@AddDevice:

; 686  : 	if (pFilterDev != NULL) IoDeleteDevice (pFilterDev);

	cmp	DWORD PTR _pFilterDev$[ebp], 0
	je	SHORT $LN1@AddDevice
	mov	eax, DWORD PTR _pFilterDev$[ebp]
	push	eax
	call	DWORD PTR __imp__IoDeleteDevice@4
$LN1@AddDevice:

; 687  : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 688  : 		"FLT - AddDevice - failed; returning status = %#010x\n", 
; 689  : 		status);

	mov	ecx, DWORD PTR _status$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DF@CEGKGNGA@FLT?5?9?5AddDevice?5?9?5failed?$DL?5return@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 16					; 00000010H

; 690  : 	return status;

	mov	eax, DWORD PTR _status$[ebp]
$LN15@AddDevice:

; 691  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?AddDevice@@YGJPAU_DRIVER_OBJECT@@PAU_DEVICE_OBJECT@@@Z ENDP ; AddDevice
; Function compile flags: /Odtp
; File c:\apps\pw7hp\devpgm\msddk\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT _InitializeListHead@4
_TEXT	SEGMENT
_ListHead$ = 8						; size = 4
_InitializeListHead@4 PROC				; COMDAT

; 7550 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 7551 :     ListHead->Flink = ListHead->Blink = ListHead;

	mov	eax, DWORD PTR _ListHead$[ebp]
	mov	ecx, DWORD PTR _ListHead$[ebp]
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR _ListHead$[ebp]
	mov	eax, DWORD PTR _ListHead$[ebp]
	mov	DWORD PTR [edx], eax

; 7552 : }

	pop	ebp
	ret	4
_InitializeListHead@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _InsertTailList@8
_TEXT	SEGMENT
_Blink$ = -4						; size = 4
_ListHead$ = 8						; size = 4
_Entry$ = 12						; size = 4
_InsertTailList@8 PROC					; COMDAT

; 7621 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 7622 :     PLIST_ENTRY Blink;
; 7623 : 
; 7624 :     Blink = ListHead->Blink;

	mov	eax, DWORD PTR _ListHead$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _Blink$[ebp], ecx

; 7625 :     Entry->Flink = ListHead;

	mov	edx, DWORD PTR _Entry$[ebp]
	mov	eax, DWORD PTR _ListHead$[ebp]
	mov	DWORD PTR [edx], eax

; 7626 :     Entry->Blink = Blink;

	mov	ecx, DWORD PTR _Entry$[ebp]
	mov	edx, DWORD PTR _Blink$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 7627 :     Blink->Flink = Entry;

	mov	eax, DWORD PTR _Blink$[ebp]
	mov	ecx, DWORD PTR _Entry$[ebp]
	mov	DWORD PTR [eax], ecx

; 7628 :     ListHead->Blink = Entry;

	mov	edx, DWORD PTR _ListHead$[ebp]
	mov	eax, DWORD PTR _Entry$[ebp]
	mov	DWORD PTR [edx+4], eax

; 7629 : }

	mov	esp, ebp
	pop	ebp
	ret	8
_InsertTailList@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _KeInitializeSpinLock@4
_TEXT	SEGMENT
_SpinLock$ = 8						; size = 4
_KeInitializeSpinLock@4 PROC				; COMDAT

; 15095: {

	npad	2
	push	ebp
	mov	ebp, esp

; 15096: 
; 15097:     *SpinLock = 0;

	mov	eax, DWORD PTR _SpinLock$[ebp]
	mov	DWORD PTR [eax], 0

; 15098:     return;
; 15099: }

	pop	ebp
	ret	4
_KeInitializeSpinLock@4 ENDP
; Function compile flags: /Odtp
; File b:\programm\wntsys\testfilter\release\1_1\source\driver\drvmain.cpp
_TEXT	ENDS
;	COMDAT ?CopyWString@@YGXPAG0K@Z
_TEXT	SEGMENT
_pLast$ = -4						; size = 4
_pDest$ = 8						; size = 4
_pSrc$ = 12						; size = 4
_DestSize$ = 16						; size = 4
?CopyWString@@YGXPAG0K@Z PROC				; CopyWString, COMDAT

; 858  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 859  : 	// pLast points to the last WCHAR in the dest buffer.
; 860  : 	//
; 861  : 	PWCHAR pLast = pDest + DestSize / sizeof (WCHAR) -1;

	mov	eax, DWORD PTR _DestSize$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR _pDest$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2-2]
	mov	DWORD PTR _pLast$[ebp], edx

; 862  : 	for (; *pSrc != L'\0'; pSrc++, pDest++) {

	jmp	SHORT $LN4@CopyWStrin
$LN3@CopyWStrin:
	mov	eax, DWORD PTR _pSrc$[ebp]
	add	eax, 2
	mov	DWORD PTR _pSrc$[ebp], eax
	mov	ecx, DWORD PTR _pDest$[ebp]
	add	ecx, 2
	mov	DWORD PTR _pDest$[ebp], ecx
$LN4@CopyWStrin:
	mov	edx, DWORD PTR _pSrc$[ebp]
	movzx	eax, WORD PTR [edx]
	test	eax, eax
	je	SHORT $LN2@CopyWStrin

; 863  : 		if (pDest >= pLast) break;

	mov	ecx, DWORD PTR _pDest$[ebp]
	cmp	ecx, DWORD PTR _pLast$[ebp]
	jb	SHORT $LN1@CopyWStrin
	jmp	SHORT $LN2@CopyWStrin
$LN1@CopyWStrin:

; 864  : 		*pDest = *pSrc;

	mov	edx, DWORD PTR _pDest$[ebp]
	mov	eax, DWORD PTR _pSrc$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR [edx], cx

; 865  : 	}

	jmp	SHORT $LN3@CopyWStrin
$LN2@CopyWStrin:

; 866  : 	*pDest = L'\0';

	xor	edx, edx
	mov	eax, DWORD PTR _pDest$[ebp]
	mov	WORD PTR [eax], dx

; 867  : 	return;
; 868  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?CopyWString@@YGXPAG0K@Z ENDP				; CopyWString
_TEXT	ENDS
PUBLIC	??_C@_0DG@KJMBDFMO@FLT?5?9?5CreateDevice?5?9?5Failed?4?5Ret@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EH@MBIPFAHB@FLT?5?9?5CreateDevice?5?9?5IoCreateSym@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EC@EDKPLCPO@FLT?5?9?5CreateDevice?5?9?5?5IoCreateDe@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1O@PAJNNBDG@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BC@MDHMAKOA@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$CF?$AAs?$AA?$CF?$AAd?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1BG@EDLFNGEH@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_RtlUnicodeStringPrintf
PUBLIC	??_C@_1BK@BKIFJHAA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AA?$CF?$AAs?$AA?$CF?$AAd?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	__$ArrayPad$
EXTRN	__imp__IoCreateSymbolicLink@8:PROC
EXTRN	__imp__IoCreateDevice@28:PROC
;	COMDAT ??_C@_0DG@KJMBDFMO@FLT?5?9?5CreateDevice?5?9?5Failed?4?5Ret@FNODOBFM@
text$s	SEGMENT
??_C@_0DG@KJMBDFMO@FLT?5?9?5CreateDevice?5?9?5Failed?4?5Ret@FNODOBFM@ DB 'F'
	DB	'LT - CreateDevice - Failed. Returning status %#010x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EH@MBIPFAHB@FLT?5?9?5CreateDevice?5?9?5IoCreateSym@FNODOBFM@
text$s	SEGMENT
??_C@_0EH@MBIPFAHB@FLT?5?9?5CreateDevice?5?9?5IoCreateSym@FNODOBFM@ DB 'F'
	DB	'LT - CreateDevice - IoCreateSymbolicLink() failed with status'
	DB	' %#010x', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EC@EDKPLCPO@FLT?5?9?5CreateDevice?5?9?5?5IoCreateDe@FNODOBFM@
text$s	SEGMENT
??_C@_0EC@EDKPLCPO@FLT?5?9?5CreateDevice?5?9?5?5IoCreateDe@FNODOBFM@ DB 'F'
	DB	'LT - CreateDevice -  IoCreateDevice() failed with status %#01'
	DB	'0x', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1O@PAJNNBDG@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1O@PAJNNBDG@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, '?', 00H, '?', 00H, '\', 00H, '%', 00H, 's', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BC@MDHMAKOA@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$CF?$AAs?$AA?$CF?$AAd?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BC@MDHMAKOA@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$CF?$AAs?$AA?$CF?$AAd?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, '?', 00H, '?', 00H, '\', 00H, '%', 00H, 's', 00H, '%', 00H
	DB	'd', 00H, 00H, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BG@EDLFNGEH@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BG@EDLFNGEH@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, '%', 00H, 's', 00H, 00H, 00H	;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BK@BKIFJHAA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AA?$CF?$AAs?$AA?$CF?$AAd?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BK@BKIFJHAA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AA?$CF?$AAs?$AA?$CF?$AAd?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, '%', 00H, 's', 00H, '%', 00H, 'd', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?CreateDevice@@YGJPAU_DRIVER_OBJECT@@PAGKPAPAU_DEVICE_OBJECT@@J1@Z
_TEXT	SEGMENT
_StrCharLen$26331 = -252				; size = 4
_i$26333 = -248						; size = 4
_status$ = -244						; size = 4
_wszIntNameBuf$ = -240					; size = 102
_pDevObj$ = -132					; size = 4
_wszSymNameBuf$ = -128					; size = 102
__$ArrayPad$ = -20					; size = 4
_uSymName$ = -16					; size = 8
_uIntName$ = -8						; size = 8
_pDriverObject$ = 8					; size = 4
_pBaseName$ = 12					; size = 4
_DevExtSize$ = 16					; size = 4
_ppDev$ = 20						; size = 4
_SeqNum$ = 24						; size = 4
_pwszSymLink$ = 28					; size = 4
?CreateDevice@@YGJPAU_DRIVER_OBJECT@@PAGKPAPAU_DEVICE_OBJECT@@J1@Z PROC ; CreateDevice, COMDAT

; 916  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 917  : 
; 918  : 	PDEVICE_OBJECT	pDevObj = NULL;

	mov	DWORD PTR _pDevObj$[ebp], 0

; 919  : 	NTSTATUS		status;
; 920  : 
; 921  : 	*ppDev = NULL;

	mov	eax, DWORD PTR _ppDev$[ebp]
	mov	DWORD PTR [eax], 0

; 922  : 
; 923  : 	// Form the device name
; 924  : 	//
; 925  : 	WCHAR			wszIntNameBuf[NAME_BUF_SIZE];
; 926  : 	UNICODE_STRING	uIntName;
; 927  : 	wszIntNameBuf[0] = L'\0';

	xor	ecx, ecx
	mov	WORD PTR _wszIntNameBuf$[ebp], cx

; 928  : 	uIntName.Length = 0;

	xor	edx, edx
	mov	WORD PTR _uIntName$[ebp], dx

; 929  : 	uIntName.MaximumLength = sizeof wszIntNameBuf;

	mov	eax, 102				; 00000066H
	mov	WORD PTR _uIntName$[ebp+2], ax

; 930  : 	uIntName.Buffer = wszIntNameBuf;

	lea	ecx, DWORD PTR _wszIntNameBuf$[ebp]
	mov	DWORD PTR _uIntName$[ebp+4], ecx

; 931  : 	if (SeqNum != -1) {

	cmp	DWORD PTR _SeqNum$[ebp], -1
	je	SHORT $LN14@CreateDevi

; 932  : 		status = RtlUnicodeStringPrintf(
; 933  : 			&uIntName,
; 934  : 			L"\\Device\\%s%d",
; 935  : 			pBaseName,
; 936  : 			SeqNum);

	mov	edx, DWORD PTR _SeqNum$[ebp]
	push	edx
	mov	eax, DWORD PTR _pBaseName$[ebp]
	push	eax
	push	OFFSET ??_C@_1BK@BKIFJHAA@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AA?$CF?$AAs?$AA?$CF?$AAd?$AA?$AA@FNODOBFM@
	lea	ecx, DWORD PTR _uIntName$[ebp]
	push	ecx
	call	_RtlUnicodeStringPrintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _status$[ebp], eax

; 937  : 	} else {

	jmp	SHORT $LN13@CreateDevi
$LN14@CreateDevi:

; 938  : 		status = RtlUnicodeStringPrintf(
; 939  : 			&uIntName,
; 940  : 			L"\\Device\\%s",
; 941  : 			pBaseName);

	mov	edx, DWORD PTR _pBaseName$[ebp]
	push	edx
	push	OFFSET ??_C@_1BG@EDLFNGEH@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@
	lea	eax, DWORD PTR _uIntName$[ebp]
	push	eax
	call	_RtlUnicodeStringPrintf
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _status$[ebp], eax
$LN13@CreateDevi:

; 942  : 	}
; 943  : 	if (!NT_SUCCESS(status)) return status;

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN12@CreateDevi
	mov	eax, DWORD PTR _status$[ebp]
	jmp	$LN15@CreateDevi
$LN12@CreateDevi:

; 944  : 
; 945  : 	// Form the symbolic link name
; 946  : 	//
; 947  : 	WCHAR			wszSymNameBuf[NAME_BUF_SIZE];
; 948  : 	UNICODE_STRING	uSymName;
; 949  : 	wszSymNameBuf[0] = L'\0';

	xor	ecx, ecx
	mov	WORD PTR _wszSymNameBuf$[ebp], cx

; 950  : 	uSymName.Length = 0;

	xor	edx, edx
	mov	WORD PTR _uSymName$[ebp], dx

; 951  : 	uSymName.MaximumLength = sizeof wszSymNameBuf;

	mov	eax, 102				; 00000066H
	mov	WORD PTR _uSymName$[ebp+2], ax

; 952  : 	uSymName.Buffer = wszSymNameBuf;

	lea	ecx, DWORD PTR _wszSymNameBuf$[ebp]
	mov	DWORD PTR _uSymName$[ebp+4], ecx

; 953  : 	if (SeqNum != -1) {

	cmp	DWORD PTR _SeqNum$[ebp], -1
	je	SHORT $LN11@CreateDevi

; 954  : 		status = RtlUnicodeStringPrintf(
; 955  : 			&uSymName,
; 956  : 			L"\\??\\%s%d",
; 957  : 			pBaseName,
; 958  : 			DevNumber);

	mov	edx, DWORD PTR _DevNumber
	push	edx
	mov	eax, DWORD PTR _pBaseName$[ebp]
	push	eax
	push	OFFSET ??_C@_1BC@MDHMAKOA@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$CF?$AAs?$AA?$CF?$AAd?$AA?$AA@FNODOBFM@
	lea	ecx, DWORD PTR _uSymName$[ebp]
	push	ecx
	call	_RtlUnicodeStringPrintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _status$[ebp], eax

; 959  : 	} else {

	jmp	SHORT $LN10@CreateDevi
$LN11@CreateDevi:

; 960  : 		status = RtlUnicodeStringPrintf(
; 961  : 			&uSymName,
; 962  : 			L"\\??\\%s",
; 963  : 			pBaseName);

	mov	edx, DWORD PTR _pBaseName$[ebp]
	push	edx
	push	OFFSET ??_C@_1O@PAJNNBDG@?$AA?2?$AA?$DP?$AA?$DP?$AA?2?$AA?$CF?$AAs?$AA?$AA@FNODOBFM@
	lea	eax, DWORD PTR _uSymName$[ebp]
	push	eax
	call	_RtlUnicodeStringPrintf
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _status$[ebp], eax
$LN10@CreateDevi:

; 964  : 	}
; 965  : 	if (!NT_SUCCESS(status)) return status;

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN9@CreateDevi
	mov	eax, DWORD PTR _status$[ebp]
	jmp	$LN15@CreateDevi
$LN9@CreateDevi:

; 966  : 
; 967  : 	// Copy the sym link name to the output buffer, if a buffer
; 968  : 	// has been specified
; 969  : 	//
; 970  : 	// pwszSymLink receives the sym link name. The UNICODE_STRING has a 
; 971  : 	// buffer of NAME_BUF_SIZE chars, however we are going to skip the
; 972  : 	// first 4 chars (\??\), so wszSymLink must hold NAME_BUF_SIZE - 4
; 973  : 	// chars. Furthermore, unicode strings do not have null 
; 974  : 	// terminators, but wszSymLink is a plain string, hence 
; 975  : 	// null-terminated. So wszSymLink must be NAME_BUF_SIZE - 3 chars.
; 976  : 	//
; 977  : 	if (pwszSymLink != NULL) {

	cmp	DWORD PTR _pwszSymLink$[ebp], 0
	je	SHORT $LN8@CreateDevi

; 978  : 		ULONG StrCharLen = uSymName.Length / sizeof (WCHAR) - 4;

	movzx	ecx, WORD PTR _uSymName$[ebp]
	shr	ecx, 1
	sub	ecx, 4
	mov	DWORD PTR _StrCharLen$26331[ebp], ecx

; 979  : 		ULONG i = 0;

	mov	DWORD PTR _i$26333[ebp], 0

; 980  : 		for (; i < StrCharLen; i++) {

	jmp	SHORT $LN7@CreateDevi
$LN6@CreateDevi:
	mov	edx, DWORD PTR _i$26333[ebp]
	add	edx, 1
	mov	DWORD PTR _i$26333[ebp], edx
$LN7@CreateDevi:
	mov	eax, DWORD PTR _i$26333[ebp]
	cmp	eax, DWORD PTR _StrCharLen$26331[ebp]
	jae	SHORT $LN5@CreateDevi

; 981  : 			pwszSymLink[i] = uSymName.Buffer[i + 4];

	mov	ecx, DWORD PTR _i$26333[ebp]
	mov	edx, DWORD PTR _pwszSymLink$[ebp]
	mov	eax, DWORD PTR _i$26333[ebp]
	mov	esi, DWORD PTR _uSymName$[ebp+4]
	mov	ax, WORD PTR [esi+eax*2+8]
	mov	WORD PTR [edx+ecx*2], ax

; 982  : 		}

	jmp	SHORT $LN6@CreateDevi
$LN5@CreateDevi:

; 983  : 		pwszSymLink[i] = L'\0';

	xor	ecx, ecx
	mov	edx, DWORD PTR _i$26333[ebp]
	mov	eax, DWORD PTR _pwszSymLink$[ebp]
	mov	WORD PTR [eax+edx*2], cx
$LN8@CreateDevi:

; 984  : 	}
; 985  : 	// Create the device
; 986  : 	//
; 987  : 	status =
; 988  : 		IoCreateDevice( pDriverObject,
; 989  : 						DevExtSize,
; 990  : 						&uIntName,
; 991  : 						FILE_DEVICE_UNKNOWN,
; 992  : 						0, FALSE,
; 993  : 						&pDevObj );

	lea	ecx, DWORD PTR _pDevObj$[ebp]
	push	ecx
	push	0
	push	0
	push	34					; 00000022H
	lea	edx, DWORD PTR _uIntName$[ebp]
	push	edx
	mov	eax, DWORD PTR _DevExtSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDriverObject$[ebp]
	push	ecx
	call	DWORD PTR __imp__IoCreateDevice@28
	mov	DWORD PTR _status$[ebp], eax

; 994  : 	if (!NT_SUCCESS(status)) {

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN4@CreateDevi

; 995  : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 996  : 			"FLT - CreateDevice -  IoCreateDevice() failed with "
; 997  : 			"status %#010x\n",
; 998  : 			status);

	mov	edx, DWORD PTR _status$[ebp]
	push	edx
	push	OFFSET ??_C@_0EC@EDKPLCPO@FLT?5?9?5CreateDevice?5?9?5?5IoCreateDe@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 16					; 00000010H

; 999  : 		return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	SHORT $LN15@CreateDevi
$LN4@CreateDevi:

; 1000 : 	}
; 1001 : 
; 1002 : 	// Form the symbolic link name
; 1003 : 	status = 
; 1004 : 		IoCreateSymbolicLink( &uSymName,
; 1005 : 							  &uIntName );

	lea	eax, DWORD PTR _uIntName$[ebp]
	push	eax
	lea	ecx, DWORD PTR _uSymName$[ebp]
	push	ecx
	call	DWORD PTR __imp__IoCreateSymbolicLink@8
	mov	DWORD PTR _status$[ebp], eax

; 1006 : 	if (!NT_SUCCESS(status)) {

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN3@CreateDevi

; 1007 : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1008 : 			"FLT - CreateDevice - IoCreateSymbolicLink() failed "
; 1009 : 			"with status %#010x\n",
; 1010 : 			status);

	mov	edx, DWORD PTR _status$[ebp]
	push	edx
	push	OFFSET ??_C@_0EH@MBIPFAHB@FLT?5?9?5CreateDevice?5?9?5IoCreateSym@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 16					; 00000010H
	jmp	SHORT $Error_Cleanup$26343

; 1011 : 		goto Error_Cleanup;

	jmp	SHORT $Error_Cleanup$26343
$LN3@CreateDevi:

; 1012 : 	}
; 1013 : 
; 1014 : 	// Pass the device object ptr to the caller.
; 1015 : 	//
; 1016 : 	*ppDev = pDevObj;

	mov	eax, DWORD PTR _ppDev$[ebp]
	mov	ecx, DWORD PTR _pDevObj$[ebp]
	mov	DWORD PTR [eax], ecx

; 1017 : 	return STATUS_SUCCESS;

	xor	eax, eax
	jmp	SHORT $LN15@CreateDevi
$Error_Cleanup$26343:

; 1018 : 
; 1019 : Error_Cleanup:
; 1020 : 	if (pDevObj != NULL) IoDeleteDevice(pDevObj);

	cmp	DWORD PTR _pDevObj$[ebp], 0
	je	SHORT $LN1@CreateDevi
	mov	edx, DWORD PTR _pDevObj$[ebp]
	push	edx
	call	DWORD PTR __imp__IoDeleteDevice@4
$LN1@CreateDevi:

; 1021 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1022 : 		"FLT - CreateDevice - Failed. Returning status %#010x\n", 
; 1023 : 		status);

	mov	eax, DWORD PTR _status$[ebp]
	push	eax
	push	OFFSET ??_C@_0DG@KJMBDFMO@FLT?5?9?5CreateDevice?5?9?5Failed?4?5Ret@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 16					; 00000010H

; 1024 : 	return status;

	mov	eax, DWORD PTR _status$[ebp]
$LN15@CreateDevi:

; 1025 : }

	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?CreateDevice@@YGJPAU_DRIVER_OBJECT@@PAGKPAPAU_DEVICE_OBJECT@@J1@Z ENDP ; CreateDevice
; Function compile flags: /Odtp
; File c:\apps\pw7hp\devpgm\msddk\inc\ddk\ntstrsafe.h
_TEXT	ENDS
;	COMDAT _RtlUnicodeStringPrintf
_TEXT	SEGMENT
_argList$25286 = -20					; size = 4
_cchNewDestLength$25287 = -16				; size = 4
_cchDest$ = -12						; size = 4
_status$ = -8						; size = 4
_pszDest$ = -4						; size = 4
_DestinationString$ = 8					; size = 4
_pszFormat$ = 12					; size = 4
_RtlUnicodeStringPrintf PROC				; COMDAT

; 11132: {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 11133:     NTSTATUS status;
; 11134:     wchar_t* pszDest;
; 11135:     size_t cchDest;
; 11136:     
; 11137:     status = RtlUnicodeStringValidateDestWorker(DestinationString,
; 11138:                                                 &pszDest,
; 11139:                                                 &cchDest,
; 11140:                                                 NULL,
; 11141:                                                 NTSTRSAFE_UNICODE_STRING_MAX_CCH,
; 11142:                                                 0);

	push	0
	push	32767					; 00007fffH
	push	0
	lea	eax, DWORD PTR _cchDest$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pszDest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _DestinationString$[ebp]
	push	edx
	call	_RtlUnicodeStringValidateDestWorker@24
	mov	DWORD PTR _status$[ebp], eax

; 11143: 
; 11144:     if (NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jl	SHORT $LN1@RtlUnicode

; 11145:     {
; 11146:         va_list argList;
; 11147:         size_t cchNewDestLength = 0;

	mov	DWORD PTR _cchNewDestLength$25287[ebp], 0

; 11148: 
; 11149:         va_start(argList, pszFormat);

	lea	eax, DWORD PTR _pszFormat$[ebp+4]
	mov	DWORD PTR _argList$25286[ebp], eax

; 11150: 
; 11151:         status = RtlWideCharArrayVPrintfWorker(pszDest,
; 11152:                                                cchDest,
; 11153:                                                &cchNewDestLength,
; 11154:                                                pszFormat,
; 11155:                                                argList);

	mov	ecx, DWORD PTR _argList$25286[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszFormat$[ebp]
	push	edx
	lea	eax, DWORD PTR _cchNewDestLength$25287[ebp]
	push	eax
	mov	ecx, DWORD PTR _cchDest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszDest$[ebp]
	push	edx
	call	_RtlWideCharArrayVPrintfWorker@20
	mov	DWORD PTR _status$[ebp], eax

; 11156: 
; 11157:         va_end(argList);

	mov	DWORD PTR _argList$25286[ebp], 0

; 11158: 
; 11159:         // safe to multiply cchNewDestLength * sizeof(wchar_t) since cchDest < NTSTRSAFE_UNICODE_STRING_MAX_CCH and sizeof(wchar_t) is 2
; 11160:         DestinationString->Length = (USHORT)(cchNewDestLength * sizeof(wchar_t));

	mov	eax, DWORD PTR _cchNewDestLength$25287[ebp]
	shl	eax, 1
	mov	ecx, DWORD PTR _DestinationString$[ebp]
	mov	WORD PTR [ecx], ax
$LN1@RtlUnicode:

; 11161:     }
; 11162: 
; 11163:     return status;

	mov	eax, DWORD PTR _status$[ebp]

; 11164: }

	mov	esp, ebp
	pop	ebp
	ret	0
_RtlUnicodeStringPrintf ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _RtlUnicodeStringValidateDestWorker@24
_TEXT	SEGMENT
_status$ = -4						; size = 4
_DestinationString$ = 8					; size = 4
_ppszDest$ = 12						; size = 4
_pcchDest$ = 16						; size = 4
_pcchDestLength$ = 20					; size = 4
_cchMax$ = 24						; size = 4
_dwFlags$ = 28						; size = 4
_RtlUnicodeStringValidateDestWorker@24 PROC		; COMDAT

; 12237: {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 12238:     NTSTATUS status;
; 12239: 
; 12240:     *ppszDest = NULL;

	mov	eax, DWORD PTR _ppszDest$[ebp]
	mov	DWORD PTR [eax], 0

; 12241:     *pcchDest = 0;

	mov	ecx, DWORD PTR _pcchDest$[ebp]
	mov	DWORD PTR [ecx], 0

; 12242: 
; 12243:     if (pcchDestLength)

	cmp	DWORD PTR _pcchDestLength$[ebp], 0
	je	SHORT $LN3@RtlUnicode@2

; 12244:     {
; 12245:         *pcchDestLength = 0;

	mov	edx, DWORD PTR _pcchDestLength$[ebp]
	mov	DWORD PTR [edx], 0
$LN3@RtlUnicode@2:

; 12246:     }
; 12247: 
; 12248:     status = RtlUnicodeStringValidateWorker(DestinationString, cchMax, dwFlags);

	mov	eax, DWORD PTR _dwFlags$[ebp]
	push	eax
	mov	ecx, DWORD PTR _cchMax$[ebp]
	push	ecx
	mov	edx, DWORD PTR _DestinationString$[ebp]
	push	edx
	call	_RtlUnicodeStringValidateWorker@12
	mov	DWORD PTR _status$[ebp], eax

; 12249: 
; 12250:     if (NT_SUCCESS(status) && DestinationString)

	cmp	DWORD PTR _status$[ebp], 0
	jl	SHORT $LN2@RtlUnicode@2
	cmp	DWORD PTR _DestinationString$[ebp], 0
	je	SHORT $LN2@RtlUnicode@2

; 12251:     {
; 12252:         *ppszDest = DestinationString->Buffer;

	mov	eax, DWORD PTR _ppszDest$[ebp]
	mov	ecx, DWORD PTR _DestinationString$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 12253:         *pcchDest = DestinationString->MaximumLength / sizeof(wchar_t);

	mov	eax, DWORD PTR _DestinationString$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	shr	ecx, 1
	mov	edx, DWORD PTR _pcchDest$[ebp]
	mov	DWORD PTR [edx], ecx

; 12254: 
; 12255:         if (pcchDestLength)

	cmp	DWORD PTR _pcchDestLength$[ebp], 0
	je	SHORT $LN2@RtlUnicode@2

; 12256:         {
; 12257:             *pcchDestLength = DestinationString->Length / sizeof(wchar_t);

	mov	eax, DWORD PTR _DestinationString$[ebp]
	movzx	ecx, WORD PTR [eax]
	shr	ecx, 1
	mov	edx, DWORD PTR _pcchDestLength$[ebp]
	mov	DWORD PTR [edx], ecx
$LN2@RtlUnicode@2:

; 12258:         }
; 12259:     }
; 12260: 
; 12261:     return status;

	mov	eax, DWORD PTR _status$[ebp]

; 12262: }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_RtlUnicodeStringValidateDestWorker@24 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _RtlUnicodeStringValidateWorker@12
_TEXT	SEGMENT
_status$ = -4						; size = 4
_SourceString$ = 8					; size = 4
_cchMax$ = 12						; size = 4
_dwFlags$ = 16						; size = 4
_RtlUnicodeStringValidateWorker@12 PROC			; COMDAT

; 12173: {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 12174:     NTSTATUS status = STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 12175: 
; 12176:     if (SourceString || !(dwFlags & STRSAFE_IGNORE_NULLS))

	cmp	DWORD PTR _SourceString$[ebp], 0
	jne	SHORT $LN6@RtlUnicode@3
	mov	eax, DWORD PTR _dwFlags$[ebp]
	and	eax, 256				; 00000100H
	jne	SHORT $LN7@RtlUnicode@3
$LN6@RtlUnicode@3:

; 12177:     {
; 12178:         if (((SourceString->Length % sizeof(wchar_t)) != 0)         ||
; 12179:             ((SourceString->MaximumLength % sizeof(wchar_t)) != 0)  ||
; 12180:             (SourceString->Length > SourceString->MaximumLength)    ||
; 12181:             (SourceString->MaximumLength > (cchMax * sizeof(wchar_t))))

	mov	ecx, DWORD PTR _SourceString$[ebp]
	movzx	eax, WORD PTR [ecx]
	xor	edx, edx
	mov	ecx, 2
	div	ecx
	test	edx, edx
	jne	SHORT $LN4@RtlUnicode@3
	mov	edx, DWORD PTR _SourceString$[ebp]
	movzx	eax, WORD PTR [edx+2]
	xor	edx, edx
	mov	ecx, 2
	div	ecx
	test	edx, edx
	jne	SHORT $LN4@RtlUnicode@3
	mov	edx, DWORD PTR _SourceString$[ebp]
	movzx	eax, WORD PTR [edx]
	mov	ecx, DWORD PTR _SourceString$[ebp]
	movzx	edx, WORD PTR [ecx+2]
	cmp	eax, edx
	jg	SHORT $LN4@RtlUnicode@3
	mov	eax, DWORD PTR _SourceString$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	mov	edx, DWORD PTR _cchMax$[ebp]
	shl	edx, 1
	cmp	ecx, edx
	jbe	SHORT $LN5@RtlUnicode@3
$LN4@RtlUnicode@3:

; 12182:         {
; 12183:             status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR _status$[ebp], -1073741811	; c000000dH

; 12184:         }
; 12185:         else if ((SourceString->Buffer == NULL) &&

	jmp	SHORT $LN7@RtlUnicode@3
$LN5@RtlUnicode@3:

; 12186:                  ((SourceString->Length != 0) || (SourceString->MaximumLength != 0)))

	mov	eax, DWORD PTR _SourceString$[ebp]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN7@RtlUnicode@3
	mov	ecx, DWORD PTR _SourceString$[ebp]
	movzx	edx, WORD PTR [ecx]
	test	edx, edx
	jne	SHORT $LN1@RtlUnicode@3
	mov	eax, DWORD PTR _SourceString$[ebp]
	movzx	ecx, WORD PTR [eax+2]
	test	ecx, ecx
	je	SHORT $LN7@RtlUnicode@3
$LN1@RtlUnicode@3:

; 12187:         {
; 12188:             status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR _status$[ebp], -1073741811	; c000000dH
$LN7@RtlUnicode@3:

; 12189:         }
; 12190:     }
; 12191: 
; 12192:     return status;

	mov	eax, DWORD PTR _status$[ebp]

; 12193: }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_RtlUnicodeStringValidateWorker@12 ENDP
_TEXT	ENDS
EXTRN	__imp___vsnwprintf:PROC
; Function compile flags: /Odtp
;	COMDAT _RtlWideCharArrayVPrintfWorker@20
_TEXT	SEGMENT
_status$ = -8						; size = 4
_iRet$ = -4						; size = 4
_pszDest$ = 8						; size = 4
_cchDest$ = 12						; size = 4
_pcchNewDestLength$ = 16				; size = 4
_pszFormat$ = 20					; size = 4
_argList$ = 24						; size = 4
_RtlWideCharArrayVPrintfWorker@20 PROC			; COMDAT

; 12374: {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 12375:     NTSTATUS status = STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 12376:     int iRet;
; 12377:     
; 12378:     #pragma warning(push)
; 12379:     #pragma warning(disable: __WARNING_BANNED_API_USAGE)// "STRSAFE not included"
; 12380:     iRet = _vsnwprintf(pszDest, cchDest, pszFormat, argList);

	mov	eax, DWORD PTR _argList$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszFormat$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cchDest$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszDest$[ebp]
	push	eax
	call	DWORD PTR __imp___vsnwprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iRet$[ebp], eax

; 12381:     #pragma warning(pop)
; 12382:     // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));
; 12383: 
; 12384:     if ((iRet < 0) || (((size_t)iRet) > cchDest))

	cmp	DWORD PTR _iRet$[ebp], 0
	jl	SHORT $LN2@RtlWideCha
	mov	ecx, DWORD PTR _iRet$[ebp]
	cmp	ecx, DWORD PTR _cchDest$[ebp]
	jbe	SHORT $LN3@RtlWideCha
$LN2@RtlWideCha:

; 12385:     {
; 12386:         *pcchNewDestLength = cchDest;

	mov	edx, DWORD PTR _pcchNewDestLength$[ebp]
	mov	eax, DWORD PTR _cchDest$[ebp]
	mov	DWORD PTR [edx], eax

; 12387: 
; 12388:         // we have truncated pszDest
; 12389:         status = STATUS_BUFFER_OVERFLOW;

	mov	DWORD PTR _status$[ebp], -2147483643	; 80000005H

; 12390:     }
; 12391:     else

	jmp	SHORT $LN1@RtlWideCha
$LN3@RtlWideCha:

; 12392:     {
; 12393:         *pcchNewDestLength = (size_t)iRet;

	mov	ecx, DWORD PTR _pcchNewDestLength$[ebp]
	mov	edx, DWORD PTR _iRet$[ebp]
	mov	DWORD PTR [ecx], edx
$LN1@RtlWideCha:

; 12394:     }
; 12395: 
; 12396:     return status;

	mov	eax, DWORD PTR _status$[ebp]

; 12397: }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_RtlWideCharArrayVPrintfWorker@20 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EI@HJAINLCB@FLT?5?9?5Master?5device?5created?4?5Dev@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CL@JPBGFCLD@FLT?5?9?5Failed?5to?5create?5the?5maste@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CG@DPMCLGJD@?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAM?$AAa?$AAs?$AAt?$AAe?$AAr?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0EI@HJAINLCB@FLT?5?9?5Master?5device?5created?4?5Dev@FNODOBFM@
; File b:\programm\wntsys\testfilter\release\1_1\source\driver\drvmain.cpp
text$s	SEGMENT
??_C@_0EI@HJAINLCB@FLT?5?9?5Master?5device?5created?4?5Dev@FNODOBFM@ DB 'F'
	DB	'LT - Master device created. Device object: %#p, device extens'
	DB	'ion: %#x', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CL@JPBGFCLD@FLT?5?9?5Failed?5to?5create?5the?5maste@FNODOBFM@
text$s	SEGMENT
??_C@_0CL@JPBGFCLD@FLT?5?9?5Failed?5to?5create?5the?5maste@FNODOBFM@ DB 'F'
	DB	'LT - Failed to create the master device.', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1CG@DPMCLGJD@?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAM?$AAa?$AAs?$AAt?$AAe?$AAr?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CG@DPMCLGJD@?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAM?$AAa?$AAs?$AAt?$AAe?$AAr?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@ DB 'F'
	DB	00H, 'i', 00H, 'l', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'M', 00H
	DB	'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'D', 00H, 'e'
	DB	00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?CreateMainDevice@@YGJPAU_DRIVER_OBJECT@@@Z
_TEXT	SEGMENT
_status$ = -8						; size = 4
_pMastDevObj$ = -4					; size = 4
_pDriverObject$ = 8					; size = 4
?CreateMainDevice@@YGJPAU_DRIVER_OBJECT@@@Z PROC	; CreateMainDevice, COMDAT

; 1056 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1057 : 	NTSTATUS status;
; 1058 : 
; 1059 : 	PDEVICE_OBJECT pMastDevObj;
; 1060 : 	status = CreateDevice(
; 1061 : 		pDriverObject,
; 1062 : 		MASTER_DEVICE_NAME,
; 1063 : 		sizeof (MADEVICE_EXTENSION),
; 1064 : 		&pMastDevObj,
; 1065 : 		-1,
; 1066 : 		NULL);

	push	0
	push	-1
	lea	eax, DWORD PTR _pMastDevObj$[ebp]
	push	eax
	push	24					; 00000018H
	push	OFFSET ??_C@_1CG@DPMCLGJD@?$AAF?$AAi?$AAl?$AAt?$AAe?$AAr?$AAM?$AAa?$AAs?$AAt?$AAe?$AAr?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?$AA@FNODOBFM@
	mov	ecx, DWORD PTR _pDriverObject$[ebp]
	push	ecx
	call	?CreateDevice@@YGJPAU_DRIVER_OBJECT@@PAGKPAPAU_DEVICE_OBJECT@@J1@Z ; CreateDevice
	mov	DWORD PTR _status$[ebp], eax

; 1067 : 	if (!NT_SUCCESS(status)) {

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN1@CreateMain

; 1068 : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1069 : 			"FLT - Failed to create the master device.\n"); 

	push	OFFSET ??_C@_0CL@JPBGFCLD@FLT?5?9?5Failed?5to?5create?5the?5maste@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 12					; 0000000cH

; 1070 : 		return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	SHORT $LN2@CreateMain
$LN1@CreateMain:

; 1071 : 	}
; 1072 : 	pMastDevExt = (PMADEVICE_EXTENSION) pMastDevObj->DeviceExtension;

	mov	edx, DWORD PTR _pMastDevObj$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR _pMastDevExt, eax

; 1073 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1074 : 		"FLT - Master device created. Device object: %#p, device "
; 1075 : 		"extension: %#x\n",
; 1076 : 		pMastDevObj,
; 1077 : 		pMastDevExt);

	mov	ecx, DWORD PTR _pMastDevExt
	push	ecx
	mov	edx, DWORD PTR _pMastDevObj$[ebp]
	push	edx
	push	OFFSET ??_C@_0EI@HJAINLCB@FLT?5?9?5Master?5device?5created?4?5Dev@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 20					; 00000014H

; 1078 : 	pMastDevObj->Flags |= DO_DIRECT_IO;

	mov	eax, DWORD PTR _pMastDevObj$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	or	ecx, 16					; 00000010H
	mov	edx, DWORD PTR _pMastDevObj$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 1079 : 	pMastDevExt->hdr.pDevice = pMastDevObj;

	mov	eax, DWORD PTR _pMastDevExt
	mov	ecx, DWORD PTR _pMastDevObj$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 1080 : 	pMastDevExt->hdr.DevType = DT_MASTER;

	mov	edx, DWORD PTR _pMastDevExt
	mov	DWORD PTR [edx], 0

; 1081 : 	KeInitializeSpinLock(
; 1082 : 		&pMastDevExt->SyncLock);

	mov	eax, DWORD PTR _pMastDevExt
	add	eax, 8
	push	eax
	call	_KeInitializeSpinLock@4

; 1083 : 	InitializeListHead(&pMastDevExt->FADevsList);

	mov	ecx, DWORD PTR _pMastDevExt
	add	ecx, 12					; 0000000cH
	push	ecx
	call	_InitializeListHead@4

; 1084 : 	pMastDevExt->FADevsCount = 0;

	mov	edx, DWORD PTR _pMastDevExt
	mov	DWORD PTR [edx+20], 0

; 1085 : 
; 1086 : 	return STATUS_SUCCESS;

	xor	eax, eax
$LN2@CreateMain:

; 1087 : 		
; 1088 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CreateMainDevice@@YGJPAU_DRIVER_OBJECT@@@Z ENDP	; CreateMainDevice
_TEXT	ENDS
PUBLIC	??_C@_0DG@FLIENFEL@FLT?5?9?5DpcCltIrpCompletion?5?9?5Clie@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_RemoveHeadList@4
PUBLIC	_IsListEmpty@4
EXTRN	__imp_@IofCompleteRequest@8:PROC
;	COMDAT ??_C@_0DG@FLIENFEL@FLT?5?9?5DpcCltIrpCompletion?5?9?5Clie@FNODOBFM@
text$s	SEGMENT
??_C@_0DG@FLIENFEL@FLT?5?9?5DpcCltIrpCompletion?5?9?5Clie@FNODOBFM@ DB 'F'
	DB	'LT - DpcCltIrpCompletion - Client Irp %#p completed', 0aH, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?DpcCltIrpCompletion@@YGXPAU_KDPC@@PAX11@Z
_TEXT	SEGMENT
_pItem$26425 = -28					; size = 4
_pIrp$26426 = -24					; size = 4
_pDevExt$ = -20						; size = 4
_pWCompl$ = -16						; size = 4
_LockHandle$ = -12					; size = 12
_Dpc$ = 8						; size = 4
_DeferredContext$ = 12					; size = 4
_SystemArgument1$ = 16					; size = 4
_SystemArgument2$ = 20					; size = 4
?DpcCltIrpCompletion@@YGXPAU_KDPC@@PAX11@Z PROC		; DpcCltIrpCompletion, COMDAT

; 1319 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1320 : 	PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION) DeferredContext;

	mov	eax, DWORD PTR _DeferredContext$[ebp]
	mov	DWORD PTR _pDevExt$[ebp], eax

; 1321 : 	PLIST_ENTRY pWCompl = &pDevExt->pWaitingComplIrpList;

	mov	ecx, DWORD PTR _pDevExt$[ebp]
	add	ecx, 208				; 000000d0H
	mov	DWORD PTR _pWCompl$[ebp], ecx
$LN3@DpcCltIrpC:

; 1322 : 	KLOCK_QUEUE_HANDLE LockHandle;
; 1323 : 	for (;;) {
; 1324 : 		KeAcquireInStackQueuedSpinLock(&pDevExt->DataLock, &LockHandle);

	mov	ecx, DWORD PTR _pDevExt$[ebp]
	add	ecx, 68					; 00000044H
	lea	edx, DWORD PTR _LockHandle$[ebp]
	call	DWORD PTR __imp_@KeAcquireInStackQueuedSpinLock@8

; 1325 : 		if (IsListEmpty(pWCompl)) {

	mov	edx, DWORD PTR _pWCompl$[ebp]
	push	edx
	call	_IsListEmpty@4
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@DpcCltIrpC

; 1326 : 			KeReleaseInStackQueuedSpinLock(&LockHandle);

	lea	ecx, DWORD PTR _LockHandle$[ebp]
	call	DWORD PTR __imp_@KeReleaseInStackQueuedSpinLock@4

; 1327 : 			break;

	jmp	SHORT $LN4@DpcCltIrpC
$LN1@DpcCltIrpC:

; 1328 : 		}
; 1329 : 		PLIST_ENTRY pItem = RemoveHeadList(pWCompl);

	mov	ecx, DWORD PTR _pWCompl$[ebp]
	push	ecx
	call	_RemoveHeadList@4
	mov	DWORD PTR _pItem$26425[ebp], eax

; 1330 : 		KeReleaseInStackQueuedSpinLock(&LockHandle);

	lea	ecx, DWORD PTR _LockHandle$[ebp]
	call	DWORD PTR __imp_@KeReleaseInStackQueuedSpinLock@4

; 1331 : 		PIRP pIrp = 
; 1332 : 			CONTAINING_RECORD(pItem, IRP, Tail.Overlay.ListEntry);

	mov	edx, DWORD PTR _pItem$26425[ebp]
	sub	edx, 88					; 00000058H
	mov	DWORD PTR _pIrp$26426[ebp], edx

; 1333 : 
; 1334 : 		IoSetCancelRoutine(pIrp, NULL);

	xor	eax, eax
	mov	ecx, DWORD PTR _pIrp$26426[ebp]
	add	ecx, 56					; 00000038H
	xchg	DWORD PTR [ecx], eax

; 1335 : 		IoCompleteRequest(pIrp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _pIrp$26426[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 1336 : 
; 1337 : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1338 : 			"FLT - DpcCltIrpCompletion - Client Irp %#p "
; 1339 : 			"completed\n", pIrp);

	mov	edx, DWORD PTR _pIrp$26426[ebp]
	push	edx
	push	OFFSET ??_C@_0DG@FLIENFEL@FLT?5?9?5DpcCltIrpCompletion?5?9?5Clie@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 16					; 00000010H
	jmp	SHORT $LN3@DpcCltIrpC
$LN4@DpcCltIrpC:

; 1340 : 	}
; 1341 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?DpcCltIrpCompletion@@YGXPAU_KDPC@@PAX11@Z ENDP		; DpcCltIrpCompletion
; Function compile flags: /Odtp
; File c:\apps\pw7hp\devpgm\msddk\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT _IsListEmpty@4
_TEXT	SEGMENT
_ListHead$ = 8						; size = 4
_IsListEmpty@4 PROC					; COMDAT

; 7560 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 7561 :     return (BOOLEAN)(ListHead->Flink == ListHead);

	mov	eax, DWORD PTR _ListHead$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _ListHead$[ebp]
	sete	al

; 7562 : }

	pop	ebp
	ret	4
_IsListEmpty@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _RemoveHeadList@4
_TEXT	SEGMENT
_Flink$ = -8						; size = 4
_Entry$ = -4						; size = 4
_ListHead$ = 8						; size = 4
_RemoveHeadList@4 PROC					; COMDAT

; 7585 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 7586 :     PLIST_ENTRY Flink;
; 7587 :     PLIST_ENTRY Entry;
; 7588 : 
; 7589 :     Entry = ListHead->Flink;

	mov	eax, DWORD PTR _ListHead$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _Entry$[ebp], ecx

; 7590 :     Flink = Entry->Flink;

	mov	edx, DWORD PTR _Entry$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _Flink$[ebp], eax

; 7591 :     ListHead->Flink = Flink;

	mov	ecx, DWORD PTR _ListHead$[ebp]
	mov	edx, DWORD PTR _Flink$[ebp]
	mov	DWORD PTR [ecx], edx

; 7592 :     Flink->Blink = ListHead;

	mov	eax, DWORD PTR _Flink$[ebp]
	mov	ecx, DWORD PTR _ListHead$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 7593 :     return Entry;

	mov	eax, DWORD PTR _Entry$[ebp]

; 7594 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_RemoveHeadList@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DO@BAPDNIJJ@FLT?5?9?5GetTargDevInfo?5?9?5Filter?3?5?$CF@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_IoGetNextIrpStackLocation@4
EXTRN	__imp__IoFreeIrp@4:PROC
EXTRN	__imp__IoReuseIrp@8:PROC
EXTRN	__imp__IoAllocateIrp@8:PROC
EXTRN	__imp__KeInitializeEvent@12:PROC
;	COMDAT ??_C@_0DO@BAPDNIJJ@FLT?5?9?5GetTargDevInfo?5?9?5Filter?3?5?$CF@FNODOBFM@
; File b:\programm\wntsys\testfilter\release\1_1\source\driver\drvmain.cpp
text$s	SEGMENT
??_C@_0DO@BAPDNIJJ@FLT?5?9?5GetTargDevInfo?5?9?5Filter?3?5?$CF@FNODOBFM@ DB 'F'
	DB	'LT - GetTargDevInfo - Filter: %#x, FA: %#x, device text: %S', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?GetTargDevInfo@@YGJPAU_FADEVICE_EXTENSION@@@Z
_TEXT	SEGMENT
_pQueryIrp$ = -44					; size = 4
_IrpStatus$ = -40					; size = 4
_status$ = -36						; size = 4
_StackSize$ = -29					; size = 1
_IrpComplEv$ = -28					; size = 16
_pStack$ = -12						; size = 4
_pTargStack$ = -8					; size = 4
_pFltDevExt$ = -4					; size = 4
_pFaDevExt$ = 8						; size = 4
?GetTargDevInfo@@YGJPAU_FADEVICE_EXTENSION@@@Z PROC	; GetTargDevInfo, COMDAT

; 1897 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 1898 : 	// We will send PNP IRPs to the target stack to query its
; 1899 : 	// information.
; 1900 : 
; 1901 : 	NTSTATUS status = STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 1902 : 	KEVENT IrpComplEv;
; 1903 : 
; 1904 : 	// Initialize the event used to wait for IRPs to complete
; 1905 : 	//
; 1906 : 	KeInitializeEvent(&IrpComplEv, NotificationEvent, FALSE);

	push	0
	push	0
	lea	eax, DWORD PTR _IrpComplEv$[ebp]
	push	eax
	call	DWORD PTR __imp__KeInitializeEvent@12

; 1907 : 
; 1908 : 
; 1909 : 	// Get the number of stack locations needed.
; 1910 : 	//
; 1911 : 	PDEVICE_EXTENSION pFltDevExt = pFaDevExt->pFilterDevExt;

	mov	ecx, DWORD PTR _pFaDevExt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _pFltDevExt$[ebp], edx

; 1912 : 	PDEVICE_OBJECT pTargStack = pFltDevExt->pTargStack;

	mov	eax, DWORD PTR _pFltDevExt$[ebp]
	mov	ecx, DWORD PTR [eax+204]
	mov	DWORD PTR _pTargStack$[ebp], ecx

; 1913 : 	CCHAR StackSize = pTargStack->StackSize;

	mov	edx, DWORD PTR _pTargStack$[ebp]
	mov	al, BYTE PTR [edx+48]
	mov	BYTE PTR _StackSize$[ebp], al

; 1914 : 
; 1915 : 	// Note on the stack size.
; 1916 : 	//
; 1917 : 	// pTargStack->StackSize gives the # of stack locations needed by
; 1918 : 	// the device below our filter.
; 1919 : 	//
; 1920 : 	// We will allocate an IRP with this number of stack locations,
; 1921 : 	// so it will not have a stack location for the filter device.
; 1922 : 	//
; 1923 : 	// We don't need it, because we only need to pass the IRP down
; 1924 : 	// the stack, with a completion routine attached, to get the
; 1925 : 	// outcome. IoSetCompletionRoutine() actually sets the routine 
; 1926 : 	// address into the stack location below the current one, so
; 1927 : 	// this call does not need a stack location for the current device.
; 1928 : 	//
; 1929 : 	// By examining IoGetCurrentIrpStackLocation(),
; 1930 : 	// IoGetNextIrpStackLocation() and IoSetNextIrpStackLocation()
; 1931 : 	// in wdm.h, we find out that the stack location for the topmost
; 1932 : 	// device is the one at the highest address.
; 1933 : 	// IoGetCurrentIrpStackLocation() returns the value of a pointer
; 1934 : 	// stored inside the IRP. Calling IoGetNextIrpStackLocation() 
; 1935 : 	// returns the address of the current SL pointer minus the size of 
; 1936 : 	// an SL, i. e., the SL for the device below us is at the next lower 
; 1937 : 	// address.
; 1938 : 	//
; 1939 : 	// We also find that IoSetNextIrpStackLocation() decrements the
; 1940 : 	// current SL pointer.
; 1941 : 	//
; 1942 : 	// We can put these facts together with how we use an IRP we 
; 1943 : 	// are setting up: after the allocation, we can immediately 
; 1944 : 	// call IoGetNextIrpStackLocation() to grab tha SL for the device
; 1945 : 	// below us and set the relevant fields. This means the current SL
; 1946 : 	// pointer has the address of the SL for the next device + the
; 1947 : 	// size of an SL, because IoGetNextIrpStackLocation() just returns
; 1948 : 	// current ptr minus SL size.
; 1949 : 	//
; 1950 : 	// Yet, since the SL for the device below us is the one at the 
; 1951 : 	// highest address (when we don't allocate an extra SL for 
; 1952 : 	// ourselves), this means the current SL pointer is actually 
; 1953 : 	// pointing outside our IRP at whatever lays after it.
; 1954 : 	//
; 1955 : 	// This is confirmed by the DDK, which states:
; 1956 : 	//
; 1957 : 	// "If a driver allocates an I/O stack location of its own in a new 
; 1958 : 	// IRP, the dispatch routine must call IoSetNextIrpStackLocation 
; 1959 : 	// before it calls IoGetCurrentIrpStackLocation to set up context in
; 1960 : 	// its own I/O stack location...".
; 1961 : 	//
; 1962 : 	// IoSetNextIrpStackLocation() just decrements the current SL 
; 1963 : 	// pointer by the size of an SL and IoGetCurrentIrpStackLocation()
; 1964 : 	// just returns the current pointer value. So, BEFORE using the
; 1965 : 	// current pointer value, we must decrement it, because it's
; 1966 : 	// pointing outside the IRP.
; 1967 : 	//
; 1968 : 	// In other words, a freshly initialized IRP has its current SL
; 1969 : 	// pointer set to an address outside the IRP. If we know we have
; 1970 : 	// reserved one extra SL for us, we can decrement it, with
; 1971 : 	// IoSet..., otherwise we are forbidden to touch the current
; 1972 : 	// SL (which actually does not exist) and must restrict ourselves
; 1973 : 	// to using the next one, returned by IoGetNext... which returns
; 1974 : 	// current ptr minus size.
; 1975 : 	//
; 1976 : 	// Probably, arraging SLs this way helps the system in detecting 
; 1977 : 	// when some code is trying to use an IRP with too few SLs for a 
; 1978 : 	// given device tree. As the IRP travels down the stack, the current
; 1979 : 	// SL ptr is decremented, so the system can detect if it bumps 
; 1980 : 	// against the beginning of the SLs array inside the IRP. If the 
; 1981 : 	// system were to increment the SL ptr, it should have kept track of 
; 1982 : 	// the SLs array size to perform the same check.
; 1983 : 
; 1984 : 	// Allocate the IRP
; 1985 : 	//
; 1986 : 	PIRP pQueryIrp = IoAllocateIrp(StackSize, FALSE);

	push	0
	movzx	ecx, BYTE PTR _StackSize$[ebp]
	push	ecx
	call	DWORD PTR __imp__IoAllocateIrp@8
	mov	DWORD PTR _pQueryIrp$[ebp], eax

; 1987 : 	if (pQueryIrp == NULL) return STATUS_NO_MEMORY;

	cmp	DWORD PTR _pQueryIrp$[ebp], 0
	jne	SHORT $LN16@GetTargDev
	mov	eax, -1073741801			; c0000017H
	jmp	$LN17@GetTargDev
$LN16@GetTargDev:

; 1988 : 
; 1989 : 	// Set the IRP up
; 1990 : 	//
; 1991 : 	pQueryIrp->Flags = 0;

	mov	edx, DWORD PTR _pQueryIrp$[ebp]
	mov	DWORD PTR [edx+8], 0

; 1992 : 	pQueryIrp->RequestorMode = KernelMode;

	mov	eax, DWORD PTR _pQueryIrp$[ebp]
	mov	BYTE PTR [eax+32], 0

; 1993 : 	pQueryIrp->Tail.Overlay.Thread = 0;

	mov	ecx, DWORD PTR _pQueryIrp$[ebp]
	mov	DWORD PTR [ecx+80], 0

; 1994 : 	pQueryIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;

	mov	edx, DWORD PTR _pQueryIrp$[ebp]
	mov	DWORD PTR [edx+24], -1073741637		; c00000bbH

; 1995 : 
; 1996 : 	// Set the I/O stack for the IRP_MN_QUERY_DEVICE_TEXT call.
; 1997 : 	//
; 1998 : 	PIO_STACK_LOCATION pStack = IoGetNextIrpStackLocation(pQueryIrp);

	mov	eax, DWORD PTR _pQueryIrp$[ebp]
	push	eax
	call	_IoGetNextIrpStackLocation@4
	mov	DWORD PTR _pStack$[ebp], eax

; 1999 : 	pStack->MajorFunction = IRP_MJ_PNP;

	mov	ecx, DWORD PTR _pStack$[ebp]
	mov	BYTE PTR [ecx], 27			; 0000001bH

; 2000 : 	pStack->MinorFunction = IRP_MN_QUERY_DEVICE_TEXT;

	mov	edx, DWORD PTR _pStack$[ebp]
	mov	BYTE PTR [edx+1], 12			; 0000000cH

; 2001 : 	pStack->Flags = 0;

	mov	eax, DWORD PTR _pStack$[ebp]
	mov	BYTE PTR [eax+2], 0

; 2002 : 	pStack->DeviceObject = pTargStack;

	mov	ecx, DWORD PTR _pStack$[ebp]
	mov	edx, DWORD PTR _pTargStack$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 2003 : 
; 2004 : 	// Send the IRP. We'll wait for it to complete.
; 2005 : 	//
; 2006 : 	NTSTATUS IrpStatus = SendIrpSync(pQueryIrp, &IrpComplEv);

	lea	eax, DWORD PTR _IrpComplEv$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pQueryIrp$[ebp]
	push	ecx
	call	?SendIrpSync@@YGJPAU_IRP@@PAU_KEVENT@@@Z ; SendIrpSync
	mov	DWORD PTR _IrpStatus$[ebp], eax

; 2007 : 	if (NT_SUCCESS(IrpStatus)) {

	cmp	DWORD PTR _IrpStatus$[ebp], 0
	jl	SHORT $LN15@GetTargDev

; 2008 : 
; 2009 : 		// Get the device text
; 2010 : 		//
; 2011 : 		if (pQueryIrp->IoStatus.Information) {

	mov	edx, DWORD PTR _pQueryIrp$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN15@GetTargDev

; 2012 : 			DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 2013 : 				"FLT - GetTargDevInfo - Filter: %#x, FA: %#x, "
; 2014 : 				"device text: %S\n",
; 2015 : 				pFaDevExt->pFilterDevExt->hdr.pDevice,
; 2016 : 				pFaDevExt->hdr.pDevice,
; 2017 : 				(PWCHAR) pQueryIrp->IoStatus.Information);

	mov	eax, DWORD PTR _pQueryIrp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _pFaDevExt$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	mov	ecx, DWORD PTR _pFaDevExt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	OFFSET ??_C@_0DO@BAPDNIJJ@FLT?5?9?5GetTargDevInfo?5?9?5Filter?3?5?$CF@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 24					; 00000018H

; 2018 : 			CopyWString(
; 2019 : 				(PWCHAR) &pFaDevExt->TargDevInfo.DeviceText, 
; 2020 : 				(PWCHAR) pQueryIrp->IoStatus.Information,
; 2021 : 				sizeof pFaDevExt->TargDevInfo.DeviceText);

	push	202					; 000000caH
	mov	ecx, DWORD PTR _pQueryIrp$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR _pFaDevExt$[ebp]
	add	eax, 520				; 00000208H
	push	eax
	call	?CopyWString@@YGXPAG0K@Z		; CopyWString

; 2022 : 
; 2023 : 			// We must free the storage for the string allocated by the
; 2024 : 			// driver which processed our IRP, just as the I/O manager
; 2025 : 			// would do.
; 2026 : 			ExFreePool((PVOID) pQueryIrp->IoStatus.Information);

	push	0
	mov	ecx, DWORD PTR _pQueryIrp$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	call	DWORD PTR __imp__ExFreePoolWithTag@8
$LN15@GetTargDev:

; 2027 : 
; 2028 : 		}
; 2029 : 	}
; 2030 : 
; 2031 : 	// The status variable stores the overall status. Update it only
; 2032 : 	// if it does not already hold an error value.
; 2033 : 	//
; 2034 : 	if (NT_SUCCESS(status)) status = IrpStatus;

	cmp	DWORD PTR _status$[ebp], 0
	jl	SHORT $LN13@GetTargDev
	mov	eax, DWORD PTR _IrpStatus$[ebp]
	mov	DWORD PTR _status$[ebp], eax
$LN13@GetTargDev:

; 2035 : 
; 2036 : 	// Set the IRP up for th IRP_MQ_QUERY_ID/BusQueryDeviceId
; 2037 : 	//
; 2038 : 	IoReuseIrp(pQueryIrp, STATUS_NOT_SUPPORTED);

	push	-1073741637				; c00000bbH
	mov	ecx, DWORD PTR _pQueryIrp$[ebp]
	push	ecx
	call	DWORD PTR __imp__IoReuseIrp@8

; 2039 : 	// IoSetNextIrpStackLocation(pQueryIrp);
; 2040 : 	pQueryIrp->Flags = 0;

	mov	edx, DWORD PTR _pQueryIrp$[ebp]
	mov	DWORD PTR [edx+8], 0

; 2041 : 	pQueryIrp->RequestorMode = KernelMode;

	mov	eax, DWORD PTR _pQueryIrp$[ebp]
	mov	BYTE PTR [eax+32], 0

; 2042 : 	pQueryIrp->Tail.Overlay.Thread = 0;

	mov	ecx, DWORD PTR _pQueryIrp$[ebp]
	mov	DWORD PTR [ecx+80], 0

; 2043 : 	pStack = IoGetNextIrpStackLocation(pQueryIrp);

	mov	edx, DWORD PTR _pQueryIrp$[ebp]
	push	edx
	call	_IoGetNextIrpStackLocation@4
	mov	DWORD PTR _pStack$[ebp], eax

; 2044 : 	pStack->MajorFunction = IRP_MJ_PNP;

	mov	eax, DWORD PTR _pStack$[ebp]
	mov	BYTE PTR [eax], 27			; 0000001bH

; 2045 : 	pStack->MinorFunction = IRP_MN_QUERY_ID;

	mov	ecx, DWORD PTR _pStack$[ebp]
	mov	BYTE PTR [ecx+1], 19			; 00000013H

; 2046 : 	pStack->Parameters.QueryId.IdType = BusQueryDeviceID;

	mov	edx, DWORD PTR _pStack$[ebp]
	mov	DWORD PTR [edx+4], 0

; 2047 : 	pStack->Flags = 0;

	mov	eax, DWORD PTR _pStack$[ebp]
	mov	BYTE PTR [eax+2], 0

; 2048 : 	pStack->DeviceObject = pTargStack;

	mov	ecx, DWORD PTR _pStack$[ebp]
	mov	edx, DWORD PTR _pTargStack$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 2049 : 	IrpStatus = SendIrpSync(pQueryIrp, &IrpComplEv);

	lea	eax, DWORD PTR _IrpComplEv$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pQueryIrp$[ebp]
	push	ecx
	call	?SendIrpSync@@YGJPAU_IRP@@PAU_KEVENT@@@Z ; SendIrpSync
	mov	DWORD PTR _IrpStatus$[ebp], eax

; 2050 : 	if (NT_SUCCESS(IrpStatus)) {

	cmp	DWORD PTR _IrpStatus$[ebp], 0
	jl	SHORT $LN12@GetTargDev

; 2051 : 		if (pQueryIrp->IoStatus.Information) {

	mov	edx, DWORD PTR _pQueryIrp$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN12@GetTargDev

; 2052 : 			CopyWString(
; 2053 : 				(PWCHAR) &pFaDevExt->TargDevInfo.DeviceId, 
; 2054 : 				(PWCHAR) pQueryIrp->IoStatus.Information,
; 2055 : 				sizeof pFaDevExt->TargDevInfo.DeviceId);

	push	202					; 000000caH
	mov	eax, DWORD PTR _pQueryIrp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _pFaDevExt$[ebp]
	add	edx, 318				; 0000013eH
	push	edx
	call	?CopyWString@@YGXPAG0K@Z		; CopyWString

; 2056 : 			ExFreePool((PVOID) pQueryIrp->IoStatus.Information);

	push	0
	mov	eax, DWORD PTR _pQueryIrp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	DWORD PTR __imp__ExFreePoolWithTag@8
$LN12@GetTargDev:

; 2057 : 		}
; 2058 : 	}
; 2059 : 	if (NT_SUCCESS(status)) status = IrpStatus;

	cmp	DWORD PTR _status$[ebp], 0
	jl	SHORT $LN10@GetTargDev
	mov	edx, DWORD PTR _IrpStatus$[ebp]
	mov	DWORD PTR _status$[ebp], edx
$LN10@GetTargDev:

; 2060 : 
; 2061 : 	// Set the IRP up for th IRP_MQ_QUERY_ID/BusQueryInstanceID
; 2062 : 	//
; 2063 : 	IoReuseIrp(pQueryIrp, STATUS_NOT_SUPPORTED);

	push	-1073741637				; c00000bbH
	mov	eax, DWORD PTR _pQueryIrp$[ebp]
	push	eax
	call	DWORD PTR __imp__IoReuseIrp@8

; 2064 : 	pQueryIrp->Flags = 0;

	mov	ecx, DWORD PTR _pQueryIrp$[ebp]
	mov	DWORD PTR [ecx+8], 0

; 2065 : 	pQueryIrp->RequestorMode = KernelMode;

	mov	edx, DWORD PTR _pQueryIrp$[ebp]
	mov	BYTE PTR [edx+32], 0

; 2066 : 	pQueryIrp->Tail.Overlay.Thread = 0;

	mov	eax, DWORD PTR _pQueryIrp$[ebp]
	mov	DWORD PTR [eax+80], 0

; 2067 : 	pStack = IoGetNextIrpStackLocation(pQueryIrp);

	mov	ecx, DWORD PTR _pQueryIrp$[ebp]
	push	ecx
	call	_IoGetNextIrpStackLocation@4
	mov	DWORD PTR _pStack$[ebp], eax

; 2068 : 	pStack->MajorFunction = IRP_MJ_PNP;

	mov	edx, DWORD PTR _pStack$[ebp]
	mov	BYTE PTR [edx], 27			; 0000001bH

; 2069 : 	pStack->MinorFunction = IRP_MN_QUERY_ID;

	mov	eax, DWORD PTR _pStack$[ebp]
	mov	BYTE PTR [eax+1], 19			; 00000013H

; 2070 : 	pStack->Parameters.QueryId.IdType = BusQueryInstanceID;

	mov	ecx, DWORD PTR _pStack$[ebp]
	mov	DWORD PTR [ecx+4], 3

; 2071 : 	pStack->Flags = 0;

	mov	edx, DWORD PTR _pStack$[ebp]
	mov	BYTE PTR [edx+2], 0

; 2072 : 	pStack->DeviceObject = pTargStack;

	mov	eax, DWORD PTR _pStack$[ebp]
	mov	ecx, DWORD PTR _pTargStack$[ebp]
	mov	DWORD PTR [eax+20], ecx

; 2073 : 	IrpStatus = SendIrpSync(pQueryIrp, &IrpComplEv);

	lea	edx, DWORD PTR _IrpComplEv$[ebp]
	push	edx
	mov	eax, DWORD PTR _pQueryIrp$[ebp]
	push	eax
	call	?SendIrpSync@@YGJPAU_IRP@@PAU_KEVENT@@@Z ; SendIrpSync
	mov	DWORD PTR _IrpStatus$[ebp], eax

; 2074 : 	if (NT_SUCCESS(IrpStatus)) {

	cmp	DWORD PTR _IrpStatus$[ebp], 0
	jl	SHORT $LN9@GetTargDev

; 2075 : 		if (pQueryIrp->IoStatus.Information) {

	mov	ecx, DWORD PTR _pQueryIrp$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	je	SHORT $LN9@GetTargDev

; 2076 : 			CopyWString(
; 2077 : 				(PWCHAR) &pFaDevExt->TargDevInfo.InstanceId, 
; 2078 : 				(PWCHAR) pQueryIrp->IoStatus.Information,
; 2079 : 				sizeof pFaDevExt->TargDevInfo.InstanceId);

	push	202					; 000000caH
	mov	edx, DWORD PTR _pQueryIrp$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR _pFaDevExt$[ebp]
	add	ecx, 924				; 0000039cH
	push	ecx
	call	?CopyWString@@YGXPAG0K@Z		; CopyWString

; 2080 : 			ExFreePool((PVOID) pQueryIrp->IoStatus.Information);

	push	0
	mov	edx, DWORD PTR _pQueryIrp$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	call	DWORD PTR __imp__ExFreePoolWithTag@8
$LN9@GetTargDev:

; 2081 : 		}
; 2082 : 	}
; 2083 : 	if (NT_SUCCESS(status)) status = IrpStatus;

	cmp	DWORD PTR _status$[ebp], 0
	jl	SHORT $LN7@GetTargDev
	mov	ecx, DWORD PTR _IrpStatus$[ebp]
	mov	DWORD PTR _status$[ebp], ecx
$LN7@GetTargDev:

; 2084 : 
; 2085 : 	// Set the IRP up for th IRP_MQ_QUERY_ID/BusQueryHardwareIDs
; 2086 : 	//
; 2087 : 	IoReuseIrp(pQueryIrp, STATUS_NOT_SUPPORTED);

	push	-1073741637				; c00000bbH
	mov	edx, DWORD PTR _pQueryIrp$[ebp]
	push	edx
	call	DWORD PTR __imp__IoReuseIrp@8

; 2088 : 	// IoSetNextIrpStackLocation(pQueryIrp);
; 2089 : 	pQueryIrp->Flags = 0;

	mov	eax, DWORD PTR _pQueryIrp$[ebp]
	mov	DWORD PTR [eax+8], 0

; 2090 : 	pQueryIrp->RequestorMode = KernelMode;

	mov	ecx, DWORD PTR _pQueryIrp$[ebp]
	mov	BYTE PTR [ecx+32], 0

; 2091 : 	pQueryIrp->Tail.Overlay.Thread = 0;

	mov	edx, DWORD PTR _pQueryIrp$[ebp]
	mov	DWORD PTR [edx+80], 0

; 2092 : 	pStack = IoGetNextIrpStackLocation(pQueryIrp);

	mov	eax, DWORD PTR _pQueryIrp$[ebp]
	push	eax
	call	_IoGetNextIrpStackLocation@4
	mov	DWORD PTR _pStack$[ebp], eax

; 2093 : 	pStack->MajorFunction = IRP_MJ_PNP;

	mov	ecx, DWORD PTR _pStack$[ebp]
	mov	BYTE PTR [ecx], 27			; 0000001bH

; 2094 : 	pStack->MinorFunction = IRP_MN_QUERY_ID;

	mov	edx, DWORD PTR _pStack$[ebp]
	mov	BYTE PTR [edx+1], 19			; 00000013H

; 2095 : 	pStack->Parameters.QueryId.IdType = BusQueryHardwareIDs;

	mov	eax, DWORD PTR _pStack$[ebp]
	mov	DWORD PTR [eax+4], 1

; 2096 : 	pStack->Flags = 0;

	mov	ecx, DWORD PTR _pStack$[ebp]
	mov	BYTE PTR [ecx+2], 0

; 2097 : 	pStack->DeviceObject = pTargStack;

	mov	edx, DWORD PTR _pStack$[ebp]
	mov	eax, DWORD PTR _pTargStack$[ebp]
	mov	DWORD PTR [edx+20], eax

; 2098 : 	IrpStatus = SendIrpSync(pQueryIrp, &IrpComplEv);

	lea	ecx, DWORD PTR _IrpComplEv$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pQueryIrp$[ebp]
	push	edx
	call	?SendIrpSync@@YGJPAU_IRP@@PAU_KEVENT@@@Z ; SendIrpSync
	mov	DWORD PTR _IrpStatus$[ebp], eax

; 2099 : 	if (NT_SUCCESS(IrpStatus)) {

	cmp	DWORD PTR _IrpStatus$[ebp], 0
	jl	SHORT $LN6@GetTargDev

; 2100 : 		if (pQueryIrp->IoStatus.Information) {

	mov	eax, DWORD PTR _pQueryIrp$[ebp]
	cmp	DWORD PTR [eax+28], 0
	je	SHORT $LN6@GetTargDev

; 2101 : 			CopyMultiWString(
; 2102 : 				(PWCHAR) &pFaDevExt->TargDevInfo.HardwareIDs, 
; 2103 : 				(PWCHAR) pQueryIrp->IoStatus.Information,
; 2104 : 				sizeof pFaDevExt->TargDevInfo.HardwareIDs);

	push	202					; 000000caH
	mov	ecx, DWORD PTR _pQueryIrp$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR _pFaDevExt$[ebp]
	add	eax, 722				; 000002d2H
	push	eax
	call	?CopyMultiWString@@YGXPAG0K@Z		; CopyMultiWString

; 2105 : 			ExFreePool((PVOID) pQueryIrp->IoStatus.Information);

	push	0
	mov	ecx, DWORD PTR _pQueryIrp$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	call	DWORD PTR __imp__ExFreePoolWithTag@8
$LN6@GetTargDev:

; 2106 : 		}
; 2107 : 	}
; 2108 : 	if (NT_SUCCESS(status)) status = IrpStatus;

	cmp	DWORD PTR _status$[ebp], 0
	jl	SHORT $LN4@GetTargDev
	mov	eax, DWORD PTR _IrpStatus$[ebp]
	mov	DWORD PTR _status$[ebp], eax
$LN4@GetTargDev:

; 2109 : 
; 2110 : 	// Set the IRP up for th IRP_MQ_QUERY_ID/BusQueryCompatibleIDs
; 2111 : 	//
; 2112 : 	IoReuseIrp(pQueryIrp, STATUS_NOT_SUPPORTED);

	push	-1073741637				; c00000bbH
	mov	ecx, DWORD PTR _pQueryIrp$[ebp]
	push	ecx
	call	DWORD PTR __imp__IoReuseIrp@8

; 2113 : 	pQueryIrp->Flags = 0;

	mov	edx, DWORD PTR _pQueryIrp$[ebp]
	mov	DWORD PTR [edx+8], 0

; 2114 : 	pQueryIrp->RequestorMode = KernelMode;

	mov	eax, DWORD PTR _pQueryIrp$[ebp]
	mov	BYTE PTR [eax+32], 0

; 2115 : 	pQueryIrp->Tail.Overlay.Thread = 0;

	mov	ecx, DWORD PTR _pQueryIrp$[ebp]
	mov	DWORD PTR [ecx+80], 0

; 2116 : 	pStack = IoGetNextIrpStackLocation(pQueryIrp);

	mov	edx, DWORD PTR _pQueryIrp$[ebp]
	push	edx
	call	_IoGetNextIrpStackLocation@4
	mov	DWORD PTR _pStack$[ebp], eax

; 2117 : 	pStack->MajorFunction = IRP_MJ_PNP;

	mov	eax, DWORD PTR _pStack$[ebp]
	mov	BYTE PTR [eax], 27			; 0000001bH

; 2118 : 	pStack->MinorFunction = IRP_MN_QUERY_ID;

	mov	ecx, DWORD PTR _pStack$[ebp]
	mov	BYTE PTR [ecx+1], 19			; 00000013H

; 2119 : 	pStack->Parameters.QueryId.IdType = BusQueryCompatibleIDs;

	mov	edx, DWORD PTR _pStack$[ebp]
	mov	DWORD PTR [edx+4], 2

; 2120 : 	pStack->Flags = 0;

	mov	eax, DWORD PTR _pStack$[ebp]
	mov	BYTE PTR [eax+2], 0

; 2121 : 	pStack->DeviceObject = pTargStack;

	mov	ecx, DWORD PTR _pStack$[ebp]
	mov	edx, DWORD PTR _pTargStack$[ebp]
	mov	DWORD PTR [ecx+20], edx

; 2122 : 	IrpStatus = SendIrpSync(pQueryIrp, &IrpComplEv);

	lea	eax, DWORD PTR _IrpComplEv$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pQueryIrp$[ebp]
	push	ecx
	call	?SendIrpSync@@YGJPAU_IRP@@PAU_KEVENT@@@Z ; SendIrpSync
	mov	DWORD PTR _IrpStatus$[ebp], eax

; 2123 : 	if (NT_SUCCESS(IrpStatus)) {

	cmp	DWORD PTR _IrpStatus$[ebp], 0
	jl	SHORT $LN3@GetTargDev

; 2124 : 		if (pQueryIrp->IoStatus.Information) {

	mov	edx, DWORD PTR _pQueryIrp$[ebp]
	cmp	DWORD PTR [edx+28], 0
	je	SHORT $LN3@GetTargDev

; 2125 : 			CopyMultiWString(
; 2126 : 				(PWCHAR) &pFaDevExt->TargDevInfo.CompatibleIDs, 
; 2127 : 				(PWCHAR) pQueryIrp->IoStatus.Information,
; 2128 : 				sizeof pFaDevExt->TargDevInfo.CompatibleIDs);

	push	202					; 000000caH
	mov	eax, DWORD PTR _pQueryIrp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _pFaDevExt$[ebp]
	add	edx, 116				; 00000074H
	push	edx
	call	?CopyMultiWString@@YGXPAG0K@Z		; CopyMultiWString

; 2129 : 			ExFreePool((PVOID) pQueryIrp->IoStatus.Information);

	push	0
	mov	eax, DWORD PTR _pQueryIrp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	call	DWORD PTR __imp__ExFreePoolWithTag@8
$LN3@GetTargDev:

; 2130 : 		}
; 2131 : 	}
; 2132 : 	if (NT_SUCCESS(status)) status = IrpStatus;

	cmp	DWORD PTR _status$[ebp], 0
	jl	SHORT $LN1@GetTargDev
	mov	edx, DWORD PTR _IrpStatus$[ebp]
	mov	DWORD PTR _status$[ebp], edx
$LN1@GetTargDev:

; 2133 : 
; 2134 : 	IoFreeIrp(pQueryIrp);

	mov	eax, DWORD PTR _pQueryIrp$[ebp]
	push	eax
	call	DWORD PTR __imp__IoFreeIrp@4

; 2135 : 
; 2136 : 	return status;

	mov	eax, DWORD PTR _status$[ebp]
$LN17@GetTargDev:

; 2137 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?GetTargDevInfo@@YGJPAU_FADEVICE_EXTENSION@@@Z ENDP	; GetTargDevInfo
_TEXT	ENDS
PUBLIC	??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0CJ@NOBCDHO@c?3?2apps?2pw7hp?2devpgm?2msddk?2inc?2d@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp__RtlAssert@16:PROC
;	COMDAT ??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@
; File c:\apps\pw7hp\devpgm\msddk\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@ DB 'Irp'
	DB	'->CurrentLocation > 0', 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CJ@NOBCDHO@c?3?2apps?2pw7hp?2devpgm?2msddk?2inc?2d@FNODOBFM@
text$s	SEGMENT
??_C@_0CJ@NOBCDHO@c?3?2apps?2pw7hp?2devpgm?2msddk?2inc?2d@FNODOBFM@ DB 'c'
	DB	':\apps\pw7hp\devpgm\msddk\inc\ddk\wdm.h', 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoGetNextIrpStackLocation@4
_TEXT	SEGMENT
tv71 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoGetNextIrpStackLocation@4 PROC			; COMDAT

; 23479: {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 23480:     ASSERT(Irp->CurrentLocation > 0);

	mov	eax, DWORD PTR _Irp$[ebp]
	movsx	ecx, BYTE PTR [eax+35]
	test	ecx, ecx
	jg	SHORT $LN3@IoGetNextI
	push	0
	push	23480					; 00005bb8H
	push	OFFSET ??_C@_0CJ@NOBCDHO@c?3?2apps?2pw7hp?2devpgm?2msddk?2inc?2d@FNODOBFM@
	push	OFFSET ??_C@_0BJ@HKMILGM@Irp?9?$DOCurrentLocation?5?$DO?50?$AA@FNODOBFM@
	call	DWORD PTR __imp__RtlAssert@16
	mov	DWORD PTR tv71[ebp], 0
	jmp	SHORT $LN4@IoGetNextI
$LN3@IoGetNextI:
	mov	DWORD PTR tv71[ebp], 1
$LN4@IoGetNextI:

; 23481: 
; 23482:     return ((Irp)->Tail.Overlay.CurrentStackLocation - 1 );

	mov	edx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR [edx+96]
	sub	eax, 36					; 00000024H

; 23483: }

	mov	esp, ebp
	pop	ebp
	ret	4
_IoGetNextIrpStackLocation@4 ENDP
; Function compile flags: /Odtp
; File b:\programm\wntsys\testfilter\release\1_1\source\driver\drvmain.cpp
_TEXT	ENDS
;	COMDAT ?CopyMultiWString@@YGXPAG0K@Z
_TEXT	SEGMENT
_pLast$ = -4						; size = 4
_pDest$ = 8						; size = 4
_pSrc$ = 12						; size = 4
_DestSize$ = 16						; size = 4
?CopyMultiWString@@YGXPAG0K@Z PROC			; CopyMultiWString, COMDAT

; 815  : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 816  : 	// pLast points to the next to last WCHAR in the dest buffer.
; 817  : 	//
; 818  : 	PWCHAR pLast = pDest + DestSize / sizeof (WCHAR) -2;

	mov	eax, DWORD PTR _DestSize$[ebp]
	shr	eax, 1
	mov	ecx, DWORD PTR _pDest$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2-4]
	mov	DWORD PTR _pLast$[ebp], edx
$LN8@CopyMultiW:

; 819  : 	do {
; 820  : 		for (; *pSrc != L'\0'; pSrc++, pDest++) {

	jmp	SHORT $LN5@CopyMultiW
$LN4@CopyMultiW:
	mov	eax, DWORD PTR _pSrc$[ebp]
	add	eax, 2
	mov	DWORD PTR _pSrc$[ebp], eax
	mov	ecx, DWORD PTR _pDest$[ebp]
	add	ecx, 2
	mov	DWORD PTR _pDest$[ebp], ecx
$LN5@CopyMultiW:
	mov	edx, DWORD PTR _pSrc$[ebp]
	movzx	eax, WORD PTR [edx]
	test	eax, eax
	je	SHORT $LN3@CopyMultiW

; 821  : 			if (pDest >= pLast) break;

	mov	ecx, DWORD PTR _pDest$[ebp]
	cmp	ecx, DWORD PTR _pLast$[ebp]
	jb	SHORT $LN2@CopyMultiW
	jmp	SHORT $LN3@CopyMultiW
$LN2@CopyMultiW:

; 822  : 			*pDest = *pSrc;

	mov	edx, DWORD PTR _pDest$[ebp]
	mov	eax, DWORD PTR _pSrc$[ebp]
	mov	cx, WORD PTR [eax]
	mov	WORD PTR [edx], cx

; 823  : 		}

	jmp	SHORT $LN4@CopyMultiW
$LN3@CopyMultiW:

; 824  : 		*pDest = L'\0';

	xor	edx, edx
	mov	eax, DWORD PTR _pDest$[ebp]
	mov	WORD PTR [eax], dx

; 825  : 		pDest++;

	mov	ecx, DWORD PTR _pDest$[ebp]
	add	ecx, 2
	mov	DWORD PTR _pDest$[ebp], ecx

; 826  : 		if (pDest >= pLast) break;

	mov	edx, DWORD PTR _pDest$[ebp]
	cmp	edx, DWORD PTR _pLast$[ebp]
	jb	SHORT $LN1@CopyMultiW
	jmp	SHORT $LN6@CopyMultiW
$LN1@CopyMultiW:

; 827  : 		pSrc++;

	mov	eax, DWORD PTR _pSrc$[ebp]
	add	eax, 2
	mov	DWORD PTR _pSrc$[ebp], eax

; 828  : 	} while (*pSrc != L'\0');

	mov	ecx, DWORD PTR _pSrc$[ebp]
	movzx	edx, WORD PTR [ecx]
	test	edx, edx
	jne	SHORT $LN8@CopyMultiW
$LN6@CopyMultiW:

; 829  : 	*(pDest) = L'\0';

	xor	eax, eax
	mov	ecx, DWORD PTR _pDest$[ebp]
	mov	WORD PTR [ecx], ax

; 830  : 	return;
; 831  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?CopyMultiWString@@YGXPAG0K@Z ENDP			; CopyMultiWString
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?MainDispatch@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z
_TEXT	SEGMENT
tv65 = -12						; size = 4
_pDevExt$ = -8						; size = 4
_pDevObj$ = 8						; size = 4
_pIrp$ = 12						; size = 4
?MainDispatch@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z PROC	; MainDispatch, COMDAT

; 2518 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2519 : 	PDEVICE_EXTENSION	pDevExt;
; 2520 : 	PIO_STACK_LOCATION	pStack;
; 2521 : 
; 2522 : 	pDevExt = (PDEVICE_EXTENSION) pDevObj->DeviceExtension;

	mov	eax, DWORD PTR _pDevObj$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _pDevExt$[ebp], ecx

; 2523 : 
; 2524 : 	switch (pDevExt->hdr.DevType) {

	mov	edx, DWORD PTR _pDevExt$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv65[ebp], eax
	cmp	DWORD PTR tv65[ebp], 0
	je	SHORT $LN2@MainDispat
	cmp	DWORD PTR tv65[ebp], 1
	je	SHORT $LN4@MainDispat
	cmp	DWORD PTR tv65[ebp], 2
	je	SHORT $LN3@MainDispat
	jmp	SHORT $LN1@MainDispat
$LN4@MainDispat:

; 2525 : 		case DT_FILTER:
; 2526 : 			return FltMainDispatch(pDevObj, pIrp);

	mov	ecx, DWORD PTR _pIrp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDevObj$[ebp]
	push	edx
	call	?FltMainDispatch@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ; FltMainDispatch
	jmp	SHORT $LN7@MainDispat

; 2527 : 			break;

	jmp	SHORT $LN7@MainDispat
$LN3@MainDispat:

; 2528 : 		case DT_FILTER_ACCESS:
; 2529 : 			return FAMainDispatch(pDevObj, pIrp);

	mov	eax, DWORD PTR _pIrp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDevObj$[ebp]
	push	ecx
	call	?FAMainDispatch@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ; FAMainDispatch
	jmp	SHORT $LN7@MainDispat

; 2530 : 			break;

	jmp	SHORT $LN7@MainDispat
$LN2@MainDispat:

; 2531 : 		 case DT_MASTER:
; 2532 : 			 return MAMainDispatch(pDevObj, pIrp);

	mov	edx, DWORD PTR _pIrp$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDevObj$[ebp]
	push	eax
	call	?MAMainDispatch@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ; MAMainDispatch
	jmp	SHORT $LN7@MainDispat

; 2533 : 			 break;

	jmp	SHORT $LN7@MainDispat
$LN1@MainDispat:

; 2534 : 		 default:
; 2535 : 			pIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;

	mov	ecx, DWORD PTR _pIrp$[ebp]
	mov	DWORD PTR [ecx+24], -1073741637		; c00000bbH

; 2536 : 			pIrp->IoStatus.Information = 0;

	mov	edx, DWORD PTR _pIrp$[ebp]
	mov	DWORD PTR [edx+28], 0

; 2537 : 			IoCompleteRequest(pIrp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _pIrp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 2538 : 			return STATUS_NOT_SUPPORTED;

	mov	eax, -1073741637			; c00000bbH
$LN7@MainDispat:

; 2539 : 	}
; 2540 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?MainDispatch@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ENDP	; MainDispatch
_TEXT	ENDS
PUBLIC	_IoGetCurrentIrpStackLocation@4
; Function compile flags: /Odtp
;	COMDAT ?FltMainDispatch@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z
_TEXT	SEGMENT
tv67 = -12						; size = 4
_pStack$ = -8						; size = 4
_MajorFunction$ = -1					; size = 1
_pDevObj$ = 8						; size = 4
_pIrp$ = 12						; size = 4
?FltMainDispatch@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z PROC ; FltMainDispatch, COMDAT

; 1379 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1380 : 	PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	eax, DWORD PTR _pIrp$[ebp]
	push	eax
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _pStack$[ebp], eax

; 1381 : 	UCHAR MajorFunction = pStack->MajorFunction;

	mov	ecx, DWORD PTR _pStack$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _MajorFunction$[ebp], dl

; 1382 : 	switch (MajorFunction) {

	mov	al, BYTE PTR _MajorFunction$[ebp]
	mov	BYTE PTR tv67[ebp], al
	cmp	BYTE PTR tv67[ebp], 3
	je	SHORT $LN3@FltMainDis
	cmp	BYTE PTR tv67[ebp], 4
	je	SHORT $LN2@FltMainDis
	jmp	SHORT $LN1@FltMainDis
$LN3@FltMainDis:

; 1383 : 		case IRP_MJ_READ:
; 1384 : 			return DispatchFilteredRead(pDevObj, pIrp);

	mov	ecx, DWORD PTR _pIrp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDevObj$[ebp]
	push	edx
	call	?DispatchFilteredRead@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ; DispatchFilteredRead
	jmp	SHORT $LN6@FltMainDis

; 1385 : 			break;

	jmp	SHORT $LN6@FltMainDis
$LN2@FltMainDis:

; 1386 : 		case IRP_MJ_WRITE:
; 1387 : 			return DispatchFilteredWrite(pDevObj, pIrp);

	mov	eax, DWORD PTR _pIrp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDevObj$[ebp]
	push	ecx
	call	?DispatchFilteredWrite@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ; DispatchFilteredWrite
	jmp	SHORT $LN6@FltMainDis

; 1388 : 			break;

	jmp	SHORT $LN6@FltMainDis
$LN1@FltMainDis:

; 1389 : 		default:
; 1390 : 
; 1391 : 			// Common tracing and forwarding.
; 1392 : 			//
; 1393 : 			return GenericTrace(pDevObj, pIrp);

	mov	edx, DWORD PTR _pIrp$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDevObj$[ebp]
	push	eax
	call	?GenericTrace@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ; GenericTrace
$LN6@FltMainDis:

; 1394 : 	}
; 1395 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?FltMainDispatch@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ENDP ; FltMainDispatch
_TEXT	ENDS
PUBLIC	??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
; File c:\apps\pw7hp\devpgm\msddk\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ DB 'I'
	DB	'rp->CurrentLocation <= Irp->StackCount + 1', 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoGetCurrentIrpStackLocation@4
_TEXT	SEGMENT
tv74 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoGetCurrentIrpStackLocation@4 PROC			; COMDAT

; 23316: {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 23317:     ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);

	mov	eax, DWORD PTR _Irp$[ebp]
	movsx	ecx, BYTE PTR [eax+35]
	mov	edx, DWORD PTR _Irp$[ebp]
	movsx	eax, BYTE PTR [edx+34]
	add	eax, 1
	cmp	ecx, eax
	jle	SHORT $LN3@IoGetCurre
	push	0
	push	23317					; 00005b15H
	push	OFFSET ??_C@_0CJ@NOBCDHO@c?3?2apps?2pw7hp?2devpgm?2msddk?2inc?2d@FNODOBFM@
	push	OFFSET ??_C@_0CM@LOONDNKF@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
	call	DWORD PTR __imp__RtlAssert@16
	mov	DWORD PTR tv74[ebp], 0
	jmp	SHORT $LN4@IoGetCurre
$LN3@IoGetCurre:
	mov	DWORD PTR tv74[ebp], 1
$LN4@IoGetCurre:

; 23318:     return Irp->Tail.Overlay.CurrentStackLocation;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	eax, DWORD PTR [ecx+96]

; 23319: }

	mov	esp, ebp
	pop	ebp
	ret	4
_IoGetCurrentIrpStackLocation@4 ENDP
_TEXT	ENDS
PUBLIC	_IoSetCompletionRoutine@24
PUBLIC	_IoCopyCurrentIrpStackLocationToNext@4
PUBLIC	??_C@_0CA@HIAJLNEM@?7offset?5?$DN?5?$CF?$CDI64x?6?7length?5?$DN?5?$CF?$CDx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BF@DHECNBIC@DispatchFilteredRead?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp_@IofCallDriver@8:PROC
;	COMDAT ??_C@_0CA@HIAJLNEM@?7offset?5?$DN?5?$CF?$CDI64x?6?7length?5?$DN?5?$CF?$CDx?6?$AA@FNODOBFM@
; File b:\programm\wntsys\testfilter\release\1_1\source\driver\drvmain.cpp
text$s	SEGMENT
??_C@_0CA@HIAJLNEM@?7offset?5?$DN?5?$CF?$CDI64x?6?7length?5?$DN?5?$CF?$CDx?6?$AA@FNODOBFM@ DB 09H
	DB	'offset = %#I64x', 0aH, 09H, 'length = %#x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BF@DHECNBIC@DispatchFilteredRead?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BF@DHECNBIC@DispatchFilteredRead?$AA@FNODOBFM@ DB 'DispatchFiltere'
	DB	'dRead', 00H					;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?DispatchFilteredRead@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z
_TEXT	SEGMENT
_pIrpStack$26395 = -8					; size = 4
_pDevExt$ = -4						; size = 4
_pDevObj$ = 8						; size = 4
_pIrp$ = 12						; size = 4
?DispatchFilteredRead@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z PROC ; DispatchFilteredRead, COMDAT

; 1218 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1219 : 	PDEVICE_EXTENSION pDevExt = (PDEVICE_EXTENSION) pDevObj->DeviceExtension;

	mov	eax, DWORD PTR _pDevObj$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _pDevExt$[ebp], ecx

; 1220 : 	if (pDevExt->dwMJFlags[IRP_MJ_READ] & FCTL_TRACE_ON) {

	mov	edx, DWORD PTR _pDevExt$[ebp]
	mov	eax, DWORD PTR [edx+88]
	and	eax, 1
	je	SHORT $LN1@DispatchFi

; 1221 : 		PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	ecx, DWORD PTR _pIrp$[ebp]
	push	ecx
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _pIrpStack$26395[ebp], eax

; 1222 : 		TraceIrpBasicInfo(pDevExt, "DispatchFilteredRead", pIrp);

	mov	edx, DWORD PTR _pIrp$[ebp]
	push	edx
	push	OFFSET ??_C@_0BF@DHECNBIC@DispatchFilteredRead?$AA@FNODOBFM@
	mov	eax, DWORD PTR _pDevExt$[ebp]
	push	eax
	call	?TraceIrpBasicInfo@@YGXPAU_DEVICE_EXTENSION@@PADPAU_IRP@@@Z ; TraceIrpBasicInfo

; 1223 : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1224 : 			"\toffset = %#I64x\n"
; 1225 : 			"\tlength = %#x\n",
; 1226 : 			pIrpStack->Parameters.Read.ByteOffset.QuadPart,
; 1227 : 			pIrpStack->Parameters.Read.Length
; 1228 : 		);

	mov	ecx, DWORD PTR _pIrpStack$26395[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	mov	eax, DWORD PTR _pIrpStack$26395[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR [eax+12]
	push	edx
	push	OFFSET ??_C@_0CA@HIAJLNEM@?7offset?5?$DN?5?$CF?$CDI64x?6?7length?5?$DN?5?$CF?$CDx?6?$AA@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 24					; 00000018H
$LN1@DispatchFi:

; 1229 : 	}
; 1230 : 
; 1231 : 	IoCopyCurrentIrpStackLocationToNext(pIrp);

	mov	eax, DWORD PTR _pIrp$[ebp]
	push	eax
	call	_IoCopyCurrentIrpStackLocationToNext@4

; 1232 : 
; 1233 : 	// Set the completion routine which will intercept the read data.
; 1234 : 	//
; 1235 : 	IoSetCompletionRoutine(pIrp, ReadCompletion, NULL, TRUE, TRUE, TRUE);

	push	1
	push	1
	push	1
	push	0
	push	OFFSET ?ReadCompletion@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@PAX@Z ; ReadCompletion
	mov	ecx, DWORD PTR _pIrp$[ebp]
	push	ecx
	call	_IoSetCompletionRoutine@24

; 1236 : 	return IoCallDriver(
; 1237 : 		pDevExt->pTargStack,
; 1238 : 		pIrp );

	mov	edx, DWORD PTR _pIrp$[ebp]
	mov	eax, DWORD PTR _pDevExt$[ebp]
	mov	ecx, DWORD PTR [eax+204]
	call	DWORD PTR __imp_@IofCallDriver@8

; 1239 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?DispatchFilteredRead@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ENDP ; DispatchFilteredRead
_TEXT	ENDS
PUBLIC	??_C@_0FK@JAEDPCKJ@?$CIInvokeOnSuccess?5?$HM?$HM?5InvokeOnErro@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0FK@JAEDPCKJ@?$CIInvokeOnSuccess?5?$HM?$HM?5InvokeOnErro@FNODOBFM@
; File c:\apps\pw7hp\devpgm\msddk\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_0FK@JAEDPCKJ@?$CIInvokeOnSuccess?5?$HM?$HM?5InvokeOnErro@FNODOBFM@ DB '('
	DB	'InvokeOnSuccess || InvokeOnError || InvokeOnCancel) ? (Comple'
	DB	'tionRoutine != NULL) : TRUE', 00H		;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoSetCompletionRoutine@24
_TEXT	SEGMENT
tv78 = -12						; size = 4
tv72 = -8						; size = 4
_irpSp$ = -4						; size = 4
_Irp$ = 8						; size = 4
_CompletionRoutine$ = 12				; size = 4
_Context$ = 16						; size = 4
_InvokeOnSuccess$ = 20					; size = 1
_InvokeOnError$ = 24					; size = 1
_InvokeOnCancel$ = 28					; size = 1
_IoSetCompletionRoutine@24 PROC				; COMDAT

; 23820: {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 23821:     PIO_STACK_LOCATION irpSp;
; 23822:     ASSERT( (InvokeOnSuccess || InvokeOnError || InvokeOnCancel) ? (CompletionRoutine != NULL) : TRUE );

	movzx	eax, BYTE PTR _InvokeOnSuccess$[ebp]
	test	eax, eax
	jne	SHORT $LN6@IoSetCompl
	movzx	ecx, BYTE PTR _InvokeOnError$[ebp]
	test	ecx, ecx
	jne	SHORT $LN6@IoSetCompl
	movzx	edx, BYTE PTR _InvokeOnCancel$[ebp]
	test	edx, edx
	jne	SHORT $LN6@IoSetCompl
	mov	DWORD PTR tv72[ebp], 1
	jmp	SHORT $LN7@IoSetCompl
$LN6@IoSetCompl:
	xor	eax, eax
	cmp	DWORD PTR _CompletionRoutine$[ebp], 0
	setne	al
	mov	DWORD PTR tv72[ebp], eax
$LN7@IoSetCompl:
	cmp	DWORD PTR tv72[ebp], 0
	jne	SHORT $LN8@IoSetCompl
	push	0
	push	23822					; 00005d0eH
	push	OFFSET ??_C@_0CJ@NOBCDHO@c?3?2apps?2pw7hp?2devpgm?2msddk?2inc?2d@FNODOBFM@
	push	OFFSET ??_C@_0FK@JAEDPCKJ@?$CIInvokeOnSuccess?5?$HM?$HM?5InvokeOnErro@FNODOBFM@
	call	DWORD PTR __imp__RtlAssert@16
	mov	DWORD PTR tv78[ebp], 0
	jmp	SHORT $LN9@IoSetCompl
$LN8@IoSetCompl:
	mov	DWORD PTR tv78[ebp], 1
$LN9@IoSetCompl:

; 23823:     irpSp = IoGetNextIrpStackLocation(Irp);

	mov	ecx, DWORD PTR _Irp$[ebp]
	push	ecx
	call	_IoGetNextIrpStackLocation@4
	mov	DWORD PTR _irpSp$[ebp], eax

; 23824:     irpSp->CompletionRoutine = CompletionRoutine;

	mov	edx, DWORD PTR _irpSp$[ebp]
	mov	eax, DWORD PTR _CompletionRoutine$[ebp]
	mov	DWORD PTR [edx+28], eax

; 23825:     irpSp->Context = Context;

	mov	ecx, DWORD PTR _irpSp$[ebp]
	mov	edx, DWORD PTR _Context$[ebp]
	mov	DWORD PTR [ecx+32], edx

; 23826:     irpSp->Control = 0;

	mov	eax, DWORD PTR _irpSp$[ebp]
	mov	BYTE PTR [eax+3], 0

; 23827: 
; 23828:     if (InvokeOnSuccess) {

	movzx	ecx, BYTE PTR _InvokeOnSuccess$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@IoSetCompl

; 23829:         irpSp->Control = SL_INVOKE_ON_SUCCESS;

	mov	edx, DWORD PTR _irpSp$[ebp]
	mov	BYTE PTR [edx+3], 64			; 00000040H
$LN3@IoSetCompl:

; 23830:     }
; 23831: 
; 23832:     if (InvokeOnError) {

	movzx	eax, BYTE PTR _InvokeOnError$[ebp]
	test	eax, eax
	je	SHORT $LN2@IoSetCompl

; 23833:         irpSp->Control |= SL_INVOKE_ON_ERROR;

	mov	ecx, DWORD PTR _irpSp$[ebp]
	movzx	edx, BYTE PTR [ecx+3]
	or	edx, 128				; 00000080H
	mov	eax, DWORD PTR _irpSp$[ebp]
	mov	BYTE PTR [eax+3], dl
$LN2@IoSetCompl:

; 23834:     }
; 23835: 
; 23836:     if (InvokeOnCancel) {

	movzx	ecx, BYTE PTR _InvokeOnCancel$[ebp]
	test	ecx, ecx
	je	SHORT $LN4@IoSetCompl

; 23837:         irpSp->Control |= SL_INVOKE_ON_CANCEL;

	mov	edx, DWORD PTR _irpSp$[ebp]
	movzx	eax, BYTE PTR [edx+3]
	or	eax, 32					; 00000020H
	mov	ecx, DWORD PTR _irpSp$[ebp]
	mov	BYTE PTR [ecx+3], al
$LN4@IoSetCompl:

; 23838:     }
; 23839: }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_IoSetCompletionRoutine@24 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _IoCopyCurrentIrpStackLocationToNext@4
_TEXT	SEGMENT
_irpSp$ = -8						; size = 4
_nextIrpSp$ = -4					; size = 4
_Irp$ = 8						; size = 4
_IoCopyCurrentIrpStackLocationToNext@4 PROC		; COMDAT

; 23912: {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	push	edi

; 23913:     PIO_STACK_LOCATION irpSp;
; 23914:     PIO_STACK_LOCATION nextIrpSp;
; 23915:     irpSp = IoGetCurrentIrpStackLocation(Irp);

	mov	eax, DWORD PTR _Irp$[ebp]
	push	eax
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _irpSp$[ebp], eax

; 23916:     nextIrpSp = IoGetNextIrpStackLocation(Irp);

	mov	ecx, DWORD PTR _Irp$[ebp]
	push	ecx
	call	_IoGetNextIrpStackLocation@4
	mov	DWORD PTR _nextIrpSp$[ebp], eax

; 23917:     RtlCopyMemory( nextIrpSp, irpSp, FIELD_OFFSET(IO_STACK_LOCATION, CompletionRoutine));

	mov	ecx, 7
	mov	esi, DWORD PTR _irpSp$[ebp]
	mov	edi, DWORD PTR _nextIrpSp$[ebp]
	rep movsd

; 23918:     nextIrpSp->Control = 0;

	mov	edx, DWORD PTR _nextIrpSp$[ebp]
	mov	BYTE PTR [edx+3], 0

; 23919: }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_IoCopyCurrentIrpStackLocationToNext@4 ENDP
_TEXT	ENDS
PUBLIC	_IoSkipCurrentIrpStackLocation@4
PUBLIC	??_C@_0BE@LDBPDEFD@?7data?5length?5?$DN?5?$CF?$CDx?6?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0BG@EAJEGOIB@DispatchFilteredWrite?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0BE@LDBPDEFD@?7data?5length?5?$DN?5?$CF?$CDx?6?$AA@FNODOBFM@
; File b:\programm\wntsys\testfilter\release\1_1\source\driver\drvmain.cpp
text$s	SEGMENT
??_C@_0BE@LDBPDEFD@?7data?5length?5?$DN?5?$CF?$CDx?6?$AA@FNODOBFM@ DB 09H
	DB	'data length = %#x', 0aH, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0BG@EAJEGOIB@DispatchFilteredWrite?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0BG@EAJEGOIB@DispatchFilteredWrite?$AA@FNODOBFM@ DB 'DispatchFilter'
	DB	'edWrite', 00H				;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?DispatchFilteredWrite@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z
_TEXT	SEGMENT
_pWriteData$26408 = -28					; size = 4
_LockHandle$26410 = -24					; size = 12
_pStack$26405 = -12					; size = 4
_cbDataLen$26409 = -8					; size = 4
_pDevExt$ = -4						; size = 4
_pDevObj$ = 8						; size = 4
_pIrp$ = 12						; size = 4
?DispatchFilteredWrite@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z PROC ; DispatchFilteredWrite, COMDAT

; 1267 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1268 : 	PDEVICE_EXTENSION pDevExt = 
; 1269 : 		(PDEVICE_EXTENSION) pDevObj->DeviceExtension;

	mov	eax, DWORD PTR _pDevObj$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _pDevExt$[ebp], ecx

; 1270 : 	if (pDevExt->dwMJFlags[IRP_MJ_WRITE] & FCTL_TRACE_ON) {

	mov	edx, DWORD PTR _pDevExt$[ebp]
	mov	eax, DWORD PTR [edx+92]
	and	eax, 1
	je	$LN1@DispatchFi@2

; 1271 : 		PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	ecx, DWORD PTR _pIrp$[ebp]
	push	ecx
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _pStack$26405[ebp], eax

; 1272 : 		TraceIrpBasicInfo(pDevExt, "DispatchFilteredWrite", pIrp);

	mov	edx, DWORD PTR _pIrp$[ebp]
	push	edx
	push	OFFSET ??_C@_0BG@EAJEGOIB@DispatchFilteredWrite?$AA@FNODOBFM@
	mov	eax, DWORD PTR _pDevExt$[ebp]
	push	eax
	call	?TraceIrpBasicInfo@@YGXPAU_DEVICE_EXTENSION@@PADPAU_IRP@@@Z ; TraceIrpBasicInfo

; 1273 : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1274 : 			"\tdata length = %#x\n", 
; 1275 : 			pStack->Parameters.Write.Length);

	mov	ecx, DWORD PTR _pStack$26405[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	OFFSET ??_C@_0BE@LDBPDEFD@?7data?5length?5?$DN?5?$CF?$CDx?6?$AA@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 16					; 00000010H

; 1276 : 
; 1277 : 		// Get the IRP data, if any.
; 1278 : 		//
; 1279 : 		PVOID pWriteData;
; 1280 : 		SIZE_T cbDataLen;
; 1281 : 		GetWriteData(pIrp, pDevExt, &pWriteData, &cbDataLen);

	lea	eax, DWORD PTR _cbDataLen$26409[ebp]
	push	eax
	lea	ecx, DWORD PTR _pWriteData$26408[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDevExt$[ebp]
	push	edx
	mov	eax, DWORD PTR _pIrp$[ebp]
	push	eax
	call	?GetWriteData@@YGXPAU_IRP@@PAU_DEVICE_EXTENSION@@PAPAXPAK@Z ; GetWriteData

; 1282 : 		KLOCK_QUEUE_HANDLE LockHandle;
; 1283 : 		KeAcquireInStackQueuedSpinLock(
; 1284 : 			&pDevExt->DataLock,
; 1285 : 			&LockHandle);

	mov	ecx, DWORD PTR _pDevExt$[ebp]
	add	ecx, 68					; 00000044H
	lea	edx, DWORD PTR _LockHandle$26410[ebp]
	call	DWORD PTR __imp_@KeAcquireInStackQueuedSpinLock@8

; 1286 : 		InterceptIrpAndData(pIrp, pWriteData, cbDataLen, pDevExt);

	mov	ecx, DWORD PTR _pDevExt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _cbDataLen$26409[ebp]
	push	edx
	mov	eax, DWORD PTR _pWriteData$26408[ebp]
	push	eax
	mov	ecx, DWORD PTR _pIrp$[ebp]
	push	ecx
	call	?InterceptIrpAndData@@YGXPAU_IRP@@PAXKPAU_DEVICE_EXTENSION@@@Z ; InterceptIrpAndData

; 1287 : 		SendIrpDataToClt(pDevExt);

	mov	edx, DWORD PTR _pDevExt$[ebp]
	push	edx
	call	?SendIrpDataToClt@@YGXPAU_DEVICE_EXTENSION@@@Z ; SendIrpDataToClt

; 1288 : 		KeReleaseInStackQueuedSpinLock(&LockHandle);

	lea	ecx, DWORD PTR _LockHandle$26410[ebp]
	call	DWORD PTR __imp_@KeReleaseInStackQueuedSpinLock@4
$LN1@DispatchFi@2:

; 1289 : 
; 1290 : 	}
; 1291 : 	IoSkipCurrentIrpStackLocation(pIrp);

	mov	eax, DWORD PTR _pIrp$[ebp]
	push	eax
	call	_IoSkipCurrentIrpStackLocation@4

; 1292 : 	return IoCallDriver(pDevExt->pTargStack, pIrp);

	mov	edx, DWORD PTR _pIrp$[ebp]
	mov	ecx, DWORD PTR _pDevExt$[ebp]
	mov	ecx, DWORD PTR [ecx+204]
	call	DWORD PTR __imp_@IofCallDriver@8

; 1293 : 
; 1294 : 
; 1295 : 
; 1296 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?DispatchFilteredWrite@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ENDP ; DispatchFilteredWrite
_TEXT	ENDS
PUBLIC	??_C@_0CI@HDMHMCGD@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0CI@HDMHMCGD@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
; File c:\apps\pw7hp\devpgm\msddk\inc\ddk\wdm.h
text$s	SEGMENT
??_C@_0CI@HDMHMCGD@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@ DB 'I'
	DB	'rp->CurrentLocation <= Irp->StackCount', 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT _IoSkipCurrentIrpStackLocation@4
_TEXT	SEGMENT
tv73 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoSkipCurrentIrpStackLocation@4 PROC			; COMDAT

; 23945: {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 23946:     ASSERT(Irp->CurrentLocation <= Irp->StackCount);

	mov	eax, DWORD PTR _Irp$[ebp]
	movsx	ecx, BYTE PTR [eax+35]
	mov	edx, DWORD PTR _Irp$[ebp]
	movsx	eax, BYTE PTR [edx+34]
	cmp	ecx, eax
	jle	SHORT $LN3@IoSkipCurr
	push	0
	push	23946					; 00005d8aH
	push	OFFSET ??_C@_0CJ@NOBCDHO@c?3?2apps?2pw7hp?2devpgm?2msddk?2inc?2d@FNODOBFM@
	push	OFFSET ??_C@_0CI@HDMHMCGD@Irp?9?$DOCurrentLocation?5?$DM?$DN?5Irp?9?$DOSta@FNODOBFM@
	call	DWORD PTR __imp__RtlAssert@16
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN4@IoSkipCurr
$LN3@IoSkipCurr:
	mov	DWORD PTR tv73[ebp], 1
$LN4@IoSkipCurr:

; 23947:     Irp->CurrentLocation++;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	dl, BYTE PTR [ecx+35]
	add	dl, 1
	mov	eax, DWORD PTR _Irp$[ebp]
	mov	BYTE PTR [eax+35], dl

; 23948:     Irp->Tail.Overlay.CurrentStackLocation++;

	mov	ecx, DWORD PTR _Irp$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	add	edx, 36					; 00000024H
	mov	eax, DWORD PTR _Irp$[ebp]
	mov	DWORD PTR [eax+96], edx

; 23949: }

	mov	esp, ebp
	pop	ebp
	ret	4
_IoSkipCurrentIrpStackLocation@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EE@ODKHGKNO@FLT?5?9?5FAMainDispatch?5?9?5Client?5IR@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0EE@ODKHGKNO@FLT?5?9?5FAMainDispatch?5?9?5Client?5IR@FNODOBFM@
; File b:\programm\wntsys\testfilter\release\1_1\source\driver\drvmain.cpp
text$s	SEGMENT
??_C@_0EE@ODKHGKNO@FLT?5?9?5FAMainDispatch?5?9?5Client?5IR@FNODOBFM@ DB 'F'
	DB	'LT - FAMainDispatch - Client IRP %#p completed with status %#'
	DB	'010x', 0aH, 00H				;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?FAMainDispatch@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z
_TEXT	SEGMENT
tv67 = -12						; size = 4
_status$ = -8						; size = 4
_pStack$ = -4						; size = 4
_pDevObj$ = 8						; size = 4
_pIrp$ = 12						; size = 4
?FAMainDispatch@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z PROC	; FAMainDispatch, COMDAT

; 1558 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1559 : 	NTSTATUS status;
; 1560 : 	PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	eax, DWORD PTR _pIrp$[ebp]
	push	eax
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _pStack$[ebp], eax

; 1561 : 	switch (pStack->MajorFunction) {

	mov	ecx, DWORD PTR _pStack$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv67[ebp], edx
	cmp	DWORD PTR tv67[ebp], 18			; 00000012H
	ja	$LN2@FAMainDisp
	mov	eax, DWORD PTR tv67[ebp]
	movzx	ecx, BYTE PTR $LN12@FAMainDisp[eax]
	jmp	DWORD PTR $LN13@FAMainDisp[ecx*4]
$LN7@FAMainDisp:

; 1562 : 		case IRP_MJ_CLEANUP:
; 1563 : 			status = STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 1564 : 			pIrp->IoStatus.Information = 0;

	mov	edx, DWORD PTR _pIrp$[ebp]
	mov	DWORD PTR [edx+28], 0

; 1565 : 			pIrp->IoStatus.Status = status;

	mov	eax, DWORD PTR _pIrp$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 1566 : 			break;

	jmp	SHORT $LN8@FAMainDisp
$LN6@FAMainDisp:

; 1567 : 		case IRP_MJ_CLOSE:
; 1568 : 			status = STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 1569 : 			pIrp->IoStatus.Information = 0;

	mov	edx, DWORD PTR _pIrp$[ebp]
	mov	DWORD PTR [edx+28], 0

; 1570 : 			pIrp->IoStatus.Status = status;

	mov	eax, DWORD PTR _pIrp$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 1571 : 			break;

	jmp	SHORT $LN8@FAMainDisp
$LN5@FAMainDisp:

; 1572 : 		case IRP_MJ_CREATE:
; 1573 : 			status = STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 1574 : 			pIrp->IoStatus.Information = 0;

	mov	edx, DWORD PTR _pIrp$[ebp]
	mov	DWORD PTR [edx+28], 0

; 1575 : 			pIrp->IoStatus.Status = status;

	mov	eax, DWORD PTR _pIrp$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 1576 : 			break;

	jmp	SHORT $LN8@FAMainDisp
$LN4@FAMainDisp:

; 1577 : 		case IRP_MJ_DEVICE_CONTROL:
; 1578 : 			status = FADispatchIoctl(pDevObj, pIrp);

	mov	edx, DWORD PTR _pIrp$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDevObj$[ebp]
	push	eax
	call	?FADispatchIoctl@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ; FADispatchIoctl
	mov	DWORD PTR _status$[ebp], eax

; 1579 : 			break;

	jmp	SHORT $LN8@FAMainDisp
$LN3@FAMainDisp:

; 1580 : 		case IRP_MJ_READ:
; 1581 : 			status = FADispatchRead(pDevObj, pIrp);

	mov	ecx, DWORD PTR _pIrp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDevObj$[ebp]
	push	edx
	call	?FADispatchRead@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ; FADispatchRead
	mov	DWORD PTR _status$[ebp], eax

; 1582 : 			break;

	jmp	SHORT $LN8@FAMainDisp
$LN2@FAMainDisp:

; 1583 : 		default:
; 1584 : 			status = STATUS_NOT_SUPPORTED;

	mov	DWORD PTR _status$[ebp], -1073741637	; c00000bbH

; 1585 : 			pIrp->IoStatus.Information = 0;

	mov	eax, DWORD PTR _pIrp$[ebp]
	mov	DWORD PTR [eax+28], 0

; 1586 : 			pIrp->IoStatus.Status = status;

	mov	ecx, DWORD PTR _pIrp$[ebp]
	mov	edx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [ecx+24], edx
$LN8@FAMainDisp:

; 1587 : 	}
; 1588 : 	if (status != STATUS_PENDING) {

	cmp	DWORD PTR _status$[ebp], 259		; 00000103H
	je	SHORT $LN1@FAMainDisp

; 1589 : 
; 1590 : 		// This should not be necessary. Code paths which set a cancel
; 1591 : 		// routine either return STATUS_PENDING or remove the cancel 
; 1592 : 		// routine by themselves. We do it in case we forgot something.
; 1593 : 		//
; 1594 : 		IoSetCancelRoutine(pIrp, NULL);

	xor	eax, eax
	mov	ecx, DWORD PTR _pIrp$[ebp]
	add	ecx, 56					; 00000038H
	xchg	DWORD PTR [ecx], eax

; 1595 : 		IoCompleteRequest(
; 1596 : 			pIrp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _pIrp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 1597 : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1598 : 			"FLT - FAMainDispatch - Client IRP %#p completed with "
; 1599 : 			"status %#010x\n", 
; 1600 : 			pIrp,
; 1601 : 			pIrp->IoStatus.Status);

	mov	edx, DWORD PTR _pIrp$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	mov	ecx, DWORD PTR _pIrp$[ebp]
	push	ecx
	push	OFFSET ??_C@_0EE@ODKHGKNO@FLT?5?9?5FAMainDispatch?5?9?5Client?5IR@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 20					; 00000014H
$LN1@FAMainDisp:

; 1602 : 	}
; 1603 : 	return status;

	mov	eax, DWORD PTR _status$[ebp]

; 1604 : }

	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN13@FAMainDisp:
	DD	$LN5@FAMainDisp
	DD	$LN6@FAMainDisp
	DD	$LN3@FAMainDisp
	DD	$LN4@FAMainDisp
	DD	$LN7@FAMainDisp
	DD	$LN2@FAMainDisp
$LN12@FAMainDisp:
	DB	0
	DB	5
	DB	1
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	5
	DB	5
	DB	5
	DB	4
?FAMainDispatch@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ENDP	; FAMainDispatch
_TEXT	ENDS
PUBLIC	??_C@_0DN@OOMCMHGN@FLT?5?9?5FADispatchRead?5?9?5Client?5IR@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0DN@OOMCMHGN@FLT?5?9?5FADispatchRead?5?9?5Client?5IR@FNODOBFM@
text$s	SEGMENT
??_C@_0DN@OOMCMHGN@FLT?5?9?5FADispatchRead?5?9?5Client?5IR@FNODOBFM@ DB 'F'
	DB	'LT - FADispatchRead - Client IRP %#p queued for processing', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?FADispatchRead@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z
_TEXT	SEGMENT
_pFaExt$ = -24						; size = 4
_status$ = -20						; size = 4
_LockHandle$ = -16					; size = 12
_pFltExt$ = -4						; size = 4
_pDevObj$ = 8						; size = 4
_pIrp$ = 12						; size = 4
?FADispatchRead@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z PROC	; FADispatchRead, COMDAT

; 1157 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1158 : 	NTSTATUS status;
; 1159 : 	status = CheckFAReadParams(pIrp);

	mov	eax, DWORD PTR _pIrp$[ebp]
	push	eax
	call	?CheckFAReadParams@@YGJPAU_IRP@@@Z	; CheckFAReadParams
	mov	DWORD PTR _status$[ebp], eax

; 1160 : 
; 1161 : 	if (!NT_SUCCESS(status)) return status;

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN2@FADispatch
	mov	eax, DWORD PTR _status$[ebp]
	jmp	SHORT $LN3@FADispatch
$LN2@FADispatch:

; 1162 : 
; 1163 : 	PFADEVICE_EXTENSION pFaExt = 
; 1164 : 		(PFADEVICE_EXTENSION) pDevObj->DeviceExtension;

	mov	ecx, DWORD PTR _pDevObj$[ebp]
	mov	edx, DWORD PTR [ecx+40]
	mov	DWORD PTR _pFaExt$[ebp], edx

; 1165 : 
; 1166 : 	// Get the extension of the filter device
; 1167 : 	//
; 1168 : 	PDEVICE_EXTENSION pFltExt = pFaExt->pFilterDevExt;

	mov	eax, DWORD PTR _pFaExt$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR _pFltExt$[ebp], ecx

; 1169 : 	KLOCK_QUEUE_HANDLE	LockHandle;
; 1170 : 	KeAcquireInStackQueuedSpinLock(
; 1171 : 		&pFltExt->DataLock,
; 1172 : 		&LockHandle);

	mov	ecx, DWORD PTR _pFltExt$[ebp]
	add	ecx, 68					; 00000044H
	lea	edx, DWORD PTR _LockHandle$[ebp]
	call	DWORD PTR __imp_@KeAcquireInStackQueuedSpinLock@8

; 1173 : 
; 1174 : 	// Queue the client IRP.
; 1175 : 	//
; 1176 : 	status = QueueCltIrp(pFltExt, pIrp);

	mov	edx, DWORD PTR _pIrp$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFltExt$[ebp]
	push	eax
	call	?QueueCltIrp@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z ; QueueCltIrp
	mov	DWORD PTR _status$[ebp], eax

; 1177 : 	if (!NT_SUCCESS(status)) {

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN1@FADispatch

; 1178 : 		KeReleaseInStackQueuedSpinLock(&LockHandle);

	lea	ecx, DWORD PTR _LockHandle$[ebp]
	call	DWORD PTR __imp_@KeReleaseInStackQueuedSpinLock@4

; 1179 : 		return status;

	mov	eax, DWORD PTR _status$[ebp]
	jmp	SHORT $LN3@FADispatch
$LN1@FADispatch:

; 1180 : 	}
; 1181 : 
; 1182 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1183 : 		"FLT - FADispatchRead - Client IRP %#p queued for "
; 1184 : 		"processing\n", pIrp);

	mov	ecx, DWORD PTR _pIrp$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DN@OOMCMHGN@FLT?5?9?5FADispatchRead?5?9?5Client?5IR@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 16					; 00000010H

; 1185 : 
; 1186 : 
; 1187 : 	// Schedule the processing of the queued IRP (if there are data)
; 1188 : 	//
; 1189 : 	SendIrpDataToClt(pFltExt);

	mov	edx, DWORD PTR _pFltExt$[ebp]
	push	edx
	call	?SendIrpDataToClt@@YGXPAU_DEVICE_EXTENSION@@@Z ; SendIrpDataToClt

; 1190 : 
; 1191 : 	KeReleaseInStackQueuedSpinLock(&LockHandle);

	lea	ecx, DWORD PTR _LockHandle$[ebp]
	call	DWORD PTR __imp_@KeReleaseInStackQueuedSpinLock@4

; 1192 : 
; 1193 : 	return status;

	mov	eax, DWORD PTR _status$[ebp]
$LN3@FADispatch:

; 1194 : 
; 1195 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?FADispatchRead@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ENDP	; FADispatchRead
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?CheckFAReadParams@@YGJPAU_IRP@@@Z
_TEXT	SEGMENT
_pIoStack$ = -12					; size = 4
_status$ = -8						; size = 4
_bufSize$ = -4						; size = 4
_pIrp$ = 8						; size = 4
?CheckFAReadParams@@YGJPAU_IRP@@@Z PROC			; CheckFAReadParams, COMDAT

; 709  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 710  : 	NTSTATUS status = STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 711  : 	PIO_STACK_LOCATION pIoStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	eax, DWORD PTR _pIrp$[ebp]
	push	eax
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _pIoStack$[ebp], eax

; 712  : 	SIZE_T bufSize = pIoStack->Parameters.Read.Length;

	mov	ecx, DWORD PTR _pIoStack$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _bufSize$[ebp], edx

; 713  : 
; 714  : 	// The buffer for a client read IRP must at least have room for
; 715  : 	// an intercepted IRP + I/O stack with their header.
; 716  : 	// It may also have room for any eventual IRP data, but this is
; 717  : 	// not manadatory.
; 718  : 	//
; 719  : 	if (bufSize < sizeof (IRP_HEADER) + sizeof(IRP) +
; 720  : 		sizeof(IO_STACK_LOCATION)) {

	cmp	DWORD PTR _bufSize$[ebp], 156		; 0000009cH
	jae	SHORT $LN1@CheckFARea

; 721  : 		status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR _status$[ebp], -1073741811	; c000000dH

; 722  : 		pIrp->IoStatus.Status = status;

	mov	eax, DWORD PTR _pIrp$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 723  : 		pIrp->IoStatus.Information = 0;

	mov	edx, DWORD PTR _pIrp$[ebp]
	mov	DWORD PTR [edx+28], 0
$LN1@CheckFARea:

; 724  : 	}
; 725  : 	return status;

	mov	eax, DWORD PTR _status$[ebp]

; 726  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?CheckFAReadParams@@YGJPAU_IRP@@@Z ENDP			; CheckFAReadParams
_TEXT	ENDS
PUBLIC	??_C@_0CM@CDEFGHPM@FLT?5?9?5FADispatchDioc?5?9?5IOCTL?5cod@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0CM@CDEFGHPM@FLT?5?9?5FADispatchDioc?5?9?5IOCTL?5cod@FNODOBFM@
text$s	SEGMENT
??_C@_0CM@CDEFGHPM@FLT?5?9?5FADispatchDioc?5?9?5IOCTL?5cod@FNODOBFM@ DB 'F'
	DB	'LT - FADispatchDioc - IOCTL code = %#010x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?FADispatchIoctl@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z
_TEXT	SEGMENT
tv77 = -24						; size = 4
_status$ = -20						; size = 4
_pIrpStack$ = -16					; size = 4
_ctlCode$ = -12						; size = 4
_pFaDevExt$ = -8					; size = 4
_pFltDevExt$ = -4					; size = 4
_pDevObj$ = 8						; size = 4
_pIrp$ = 12						; size = 4
?FADispatchIoctl@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z PROC ; FADispatchIoctl, COMDAT

; 1503 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1504 : 	PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	eax, DWORD PTR _pIrp$[ebp]
	push	eax
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _pIrpStack$[ebp], eax

; 1505 : 	ULONG ctlCode = pIrpStack->Parameters.DeviceIoControl.IoControlCode;

	mov	ecx, DWORD PTR _pIrpStack$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR _ctlCode$[ebp], edx

; 1506 : 
; 1507 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1508 : 		"FLT - FADispatchDioc - IOCTL code = %#010x\n", ctlCode);

	mov	eax, DWORD PTR _ctlCode$[ebp]
	push	eax
	push	OFFSET ??_C@_0CM@CDEFGHPM@FLT?5?9?5FADispatchDioc?5?9?5IOCTL?5cod@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 16					; 00000010H

; 1509 : 
; 1510 : 	pIrp->IoStatus.Information = 0;	// bytes xfered

	mov	ecx, DWORD PTR _pIrp$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 1511 : 
; 1512 : 	// pFaDevExt points to the dev ext for the FA device. pFltDevExt
; 1513 : 	// points to the one for the filter device.
; 1514 : 	//
; 1515 : 	PFADEVICE_EXTENSION pFaDevExt = 
; 1516 : 		(PFADEVICE_EXTENSION) pDevObj->DeviceExtension;

	mov	edx, DWORD PTR _pDevObj$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR _pFaDevExt$[ebp], eax

; 1517 : 	PDEVICE_EXTENSION pFltDevExt = 
; 1518 : 		(PDEVICE_EXTENSION) pFaDevExt->pFilterDevExt;

	mov	ecx, DWORD PTR _pFaDevExt$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR _pFltDevExt$[ebp], edx

; 1519 : 	NTSTATUS status = STATUS_UNSUCCESSFUL;

	mov	DWORD PTR _status$[ebp], -1073741823	; c0000001H

; 1520 : 	//PMJF_CONTROL pOutFlags = NULL;
; 1521 : 	//PMJF_CONTROL pNewFlags = NULL;
; 1522 : 	switch (ctlCode) {

	mov	eax, DWORD PTR _ctlCode$[ebp]
	mov	DWORD PTR tv77[ebp], eax
	cmp	DWORD PTR tv77[ebp], 2252800		; 00226000H
	je	SHORT $LN3@FADispatch@2
	cmp	DWORD PTR tv77[ebp], 2269188		; 0022a004H
	je	SHORT $LN2@FADispatch@2
	jmp	SHORT $LN1@FADispatch@2
$LN3@FADispatch@2:

; 1523 : 	    case IOCTL_FILTER_GET_MJF_FLAGS:
; 1524 : 			status = IoctlGetMJFFlags(pIrp, pFltDevExt);

	mov	ecx, DWORD PTR _pFltDevExt$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pIrp$[ebp]
	push	edx
	call	?IoctlGetMJFFlags@@YGJPAU_IRP@@PAU_DEVICE_EXTENSION@@@Z ; IoctlGetMJFFlags
	mov	DWORD PTR _status$[ebp], eax

; 1525 : 			break;

	jmp	SHORT $LN4@FADispatch@2
$LN2@FADispatch@2:

; 1526 : 	    case IOCTL_FILTER_SET_MJF_FLAGS:
; 1527 : 			status = IoctlSetMJFFlags(pIrp, pFltDevExt);

	mov	eax, DWORD PTR _pFltDevExt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pIrp$[ebp]
	push	ecx
	call	?IoctlSetMJFFlags@@YGJPAU_IRP@@PAU_DEVICE_EXTENSION@@@Z ; IoctlSetMJFFlags
	mov	DWORD PTR _status$[ebp], eax

; 1528 : 			break;

	jmp	SHORT $LN4@FADispatch@2
$LN1@FADispatch@2:

; 1529 : 		default:
; 1530 : 			status = STATUS_INVALID_DEVICE_REQUEST;

	mov	DWORD PTR _status$[ebp], -1073741808	; c0000010H

; 1531 : 			pIrp->IoStatus.Status = status;

	mov	edx, DWORD PTR _pIrp$[ebp]
	mov	eax, DWORD PTR _status$[ebp]
	mov	DWORD PTR [edx+24], eax
$LN4@FADispatch@2:

; 1532 : 	}
; 1533 : 	return status;

	mov	eax, DWORD PTR _status$[ebp]

; 1534 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?FADispatchIoctl@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ENDP ; FADispatchIoctl
_TEXT	ENDS
PUBLIC	??_C@_0N@NLMLMCJE@GenericTrace?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
EXTRN	__imp__PoCallDriver@8:PROC
;	COMDAT ??_C@_0N@NLMLMCJE@GenericTrace?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0N@NLMLMCJE@GenericTrace?$AA@FNODOBFM@ DB 'GenericTrace', 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?GenericTrace@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z
_TEXT	SEGMENT
_pDevExt$ = -16						; size = 4
_MajFun$ = -9						; size = 1
_status$ = -8						; size = 4
_pStack$ = -4						; size = 4
_pDevObj$ = 8						; size = 4
_pIrp$ = 12						; size = 4
?GenericTrace@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z PROC	; GenericTrace, COMDAT

; 1720 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 1721 : 	PDEVICE_EXTENSION pDevExt = 
; 1722 : 		(PDEVICE_EXTENSION) pDevObj->DeviceExtension;

	mov	eax, DWORD PTR _pDevObj$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _pDevExt$[ebp], ecx

; 1723 : 	PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	edx, DWORD PTR _pIrp$[ebp]
	push	edx
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _pStack$[ebp], eax

; 1724 : 	UCHAR MajFun = pStack->MajorFunction;

	mov	eax, DWORD PTR _pStack$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _MajFun$[ebp], cl

; 1725 : 	NTSTATUS status = STATUS_UNSUCCESSFUL;

	mov	DWORD PTR _status$[ebp], -1073741823	; c0000001H

; 1726 : 	if (MajFun <= IRP_MJ_MAXIMUM_FUNCTION) { //One never knows...

	movzx	edx, BYTE PTR _MajFun$[ebp]
	cmp	edx, 27					; 0000001bH
	jg	$LN6@GenericTra

; 1727 : 		if ((pDevExt->dwMJFlags[MajFun]) & FCTL_TRACE_ON) {

	movzx	eax, BYTE PTR _MajFun$[ebp]
	mov	ecx, DWORD PTR _pDevExt$[ebp]
	mov	edx, DWORD PTR [ecx+eax*4+76]
	and	edx, 1
	je	SHORT $LN5@GenericTra

; 1728 : 			TraceIrpBasicInfo(pDevExt, "GenericTrace", pIrp);

	mov	eax, DWORD PTR _pIrp$[ebp]
	push	eax
	push	OFFSET ??_C@_0N@NLMLMCJE@GenericTrace?$AA@FNODOBFM@
	mov	ecx, DWORD PTR _pDevExt$[ebp]
	push	ecx
	call	?TraceIrpBasicInfo@@YGXPAU_DEVICE_EXTENSION@@PADPAU_IRP@@@Z ; TraceIrpBasicInfo

; 1729 : 
; 1730 : 			// Set the completion
; 1731 : 			// routine, which will track the IRP.
; 1732 : 			//
; 1733 : 			IoCopyCurrentIrpStackLocationToNext(pIrp);

	mov	edx, DWORD PTR _pIrp$[ebp]
	push	edx
	call	_IoCopyCurrentIrpStackLocationToNext@4

; 1734 : 			IoSetCompletionRoutine(pIrp, GTCompletion, pDevExt, TRUE, 
; 1735 : 				TRUE, TRUE);

	push	1
	push	1
	push	1
	mov	eax, DWORD PTR _pDevExt$[ebp]
	push	eax
	push	OFFSET ?GTCompletion@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@PAX@Z ; GTCompletion
	mov	ecx, DWORD PTR _pIrp$[ebp]
	push	ecx
	call	_IoSetCompletionRoutine@24

; 1736 : 			if (MajFun == IRP_MJ_POWER) {

	movzx	edx, BYTE PTR _MajFun$[ebp]
	cmp	edx, 22					; 00000016H
	jne	SHORT $LN4@GenericTra

; 1737 : 				status = PoCallDriver(pDevExt->pTargStack, pIrp);

	mov	eax, DWORD PTR _pIrp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDevExt$[ebp]
	mov	edx, DWORD PTR [ecx+204]
	push	edx
	call	DWORD PTR __imp__PoCallDriver@8
	mov	DWORD PTR _status$[ebp], eax

; 1738 : 			} else {

	jmp	SHORT $LN3@GenericTra
$LN4@GenericTra:

; 1739 : 				status = IoCallDriver(pDevExt->pTargStack, pIrp);

	mov	edx, DWORD PTR _pIrp$[ebp]
	mov	eax, DWORD PTR _pDevExt$[ebp]
	mov	ecx, DWORD PTR [eax+204]
	call	DWORD PTR __imp_@IofCallDriver@8
	mov	DWORD PTR _status$[ebp], eax
$LN3@GenericTra:

; 1740 : 			}
; 1741 : 		} else {

	jmp	SHORT $LN2@GenericTra
$LN5@GenericTra:

; 1742 : 
; 1743 : 			// Tracing is off. Just forward the IRP.
; 1744 : 			//
; 1745 : 			status = ForwardIrpOrPIrp(pDevObj, pIrp);

	mov	ecx, DWORD PTR _pIrp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDevObj$[ebp]
	push	edx
	call	?ForwardIrpOrPIrp@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ; ForwardIrpOrPIrp
	mov	DWORD PTR _status$[ebp], eax
$LN2@GenericTra:

; 1746 : 		}
; 1747 : 	} else {

	jmp	SHORT $LN1@GenericTra
$LN6@GenericTra:

; 1748 : 		status = ForwardIrpOrPIrp(pDevObj, pIrp);

	mov	eax, DWORD PTR _pIrp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDevObj$[ebp]
	push	ecx
	call	?ForwardIrpOrPIrp@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ; ForwardIrpOrPIrp
	mov	DWORD PTR _status$[ebp], eax
$LN1@GenericTra:

; 1749 : 
; 1750 : 	}
; 1751 : 	return status;

	mov	eax, DWORD PTR _status$[ebp]

; 1752 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?GenericTrace@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ENDP	; GenericTrace
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ForwardIrpOrPIrp@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z
_TEXT	SEGMENT
_MajFun$ = -9						; size = 1
_status$ = -8						; size = 4
_pStack$ = -4						; size = 4
_pDevObj$ = 8						; size = 4
_pIrp$ = 12						; size = 4
?ForwardIrpOrPIrp@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z PROC ; ForwardIrpOrPIrp, COMDAT

; 1626 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1627 : 	PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	eax, DWORD PTR _pIrp$[ebp]
	push	eax
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _pStack$[ebp], eax

; 1628 : 	UCHAR MajFun = pStack->MajorFunction;

	mov	ecx, DWORD PTR _pStack$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _MajFun$[ebp], dl

; 1629 : 	NTSTATUS status = STATUS_UNSUCCESSFUL;

	mov	DWORD PTR _status$[ebp], -1073741823	; c0000001H

; 1630 : 	if (MajFun == IRP_MJ_POWER) {

	movzx	eax, BYTE PTR _MajFun$[ebp]
	cmp	eax, 22					; 00000016H
	jne	SHORT $LN2@ForwardIrp

; 1631 : 
; 1632 : 		// Power IRP must be forwarded differently.
; 1633 : 		//
; 1634 : 		status = ForwardPIrpToNext(pDevObj, pIrp);

	mov	ecx, DWORD PTR _pIrp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDevObj$[ebp]
	push	edx
	call	?ForwardPIrpToNext@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ; ForwardPIrpToNext
	mov	DWORD PTR _status$[ebp], eax

; 1635 : 	} else {

	jmp	SHORT $LN1@ForwardIrp
$LN2@ForwardIrp:

; 1636 : 		status = ForwardToNext(pDevObj, pIrp);

	mov	eax, DWORD PTR _pIrp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDevObj$[ebp]
	push	ecx
	call	?ForwardToNext@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ; ForwardToNext
	mov	DWORD PTR _status$[ebp], eax
$LN1@ForwardIrp:

; 1637 : 	}
; 1638 : 	return status;

	mov	eax, DWORD PTR _status$[ebp]

; 1639 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ForwardIrpOrPIrp@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ENDP ; ForwardIrpOrPIrp
_TEXT	ENDS
EXTRN	__imp__PoStartNextPowerIrp@4:PROC
; Function compile flags: /Odtp
;	COMDAT ?ForwardPIrpToNext@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z
_TEXT	SEGMENT
_pDevExt$ = -4						; size = 4
_pDevObj$ = 8						; size = 4
_pIrp$ = 12						; size = 4
?ForwardPIrpToNext@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z PROC ; ForwardPIrpToNext, COMDAT

; 1660 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 1661 : 	PDEVICE_EXTENSION	pDevExt;
; 1662 : 
; 1663 : 	pDevExt = (PDEVICE_EXTENSION) pDevObj->DeviceExtension;

	mov	eax, DWORD PTR _pDevObj$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _pDevExt$[ebp], ecx

; 1664 : 	PoStartNextPowerIrp(pIrp);

	mov	edx, DWORD PTR _pIrp$[ebp]
	push	edx
	call	DWORD PTR __imp__PoStartNextPowerIrp@4

; 1665 : 	IoSkipCurrentIrpStackLocation(pIrp);

	mov	eax, DWORD PTR _pIrp$[ebp]
	push	eax
	call	_IoSkipCurrentIrpStackLocation@4

; 1666 : 	return PoCallDriver(
; 1667 : 		pDevExt->pTargStack,
; 1668 : 		pIrp );

	mov	ecx, DWORD PTR _pIrp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDevExt$[ebp]
	mov	eax, DWORD PTR [edx+204]
	push	eax
	call	DWORD PTR __imp__PoCallDriver@8

; 1669 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ForwardPIrpToNext@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ENDP ; ForwardPIrpToNext
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?ForwardToNext@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z
_TEXT	SEGMENT
_pDevExt$ = -4						; size = 4
_pDevObj$ = 8						; size = 4
_pIrp$ = 12						; size = 4
?ForwardToNext@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z PROC	; ForwardToNext, COMDAT

; 1689 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 1690 : 	PDEVICE_EXTENSION	pDevExt;
; 1691 : 
; 1692 : 	pDevExt = (PDEVICE_EXTENSION) pDevObj->DeviceExtension;

	mov	eax, DWORD PTR _pDevObj$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _pDevExt$[ebp], ecx

; 1693 : 
; 1694 : 	IoSkipCurrentIrpStackLocation(pIrp);

	mov	edx, DWORD PTR _pIrp$[ebp]
	push	edx
	call	_IoSkipCurrentIrpStackLocation@4

; 1695 : 	return IoCallDriver(
; 1696 : 		pDevExt->pTargStack,
; 1697 : 		pIrp );

	mov	edx, DWORD PTR _pIrp$[ebp]
	mov	eax, DWORD PTR _pDevExt$[ebp]
	mov	ecx, DWORD PTR [eax+204]
	call	DWORD PTR __imp_@IofCallDriver@8

; 1698 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?ForwardToNext@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ENDP	; ForwardToNext
_TEXT	ENDS
PUBLIC	??_C@_0DL@GMEEJJEE@FLT?5?9?5GetWriteData?5?9?5Write?5data?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp__MmMapLockedPagesSpecifyCache@24:PROC
;	COMDAT ??_C@_0DL@GMEEJJEE@FLT?5?9?5GetWriteData?5?9?5Write?5data?5@FNODOBFM@
text$s	SEGMENT
??_C@_0DL@GMEEJJEE@FLT?5?9?5GetWriteData?5?9?5Write?5data?5@FNODOBFM@ DB 'F'
	DB	'LT - GetWriteData - Write data address: %#p, length: %#x', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?GetWriteData@@YGXPAU_IRP@@PAU_DEVICE_EXTENSION@@PAPAXPAK@Z
_TEXT	SEGMENT
tv87 = -16						; size = 4
_pBufStart$26670 = -12					; size = 4
_pMdl$26669 = -8					; size = 4
_pStack$ = -4						; size = 4
_pIrp$ = 8						; size = 4
_pDevExt$ = 12						; size = 4
_ppWriteData$ = 16					; size = 4
_pcbDataLen$ = 20					; size = 4
?GetWriteData@@YGXPAU_IRP@@PAU_DEVICE_EXTENSION@@PAPAXPAK@Z PROC ; GetWriteData, COMDAT

; 2177 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2178 : 	*ppWriteData = NULL;

	mov	eax, DWORD PTR _ppWriteData$[ebp]
	mov	DWORD PTR [eax], 0

; 2179 : 	*pcbDataLen = 0;

	mov	ecx, DWORD PTR _pcbDataLen$[ebp]
	mov	DWORD PTR [ecx], 0

; 2180 : 
; 2181 : 	PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	edx, DWORD PTR _pIrp$[ebp]
	push	edx
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _pStack$[ebp], eax

; 2182 : 	*pcbDataLen = pStack->Parameters.Write.Length;

	mov	eax, DWORD PTR _pcbDataLen$[ebp]
	mov	ecx, DWORD PTR _pStack$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 2183 : 	if (!*pcbDataLen) return;

	mov	eax, DWORD PTR _pcbDataLen$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@GetWriteDa
	jmp	$LN6@GetWriteDa
$LN5@GetWriteDa:

; 2184 : 
; 2185 : 	// Determine the buffering mode
; 2186 : 	//
; 2187 : 	if (pDevExt->hdr.pDevice->Flags & DO_DIRECT_IO) {

	mov	ecx, DWORD PTR _pDevExt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+28]
	and	eax, 16					; 00000010H
	je	SHORT $LN4@GetWriteDa

; 2188 : 
; 2189 : 		PMDL pMdl = pIrp->MdlAddress;

	mov	ecx, DWORD PTR _pIrp$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _pMdl$26669[ebp], edx

; 2190 : 		PCHAR pBufStart = (PCHAR) MmGetSystemAddressForMdlSafe(pMdl, 
; 2191 : 				LowPagePriority);

	mov	eax, DWORD PTR _pMdl$26669[ebp]
	movsx	ecx, WORD PTR [eax+6]
	and	ecx, 5
	je	SHORT $LN8@GetWriteDa
	mov	edx, DWORD PTR _pMdl$26669[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv87[ebp], eax
	jmp	SHORT $LN9@GetWriteDa
$LN8@GetWriteDa:
	push	0
	push	0
	push	0
	push	1
	push	0
	mov	ecx, DWORD PTR _pMdl$26669[ebp]
	push	ecx
	call	DWORD PTR __imp__MmMapLockedPagesSpecifyCache@24
	mov	DWORD PTR tv87[ebp], eax
$LN9@GetWriteDa:
	mov	edx, DWORD PTR tv87[ebp]
	mov	DWORD PTR _pBufStart$26670[ebp], edx

; 2192 : 		if (pBufStart != NULL) {

	cmp	DWORD PTR _pBufStart$26670[ebp], 0
	je	SHORT $LN3@GetWriteDa

; 2193 : 			*ppWriteData = pBufStart;

	mov	eax, DWORD PTR _ppWriteData$[ebp]
	mov	ecx, DWORD PTR _pBufStart$26670[ebp]
	mov	DWORD PTR [eax], ecx

; 2194 : 		} else {

	jmp	SHORT $LN2@GetWriteDa
$LN3@GetWriteDa:

; 2195 : 
; 2196 : 			// This should never happen, because the client buffer
; 2197 : 			// has already been locked in place by who issued the
; 2198 : 			// read IRP.
; 2199 : 			//
; 2200 : 			*pcbDataLen = 0;

	mov	edx, DWORD PTR _pcbDataLen$[ebp]
	mov	DWORD PTR [edx], 0
$LN2@GetWriteDa:

; 2201 : 		}
; 2202 : 	} else {

	jmp	SHORT $LN1@GetWriteDa
$LN4@GetWriteDa:

; 2203 : 
; 2204 : 		// Buffered I/O
; 2205 : 		//
; 2206 : 		*ppWriteData = pIrp->AssociatedIrp.SystemBuffer;

	mov	eax, DWORD PTR _ppWriteData$[ebp]
	mov	ecx, DWORD PTR _pIrp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax], edx
$LN1@GetWriteDa:

; 2207 : 	}
; 2208 : 
; 2209 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 2210 : 		"FLT - GetWriteData - Write data address: %#p, length: %#x\n",
; 2211 : 		*ppWriteData, *pcbDataLen);

	mov	eax, DWORD PTR _pcbDataLen$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _ppWriteData$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET ??_C@_0DL@GMEEJJEE@FLT?5?9?5GetWriteData?5?9?5Write?5data?5@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 20					; 00000014H
$LN6@GetWriteDa:

; 2212 : 
; 2213 : 	return;
; 2214 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?GetWriteData@@YGXPAU_IRP@@PAU_DEVICE_EXTENSION@@PAPAXPAK@Z ENDP ; GetWriteData
_TEXT	ENDS
PUBLIC	_IoMarkIrpPending@4
PUBLIC	??_C@_0CF@GHKHGNKG@?7Status?5?$DN?5?$CF?$CD010x?6?7Information?5?$DN?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0N@IHJEBEEH@GTCompletion?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0CF@GHKHGNKG@?7Status?5?$DN?5?$CF?$CD010x?6?7Information?5?$DN?5@FNODOBFM@
text$s	SEGMENT
??_C@_0CF@GHKHGNKG@?7Status?5?$DN?5?$CF?$CD010x?6?7Information?5?$DN?5@FNODOBFM@ DB 09H
	DB	'Status = %#010x', 0aH, 09H, 'Information = %#x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0N@IHJEBEEH@GTCompletion?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_0N@IHJEBEEH@GTCompletion?$AA@FNODOBFM@ DB 'GTCompletion', 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?GTCompletion@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@PAX@Z
_TEXT	SEGMENT
_klock$ = -24						; size = 12
_pDevExt$ = -12						; size = 4
_MajFun$ = -5						; size = 1
_pStack$ = -4						; size = 4
_pDevObj$ = 8						; size = 4
_pIrp$ = 12						; size = 4
_Context$ = 16						; size = 4
?GTCompletion@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@PAX@Z PROC ; GTCompletion, COMDAT

; 2238 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 2239 : 	PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	eax, DWORD PTR _pIrp$[ebp]
	push	eax
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _pStack$[ebp], eax

; 2240 : 	UCHAR MajFun = pStack->MajorFunction;

	mov	ecx, DWORD PTR _pStack$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _MajFun$[ebp], dl

; 2241 : 	PDEVICE_EXTENSION pDevExt = 
; 2242 : 		(PDEVICE_EXTENSION) Context;

	mov	eax, DWORD PTR _Context$[ebp]
	mov	DWORD PTR _pDevExt$[ebp], eax

; 2243 : 	TraceIrpBasicInfo(pDevExt, "GTCompletion", pIrp);

	mov	ecx, DWORD PTR _pIrp$[ebp]
	push	ecx
	push	OFFSET ??_C@_0N@IHJEBEEH@GTCompletion?$AA@FNODOBFM@
	mov	edx, DWORD PTR _pDevExt$[ebp]
	push	edx
	call	?TraceIrpBasicInfo@@YGXPAU_DEVICE_EXTENSION@@PADPAU_IRP@@@Z ; TraceIrpBasicInfo

; 2244 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 2245 : 		"\tStatus = %#010x\n"
; 2246 : 		"\tInformation = %#x\n",
; 2247 : 		pIrp->IoStatus.Status,
; 2248 : 		pIrp->IoStatus.Information);

	mov	eax, DWORD PTR _pIrp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _pIrp$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	push	OFFSET ??_C@_0CF@GHKHGNKG@?7Status?5?$DN?5?$CF?$CD010x?6?7Information?5?$DN?5@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 20					; 00000014H

; 2249 : 
; 2250 : 	KLOCK_QUEUE_HANDLE klock;
; 2251 : 
; 2252 : 	KeAcquireInStackQueuedSpinLock(&pDevExt->DataLock, &klock);

	mov	ecx, DWORD PTR _pDevExt$[ebp]
	add	ecx, 68					; 00000044H
	lea	edx, DWORD PTR _klock$[ebp]
	call	DWORD PTR __imp_@KeAcquireInStackQueuedSpinLock@8

; 2253 : 
; 2254 : 	InterceptIrpAndData(pIrp, NULL, 0, pDevExt);

	mov	ecx, DWORD PTR _pDevExt$[ebp]
	push	ecx
	push	0
	push	0
	mov	edx, DWORD PTR _pIrp$[ebp]
	push	edx
	call	?InterceptIrpAndData@@YGXPAU_IRP@@PAXKPAU_DEVICE_EXTENSION@@@Z ; InterceptIrpAndData

; 2255 : 	SendIrpDataToClt(pDevExt);

	mov	eax, DWORD PTR _pDevExt$[ebp]
	push	eax
	call	?SendIrpDataToClt@@YGXPAU_DEVICE_EXTENSION@@@Z ; SendIrpDataToClt

; 2256 : 
; 2257 : 	KeReleaseInStackQueuedSpinLock(&klock);

	lea	ecx, DWORD PTR _klock$[ebp]
	call	DWORD PTR __imp_@KeReleaseInStackQueuedSpinLock@4

; 2258 : 
; 2259 : 	if (MajFun == IRP_MJ_POWER) PoStartNextPowerIrp(pIrp);

	movzx	ecx, BYTE PTR _MajFun$[ebp]
	cmp	ecx, 22					; 00000016H
	jne	SHORT $LN2@GTCompleti
	mov	edx, DWORD PTR _pIrp$[ebp]
	push	edx
	call	DWORD PTR __imp__PoStartNextPowerIrp@4
$LN2@GTCompleti:

; 2260 : 	if (pIrp->PendingReturned) IoMarkIrpPending(pIrp);

	mov	eax, DWORD PTR _pIrp$[ebp]
	movzx	ecx, BYTE PTR [eax+33]
	test	ecx, ecx
	je	SHORT $LN1@GTCompleti
	mov	edx, DWORD PTR _pIrp$[ebp]
	push	edx
	call	_IoMarkIrpPending@4
$LN1@GTCompleti:

; 2261 : 	return STATUS_SUCCESS;

	xor	eax, eax

; 2262 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GTCompletion@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@PAX@Z ENDP ; GTCompletion
; Function compile flags: /Odtp
; File c:\apps\pw7hp\devpgm\msddk\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT _IoMarkIrpPending@4
_TEXT	SEGMENT
tv67 = -4						; size = 4
_Irp$ = 8						; size = 4
_IoMarkIrpPending@4 PROC				; COMDAT

; 23667: {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 23668:     IoGetCurrentIrpStackLocation( (Irp) )->Control |= SL_PENDING_RETURNED;

	mov	eax, DWORD PTR _Irp$[ebp]
	push	eax
	call	_IoGetCurrentIrpStackLocation@4
	add	eax, 3
	mov	DWORD PTR tv67[ebp], eax
	mov	ecx, DWORD PTR tv67[ebp]
	movzx	edx, BYTE PTR [ecx]
	or	edx, 1
	mov	eax, DWORD PTR tv67[ebp]
	mov	BYTE PTR [eax], dl

; 23669: }

	mov	esp, ebp
	pop	ebp
	ret	4
_IoMarkIrpPending@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0EO@KNKPAAK@FLT?5?9?5InterceptIrpAndData?5?9?5Stor@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0FA@GIHNANGK@FLT?5?9?5InterceptIrpAndData?5?9?5Stor@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0DN@KNINDNNC@FLT?5?9?5InterceptIrpAndData?5?9?5Stor@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EK@OJJBHMCK@FLT?5?9?5InterceptIrpAndData?5?9?5Buff@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	?CBStore@@YGJPAU_CIRCULAR_BUFFER@@PAPADPAK22@Z:PROC ; CBStore
EXTRN	?CBAllocateBlock@@YGJPAU_CIRCULAR_BUFFER@@K@Z:PROC ; CBAllocateBlock
;	COMDAT ??_C@_0EO@KNKPAAK@FLT?5?9?5InterceptIrpAndData?5?9?5Stor@FNODOBFM@
; File b:\programm\wntsys\testfilter\release\1_1\source\driver\drvmain.cpp
text$s	SEGMENT
??_C@_0EO@KNKPAAK@FLT?5?9?5InterceptIrpAndData?5?9?5Stor@FNODOBFM@ DB 'FL'
	DB	'T - InterceptIrpAndData - Storing %#x bytes of data at %#p in'
	DB	'to the buffer', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0FA@GIHNANGK@FLT?5?9?5InterceptIrpAndData?5?9?5Stor@FNODOBFM@
text$s	SEGMENT
??_C@_0FA@GIHNANGK@FLT?5?9?5InterceptIrpAndData?5?9?5Stor@FNODOBFM@ DB 'F'
	DB	'LT - InterceptIrpAndData - Storing current stack location %#p'
	DB	' into the buffer', 0aH, 00H			;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0DN@KNINDNNC@FLT?5?9?5InterceptIrpAndData?5?9?5Stor@FNODOBFM@
text$s	SEGMENT
??_C@_0DN@KNINDNNC@FLT?5?9?5InterceptIrpAndData?5?9?5Stor@FNODOBFM@ DB 'F'
	DB	'LT - InterceptIrpAndData - Storing IRP %#p into the buffer', 0aH
	DB	00H						;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EK@OJJBHMCK@FLT?5?9?5InterceptIrpAndData?5?9?5Buff@FNODOBFM@
text$s	SEGMENT
??_C@_0EK@OJJBHMCK@FLT?5?9?5InterceptIrpAndData?5?9?5Buff@FNODOBFM@ DB 'F'
	DB	'LT - InterceptIrpAndData - Buffer allocation failed with stat'
	DB	'us: %#010x', 0aH, 00H			;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?InterceptIrpAndData@@YGXPAU_IRP@@PAXKPAU_DEVICE_EXTENSION@@@Z
_TEXT	SEGMENT
_cbBlockOffset$ = -28					; size = 4
_pBuf$ = -24						; size = 4
_cbStoreLength$ = -20					; size = 4
_status$ = -16						; size = 4
_pStore$ = -12						; size = 4
_IrpHea$ = -8						; size = 8
_pIrp$ = 8						; size = 4
_pData$ = 12						; size = 4
_cbDataLen$ = 16					; size = 4
_pDevExt$ = 20						; size = 4
?InterceptIrpAndData@@YGXPAU_IRP@@PAXKPAU_DEVICE_EXTENSION@@@Z PROC ; InterceptIrpAndData, COMDAT

; 2316 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 2317 : 	PCIRCULAR_BUFFER pBuf = &pDevExt->DataBuffer;

	mov	eax, DWORD PTR _pDevExt$[ebp]
	add	eax, 40					; 00000028H
	mov	DWORD PTR _pBuf$[ebp], eax

; 2318 : 	NTSTATUS		status;
; 2319 : 
; 2320 : 	// Allocate a buffer block to store the IRP with its header,
; 2321 : 	// its I/O stack loc and its data, iF any.
; 2322 : 	//
; 2323 : 	status = CBAllocateBlock(
; 2324 : 		pBuf,
; 2325 : 		sizeof (IRP_HEADER) + sizeof (IRP) + sizeof(IO_STACK_LOCATION) + 
; 2326 : 			cbDataLen
; 2327 : 	);

	mov	ecx, DWORD PTR _cbDataLen$[ebp]
	add	ecx, 156				; 0000009cH
	push	ecx
	mov	edx, DWORD PTR _pBuf$[ebp]
	push	edx
	call	?CBAllocateBlock@@YGJPAU_CIRCULAR_BUFFER@@K@Z ; CBAllocateBlock
	mov	DWORD PTR _status$[ebp], eax

; 2328 : 
; 2329 : 	if (NT_ERROR(status)) {	// This should happen only if the size

	mov	eax, DWORD PTR _status$[ebp]
	shr	eax, 30					; 0000001eH
	cmp	eax, 3
	jne	SHORT $LN3@InterceptI

; 2330 : 								// is greater than the entire buffer 
; 2331 : 								// size
; 2332 : 
; 2333 : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 2334 : 			"FLT - InterceptIrpAndData - Buffer allocation failed "
; 2335 : 			"with status: %#010x\n", 
; 2336 : 			status);

	mov	ecx, DWORD PTR _status$[ebp]
	push	ecx
	push	OFFSET ??_C@_0EK@OJJBHMCK@FLT?5?9?5InterceptIrpAndData?5?9?5Buff@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 16					; 00000010H

; 2337 : 		// Set the data lost flag and quit
; 2338 : 		//
; 2339 : 		pDevExt->dwStatus |= FSTATUS_DATA_LOST;

	mov	edx, DWORD PTR _pDevExt$[ebp]
	mov	eax, DWORD PTR [edx+188]
	or	eax, 1
	mov	ecx, DWORD PTR _pDevExt$[ebp]
	mov	DWORD PTR [ecx+188], eax

; 2340 : 		return;

	jmp	$LN4@InterceptI
$LN3@InterceptI:

; 2341 : 	}
; 2342 : 
; 2343 : 	if (status == CB_STATUS_WARN_DATA_LOST) {	// Data has been thrown 

	cmp	DWORD PTR _status$[ebp], -1610612735	; a0000001H
	jne	SHORT $LN2@InterceptI

; 2344 : 		// out to make room into the buffer.
; 2345 : 
; 2346 : 		pDevExt->dwStatus |= FSTATUS_DATA_LOST;

	mov	edx, DWORD PTR _pDevExt$[ebp]
	mov	eax, DWORD PTR [edx+188]
	or	eax, 1
	mov	ecx, DWORD PTR _pDevExt$[ebp]
	mov	DWORD PTR [ecx+188], eax
$LN2@InterceptI:

; 2347 : 	}
; 2348 : 
; 2349 : 	// Set up the IRP header and store it into the buffer.
; 2350 : 	//
; 2351 : 	IRP_HEADER IrpHea = {0};

	mov	DWORD PTR _IrpHea$[ebp], 0
	xor	edx, edx
	mov	DWORD PTR _IrpHea$[ebp+4], edx

; 2352 : 	IrpHea.cbDataLen = cbDataLen;

	mov	eax, DWORD PTR _cbDataLen$[ebp]
	mov	DWORD PTR _IrpHea$[ebp+4], eax

; 2353 : 	PCHAR pStore = (PCHAR) &IrpHea;

	lea	ecx, DWORD PTR _IrpHea$[ebp]
	mov	DWORD PTR _pStore$[ebp], ecx

; 2354 : 	SIZE_T cbBlockOffset = 0;

	mov	DWORD PTR _cbBlockOffset$[ebp], 0

; 2355 : 	SIZE_T cbStoreLength = sizeof IrpHea;

	mov	DWORD PTR _cbStoreLength$[ebp], 8

; 2356 : 
; 2357 : 	// Don't check CBStore ret status, because we are sure we have 
; 2358 : 	// allocated the block.
; 2359 : 	//
; 2360 : 	CBStore(pBuf, &pStore, &cbStoreLength, &cbBlockOffset, NULL);

	push	0
	lea	edx, DWORD PTR _cbBlockOffset$[ebp]
	push	edx
	lea	eax, DWORD PTR _cbStoreLength$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pStore$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pBuf$[ebp]
	push	edx
	call	?CBStore@@YGJPAU_CIRCULAR_BUFFER@@PAPADPAK22@Z ; CBStore

; 2361 : 
; 2362 : 	// Now store the IRP into the buffer.
; 2363 : 	//
; 2364 : 	pStore = (PCHAR) pIrp;

	mov	eax, DWORD PTR _pIrp$[ebp]
	mov	DWORD PTR _pStore$[ebp], eax

; 2365 : 	cbStoreLength = sizeof (IRP);

	mov	DWORD PTR _cbStoreLength$[ebp], 112	; 00000070H

; 2366 : 
; 2367 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 2368 : 		"FLT - InterceptIrpAndData - Storing IRP %#p into the "
; 2369 : 		"buffer\n", pIrp);

	mov	ecx, DWORD PTR _pIrp$[ebp]
	push	ecx
	push	OFFSET ??_C@_0DN@KNINDNNC@FLT?5?9?5InterceptIrpAndData?5?9?5Stor@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 16					; 00000010H

; 2370 : 
; 2371 : 	CBStore(pBuf, &pStore, &cbStoreLength, &cbBlockOffset, NULL);

	push	0
	lea	edx, DWORD PTR _cbBlockOffset$[ebp]
	push	edx
	lea	eax, DWORD PTR _cbStoreLength$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pStore$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pBuf$[ebp]
	push	edx
	call	?CBStore@@YGJPAU_CIRCULAR_BUFFER@@PAPADPAK22@Z ; CBStore

; 2372 : 
; 2373 : 	// Store the current stack location into the buffer.
; 2374 : 	//
; 2375 : 	pStore = (PCHAR) IoGetCurrentIrpStackLocation(pIrp);

	mov	eax, DWORD PTR _pIrp$[ebp]
	push	eax
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _pStore$[ebp], eax

; 2376 : 	cbStoreLength = sizeof (IO_STACK_LOCATION);

	mov	DWORD PTR _cbStoreLength$[ebp], 36	; 00000024H

; 2377 : 
; 2378 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 2379 : 		"FLT - InterceptIrpAndData - Storing current stack "
; 2380 : 		"location %#p into the "
; 2381 : 		"buffer\n", pStore);

	mov	ecx, DWORD PTR _pStore$[ebp]
	push	ecx
	push	OFFSET ??_C@_0FA@GIHNANGK@FLT?5?9?5InterceptIrpAndData?5?9?5Stor@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 16					; 00000010H

; 2382 : 
; 2383 : 	CBStore(pBuf, &pStore, &cbStoreLength, &cbBlockOffset, NULL);

	push	0
	lea	edx, DWORD PTR _cbBlockOffset$[ebp]
	push	edx
	lea	eax, DWORD PTR _cbStoreLength$[ebp]
	push	eax
	lea	ecx, DWORD PTR _pStore$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pBuf$[ebp]
	push	edx
	call	?CBStore@@YGJPAU_CIRCULAR_BUFFER@@PAPADPAK22@Z ; CBStore

; 2384 : 
; 2385 : 	if (cbStoreLength = cbDataLen) {	// The = operator is 

	mov	eax, DWORD PTR _cbDataLen$[ebp]
	mov	DWORD PTR _cbStoreLength$[ebp], eax
	cmp	DWORD PTR _cbStoreLength$[ebp], 0
	je	SHORT $LN4@InterceptI

; 2386 : 										// intentional!
; 2387 : 										// Check cbDataLen != 0 
; 2388 : 										// and copy it into 
; 2389 : 										// cbStoreLength.
; 2390 : 		pStore = (PCHAR) pData;

	mov	ecx, DWORD PTR _pData$[ebp]
	mov	DWORD PTR _pStore$[ebp], ecx

; 2391 : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 2392 : 			"FLT - InterceptIrpAndData - Storing %#x bytes of "
; 2393 : 			"data at %#p into the "
; 2394 : 			"buffer\n", cbDataLen, pStore);

	mov	edx, DWORD PTR _pStore$[ebp]
	push	edx
	mov	eax, DWORD PTR _cbDataLen$[ebp]
	push	eax
	push	OFFSET ??_C@_0EO@KNKPAAK@FLT?5?9?5InterceptIrpAndData?5?9?5Stor@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 20					; 00000014H

; 2395 : 		CBStore(pBuf, &pStore, &cbStoreLength, &cbBlockOffset, NULL);

	push	0
	lea	ecx, DWORD PTR _cbBlockOffset$[ebp]
	push	ecx
	lea	edx, DWORD PTR _cbStoreLength$[ebp]
	push	edx
	lea	eax, DWORD PTR _pStore$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pBuf$[ebp]
	push	ecx
	call	?CBStore@@YGJPAU_CIRCULAR_BUFFER@@PAPADPAK22@Z ; CBStore
$LN4@InterceptI:

; 2396 : 	}
; 2397 : 	return;
; 2398 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?InterceptIrpAndData@@YGXPAU_IRP@@PAXKPAU_DEVICE_EXTENSION@@@Z ENDP ; InterceptIrpAndData
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IoctlGetMJFFlags@@YGJPAU_IRP@@PAU_DEVICE_EXTENSION@@@Z
_TEXT	SEGMENT
_status$ = -16						; size = 4
_MajFun$ = -9						; size = 1
_pStack$ = -8						; size = 4
_pOutFlags$ = -4					; size = 4
_pIrp$ = 8						; size = 4
_pFltDevExt$ = 12					; size = 4
?IoctlGetMJFFlags@@YGJPAU_IRP@@PAU_DEVICE_EXTENSION@@@Z PROC ; IoctlGetMJFFlags, COMDAT

; 2420 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 2421 : 	NTSTATUS status = STATUS_UNSUCCESSFUL;

	mov	DWORD PTR _status$[ebp], -1073741823	; c0000001H

; 2422 : 	pIrp->IoStatus.Information = 0;

	mov	eax, DWORD PTR _pIrp$[ebp]
	mov	DWORD PTR [eax+28], 0

; 2423 : 	PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	ecx, DWORD PTR _pIrp$[ebp]
	push	ecx
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _pStack$[ebp], eax

; 2424 : 	if (pStack->Parameters.DeviceIoControl.OutputBufferLength <
; 2425 : 		sizeof (MJF_CONTROL)) {

	mov	edx, DWORD PTR _pStack$[ebp]
	cmp	DWORD PTR [edx+4], 8
	jae	SHORT $LN4@IoctlGetMJ

; 2426 : 		status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR _status$[ebp], -1073741811	; c000000dH
	jmp	SHORT $QUIT$26730

; 2427 : 		goto QUIT;

	jmp	SHORT $QUIT$26730
$LN4@IoctlGetMJ:

; 2428 : 	}
; 2429 : 	PMJF_CONTROL pOutFlags = 
; 2430 : 		(PMJF_CONTROL) pIrp->AssociatedIrp.SystemBuffer;

	mov	eax, DWORD PTR _pIrp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _pOutFlags$[ebp], ecx

; 2431 : 	UCHAR MajFun = pOutFlags->MajorFunction;

	mov	edx, DWORD PTR _pOutFlags$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _MajFun$[ebp], al

; 2432 : 	if (MajFun > IRP_MJ_MAXIMUM_FUNCTION) {

	movzx	ecx, BYTE PTR _MajFun$[ebp]
	cmp	ecx, 27					; 0000001bH
	jle	SHORT $LN2@IoctlGetMJ

; 2433 : 		status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR _status$[ebp], -1073741811	; c000000dH
	jmp	SHORT $QUIT$26730

; 2434 : 		goto QUIT;

	jmp	SHORT $QUIT$26730
$LN2@IoctlGetMJ:

; 2435 : 	}
; 2436 : 	pOutFlags->dwFlags = pFltDevExt->dwMJFlags[MajFun];

	movzx	edx, BYTE PTR _MajFun$[ebp]
	mov	eax, DWORD PTR _pOutFlags$[ebp]
	mov	ecx, DWORD PTR _pFltDevExt$[ebp]
	mov	edx, DWORD PTR [ecx+edx*4+76]
	mov	DWORD PTR [eax+4], edx

; 2437 :     status = STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 2438 : 	pIrp->IoStatus.Information = sizeof (MJF_CONTROL);

	mov	eax, DWORD PTR _pIrp$[ebp]
	mov	DWORD PTR [eax+28], 8
$QUIT$26730:

; 2439 : 
; 2440 : QUIT:
; 2441 : 	pIrp->IoStatus.Status = status;

	mov	ecx, DWORD PTR _pIrp$[ebp]
	mov	edx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 2442 : 	return status;

	mov	eax, DWORD PTR _status$[ebp]

; 2443 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?IoctlGetMJFFlags@@YGJPAU_IRP@@PAU_DEVICE_EXTENSION@@@Z ENDP ; IoctlGetMJFFlags
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?IoctlSetMJFFlags@@YGJPAU_IRP@@PAU_DEVICE_EXTENSION@@@Z
_TEXT	SEGMENT
_i$26756 = -20						; size = 4
_status$ = -16						; size = 4
_MajFun$ = -9						; size = 1
_pStack$ = -8						; size = 4
_pNewFlags$ = -4					; size = 4
_pIrp$ = 8						; size = 4
_pFltDevExt$ = 12					; size = 4
?IoctlSetMJFFlags@@YGJPAU_IRP@@PAU_DEVICE_EXTENSION@@@Z PROC ; IoctlSetMJFFlags, COMDAT

; 2465 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2466 : 	NTSTATUS status = STATUS_UNSUCCESSFUL;

	mov	DWORD PTR _status$[ebp], -1073741823	; c0000001H

; 2467 : 	pIrp->IoStatus.Information = 0;

	mov	eax, DWORD PTR _pIrp$[ebp]
	mov	DWORD PTR [eax+28], 0

; 2468 : 	PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	ecx, DWORD PTR _pIrp$[ebp]
	push	ecx
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _pStack$[ebp], eax

; 2469 : 	if (pStack->Parameters.DeviceIoControl.InputBufferLength <
; 2470 : 		sizeof (MJF_CONTROL)) {

	mov	edx, DWORD PTR _pStack$[ebp]
	cmp	DWORD PTR [edx+8], 8
	jae	SHORT $LN9@IoctlSetMJ

; 2471 : 		status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR _status$[ebp], -1073741811	; c000000dH
	jmp	$QUIT$26750

; 2472 : 		goto QUIT;

	jmp	SHORT $QUIT$26750
$LN9@IoctlSetMJ:

; 2473 : 	}
; 2474 : 	PMJF_CONTROL pNewFlags = 
; 2475 : 		(PMJF_CONTROL) pIrp->AssociatedIrp.SystemBuffer;

	mov	eax, DWORD PTR _pIrp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _pNewFlags$[ebp], ecx

; 2476 : 	UCHAR MajFun = pNewFlags->MajorFunction;

	mov	edx, DWORD PTR _pNewFlags$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _MajFun$[ebp], al

; 2477 : 	if (MajFun == 0xff) {

	movzx	ecx, BYTE PTR _MajFun$[ebp]
	cmp	ecx, 255				; 000000ffH
	jne	SHORT $LN7@IoctlSetMJ

; 2478 : 
; 2479 : 		// 0xff means to set the flags for all the function codes.
; 2480 : 		//
; 2481 : 		for (INT i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) {

	mov	DWORD PTR _i$26756[ebp], 0
	jmp	SHORT $LN6@IoctlSetMJ
$LN5@IoctlSetMJ:
	mov	edx, DWORD PTR _i$26756[ebp]
	add	edx, 1
	mov	DWORD PTR _i$26756[ebp], edx
$LN6@IoctlSetMJ:
	cmp	DWORD PTR _i$26756[ebp], 27		; 0000001bH
	jge	SHORT $LN4@IoctlSetMJ

; 2482 : 			pFltDevExt->dwMJFlags[i] = pNewFlags->dwFlags;

	mov	eax, DWORD PTR _i$26756[ebp]
	mov	ecx, DWORD PTR _pFltDevExt$[ebp]
	mov	edx, DWORD PTR _pNewFlags$[ebp]
	mov	edx, DWORD PTR [edx+4]
	mov	DWORD PTR [ecx+eax*4+76], edx

; 2483 : 		}

	jmp	SHORT $LN5@IoctlSetMJ
$LN4@IoctlSetMJ:

; 2484 : 		status = STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0
	jmp	SHORT $QUIT$26750

; 2485 : 		goto QUIT;

	jmp	SHORT $QUIT$26750
$LN7@IoctlSetMJ:

; 2486 : 	}
; 2487 : 	if (MajFun > IRP_MJ_MAXIMUM_FUNCTION) {

	movzx	eax, BYTE PTR _MajFun$[ebp]
	cmp	eax, 27					; 0000001bH
	jle	SHORT $LN2@IoctlSetMJ

; 2488 : 		status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR _status$[ebp], -1073741811	; c000000dH
	jmp	SHORT $QUIT$26750

; 2489 : 		goto QUIT;

	jmp	SHORT $QUIT$26750
$LN2@IoctlSetMJ:

; 2490 : 	}
; 2491 : 	pFltDevExt->dwMJFlags[MajFun] = pNewFlags->dwFlags;

	movzx	ecx, BYTE PTR _MajFun$[ebp]
	mov	edx, DWORD PTR _pFltDevExt$[ebp]
	mov	eax, DWORD PTR _pNewFlags$[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edx+ecx*4+76], eax

; 2492 :     status = STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0
$QUIT$26750:

; 2493 : 
; 2494 : QUIT:
; 2495 : 	pIrp->IoStatus.Status = status;

	mov	ecx, DWORD PTR _pIrp$[ebp]
	mov	edx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 2496 : 	return status;

	mov	eax, DWORD PTR _status$[ebp]

; 2497 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?IoctlSetMJFFlags@@YGJPAU_IRP@@PAU_DEVICE_EXTENSION@@@Z ENDP ; IoctlSetMJFFlags
_TEXT	ENDS
PUBLIC	??_C@_0EE@FCHCFMEI@FLT?5?9?5MAMainDispatch?5?9?5Client?5IR@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0EE@FCHCFMEI@FLT?5?9?5MAMainDispatch?5?9?5Client?5IR@FNODOBFM@
text$s	SEGMENT
??_C@_0EE@FCHCFMEI@FLT?5?9?5MAMainDispatch?5?9?5Client?5IR@FNODOBFM@ DB 'F'
	DB	'LT - MAMainDispatch - Client IRP %#p completed with status %#'
	DB	'010x', 0aH, 00H				;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?MAMainDispatch@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z
_TEXT	SEGMENT
tv67 = -12						; size = 4
_status$ = -8						; size = 4
_pStack$ = -4						; size = 4
_pDevObj$ = 8						; size = 4
_pIrp$ = 12						; size = 4
?MAMainDispatch@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z PROC	; MAMainDispatch, COMDAT

; 2681 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 2682 : 	NTSTATUS status;
; 2683 : 	PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	eax, DWORD PTR _pIrp$[ebp]
	push	eax
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _pStack$[ebp], eax

; 2684 : 	switch (pStack->MajorFunction) {

	mov	ecx, DWORD PTR _pStack$[ebp]
	movzx	edx, BYTE PTR [ecx]
	mov	DWORD PTR tv67[ebp], edx
	cmp	DWORD PTR tv67[ebp], 18			; 00000012H
	ja	SHORT $LN2@MAMainDisp
	mov	eax, DWORD PTR tv67[ebp]
	movzx	ecx, BYTE PTR $LN11@MAMainDisp[eax]
	jmp	DWORD PTR $LN12@MAMainDisp[ecx*4]
$LN6@MAMainDisp:

; 2685 : 		case IRP_MJ_CLEANUP:
; 2686 : 			status = STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 2687 : 			pIrp->IoStatus.Information = 0;

	mov	edx, DWORD PTR _pIrp$[ebp]
	mov	DWORD PTR [edx+28], 0

; 2688 : 			pIrp->IoStatus.Status = status;

	mov	eax, DWORD PTR _pIrp$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 2689 : 			break;

	jmp	SHORT $LN7@MAMainDisp
$LN5@MAMainDisp:

; 2690 : 		case IRP_MJ_CLOSE:
; 2691 : 			status = STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 2692 : 			pIrp->IoStatus.Information = 0;

	mov	edx, DWORD PTR _pIrp$[ebp]
	mov	DWORD PTR [edx+28], 0

; 2693 : 			pIrp->IoStatus.Status = status;

	mov	eax, DWORD PTR _pIrp$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 2694 : 			break;

	jmp	SHORT $LN7@MAMainDisp
$LN4@MAMainDisp:

; 2695 : 		case IRP_MJ_CREATE:
; 2696 : 			status = STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 2697 : 			pIrp->IoStatus.Information = 0;

	mov	edx, DWORD PTR _pIrp$[ebp]
	mov	DWORD PTR [edx+28], 0

; 2698 : 			pIrp->IoStatus.Status = status;

	mov	eax, DWORD PTR _pIrp$[ebp]
	mov	ecx, DWORD PTR _status$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 2699 : 			break;

	jmp	SHORT $LN7@MAMainDisp
$LN3@MAMainDisp:

; 2700 : 		case IRP_MJ_READ:
; 2701 : 			status = MADispatchRead(pDevObj, pIrp);

	mov	edx, DWORD PTR _pIrp$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDevObj$[ebp]
	push	eax
	call	?MADispatchRead@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ; MADispatchRead
	mov	DWORD PTR _status$[ebp], eax

; 2702 : 			break;

	jmp	SHORT $LN7@MAMainDisp
$LN2@MAMainDisp:

; 2703 : 		default:
; 2704 : 			status = STATUS_NOT_SUPPORTED;

	mov	DWORD PTR _status$[ebp], -1073741637	; c00000bbH

; 2705 : 			pIrp->IoStatus.Information = 0;

	mov	ecx, DWORD PTR _pIrp$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 2706 : 			pIrp->IoStatus.Status = status;

	mov	edx, DWORD PTR _pIrp$[ebp]
	mov	eax, DWORD PTR _status$[ebp]
	mov	DWORD PTR [edx+24], eax
$LN7@MAMainDisp:

; 2707 : 	}
; 2708 : 	if (status != STATUS_PENDING) {

	cmp	DWORD PTR _status$[ebp], 259		; 00000103H
	je	SHORT $LN1@MAMainDisp

; 2709 : 		IoCompleteRequest(
; 2710 : 			pIrp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _pIrp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 2711 : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 2712 : 			"FLT - MAMainDispatch - Client IRP %#p completed with "
; 2713 : 			"status %#010x\n", 
; 2714 : 			pIrp,
; 2715 : 			pIrp->IoStatus.Status);

	mov	ecx, DWORD PTR _pIrp$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	eax, DWORD PTR _pIrp$[ebp]
	push	eax
	push	OFFSET ??_C@_0EE@FCHCFMEI@FLT?5?9?5MAMainDispatch?5?9?5Client?5IR@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 20					; 00000014H
$LN1@MAMainDisp:

; 2716 : 	}
; 2717 : 	return status;

	mov	eax, DWORD PTR _status$[ebp]

; 2718 : }

	mov	esp, ebp
	pop	ebp
	ret	8
	npad	2
$LN12@MAMainDisp:
	DD	$LN4@MAMainDisp
	DD	$LN5@MAMainDisp
	DD	$LN3@MAMainDisp
	DD	$LN6@MAMainDisp
	DD	$LN2@MAMainDisp
$LN11@MAMainDisp:
	DB	0
	DB	4
	DB	1
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
?MAMainDispatch@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ENDP	; MAMainDispatch
_TEXT	ENDS
PUBLIC	??_C@_0CL@KFEIBEJF@FLT?5?9?5MADispatchRead?5?9?5Entered?4?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0CL@KFEIBEJF@FLT?5?9?5MADispatchRead?5?9?5Entered?4?5@FNODOBFM@
text$s	SEGMENT
??_C@_0CL@KFEIBEJF@FLT?5?9?5MADispatchRead?5?9?5Entered?4?5@FNODOBFM@ DB 'F'
	DB	'LT - MADispatchRead - Entered. pIrp = %#p', 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?MADispatchRead@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z
_TEXT	SEGMENT
_pFADevExt$26816 = -32					; size = 4
_i$26812 = -28						; size = 4
_pDevInfoLink$ = -24					; size = 4
_pMastDevExt$ = -20					; size = 4
_status$ = -16						; size = 4
_pStack$ = -12						; size = 4
_ReqBytes$ = -8						; size = 4
_pAdl$ = -4						; size = 4
_pDevObj$ = 8						; size = 4
_pIrp$ = 12						; size = 4
?MADispatchRead@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z PROC	; MADispatchRead, COMDAT

; 2572 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	esi
	push	edi

; 2573 : 	NTSTATUS status;
; 2574 : 
; 2575 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 2576 : 		"FLT - MADispatchRead - Entered. pIrp = %#p", pIrp);

	mov	eax, DWORD PTR _pIrp$[ebp]
	push	eax
	push	OFFSET ??_C@_0CL@KFEIBEJF@FLT?5?9?5MADispatchRead?5?9?5Entered?4?5@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 16					; 00000010H

; 2577 : 	PIO_STACK_LOCATION pStack;
; 2578 : 	PACCESS_DEVICES_LIST pAdl;
; 2579 : 	status = CheckMAReadParams(pIrp, pDevObj, &pStack, &pAdl);

	lea	ecx, DWORD PTR _pAdl$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pStack$[ebp]
	push	edx
	mov	eax, DWORD PTR _pDevObj$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pIrp$[ebp]
	push	ecx
	call	?CheckMAReadParams@@YGJPAU_IRP@@PAU_DEVICE_OBJECT@@PAPAU_IO_STACK_LOCATION@@PAPAU_ACCESS_DEVICES_LIST@@@Z ; CheckMAReadParams
	mov	DWORD PTR _status$[ebp], eax

; 2580 : 
; 2581 : 	if (!NT_SUCCESS(status)) return status;

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN7@MADispatch
	mov	eax, DWORD PTR _status$[ebp]
	jmp	$LN8@MADispatch
$LN7@MADispatch:

; 2582 : 
; 2583 : 	PMADEVICE_EXTENSION pMastDevExt = (PMADEVICE_EXTENSION) 
; 2584 : 		pDevObj->DeviceExtension;

	mov	edx, DWORD PTR _pDevObj$[ebp]
	mov	eax, DWORD PTR [edx+40]
	mov	DWORD PTR _pMastDevExt$[ebp], eax

; 2585 : 
; 2586 : 	// Compute the size the buffer must have to receive all the
; 2587 : 	// data.
; 2588 : 	//
; 2589 : 	ULONG ReqBytes = FIELD_OFFSET(ACCESS_DEVICES_LIST, TargDevVect) +
; 2590 : 		pMastDevExt->FADevsCount * sizeof (TARGET_DEVICE_INFO);

	mov	ecx, DWORD PTR _pMastDevExt$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	imul	edx, 1114				; 0000045aH
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _ReqBytes$[ebp], edx

; 2591 : 	if (pStack->Parameters.Read.Length < ReqBytes) {

	mov	eax, DWORD PTR _pStack$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR _ReqBytes$[ebp]
	jae	SHORT $LN6@MADispatch

; 2592 : 		pAdl->bIncomplete = TRUE;

	mov	edx, DWORD PTR _pAdl$[ebp]
	mov	BYTE PTR [edx], 1

; 2593 : 	} else {

	jmp	SHORT $LN5@MADispatch
$LN6@MADispatch:

; 2594 : 		pAdl->bIncomplete = FALSE;

	mov	eax, DWORD PTR _pAdl$[ebp]
	mov	BYTE PTR [eax], 0
$LN5@MADispatch:

; 2595 : 	}
; 2596 : 	pAdl->ReqBufSize = ReqBytes;

	mov	ecx, DWORD PTR _pAdl$[ebp]
	mov	edx, DWORD PTR _ReqBytes$[ebp]
	mov	DWORD PTR [ecx+8], edx

; 2597 : 
; 2598 : 	// Compute the # of TARGET_DEVICE_INFO that can fit into the buffer
; 2599 : 	//
; 2600 : 	pAdl->DevInfoCount = (pStack->Parameters.Read.Length -
; 2601 : 		FIELD_OFFSET(ACCESS_DEVICES_LIST, TargDevVect)) / 
; 2602 : 		sizeof (TARGET_DEVICE_INFO);

	mov	eax, DWORD PTR _pStack$[ebp]
	mov	eax, DWORD PTR [eax+4]
	sub	eax, 12					; 0000000cH
	xor	edx, edx
	mov	ecx, 1114				; 0000045aH
	div	ecx
	mov	edx, DWORD PTR _pAdl$[ebp]
	mov	DWORD PTR [edx+4], eax

; 2603 : 
; 2604 : 	// If the actual # of info struct is less, return the actual count.
; 2605 : 	//
; 2606 : 	if (pAdl->DevInfoCount > pMastDevExt->FADevsCount)

	mov	eax, DWORD PTR _pAdl$[ebp]
	mov	ecx, DWORD PTR _pMastDevExt$[ebp]
	mov	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR [ecx+20]
	jbe	SHORT $LN4@MADispatch

; 2607 : 		pAdl->DevInfoCount = pMastDevExt->FADevsCount;

	mov	eax, DWORD PTR _pAdl$[ebp]
	mov	ecx, DWORD PTR _pMastDevExt$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR [eax+4], edx
$LN4@MADispatch:

; 2608 : 
; 2609 : 	// Compute the # of bytes transferred from the # of dev info
; 2610 : 	//
; 2611 : 	pIrp->IoStatus.Information = 
; 2612 : 		FIELD_OFFSET(ACCESS_DEVICES_LIST, TargDevVect) + 
; 2613 : 		pAdl->DevInfoCount *
; 2614 : 		sizeof (TARGET_DEVICE_INFO);

	mov	eax, DWORD PTR _pAdl$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	imul	ecx, 1114				; 0000045aH
	add	ecx, 12					; 0000000cH
	mov	edx, DWORD PTR _pIrp$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 2615 : 
; 2616 : 	PLIST_ENTRY pDevInfoLink = pMastDevExt->FADevsList.Flink;

	mov	eax, DWORD PTR _pMastDevExt$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR _pDevInfoLink$[ebp], ecx

; 2617 : 
; 2618 : 	// Copy only the TARGET_DEVICE_INFOs that fit.
; 2619 : 	//
; 2620 : 	for (ULONG i = 0; i < pAdl->DevInfoCount; i++) {

	mov	DWORD PTR _i$26812[ebp], 0
	jmp	SHORT $LN3@MADispatch
$LN2@MADispatch:
	mov	edx, DWORD PTR _i$26812[ebp]
	add	edx, 1
	mov	DWORD PTR _i$26812[ebp], edx
$LN3@MADispatch:
	mov	eax, DWORD PTR _pAdl$[ebp]
	mov	ecx, DWORD PTR _i$26812[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN1@MADispatch

; 2621 : 		PFADEVICE_EXTENSION pFADevExt =
; 2622 : 			CONTAINING_RECORD(pDevInfoLink, FADEVICE_EXTENSION,
; 2623 : 				ListEntry);

	mov	edx, DWORD PTR _pDevInfoLink$[ebp]
	sub	edx, 1128				; 00000468H
	mov	DWORD PTR _pFADevExt$26816[ebp], edx

; 2624 : 		pAdl->TargDevVect[i] = pFADevExt->TargDevInfo;

	mov	esi, DWORD PTR _pFADevExt$26816[ebp]
	add	esi, 12					; 0000000cH
	mov	eax, DWORD PTR _i$26812[ebp]
	imul	eax, 1114				; 0000045aH
	mov	ecx, DWORD PTR _pAdl$[ebp]
	lea	edi, DWORD PTR [ecx+eax+12]
	mov	ecx, 278				; 00000116H
	rep movsd
	movsw

; 2625 : 		pDevInfoLink = pDevInfoLink->Flink;

	mov	edx, DWORD PTR _pDevInfoLink$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _pDevInfoLink$[ebp], eax

; 2626 : 	}

	jmp	SHORT $LN2@MADispatch
$LN1@MADispatch:

; 2627 : 	pIrp->IoStatus.Status = STATUS_SUCCESS;

	mov	ecx, DWORD PTR _pIrp$[ebp]
	mov	DWORD PTR [ecx+24], 0

; 2628 : 	return STATUS_SUCCESS;

	xor	eax, eax
$LN8@MADispatch:

; 2629 : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?MADispatchRead@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ENDP	; MADispatchRead
_TEXT	ENDS
PUBLIC	??_C@_0GD@DEPIDMO@FLT?5?9?5CheckMAReadPArams?5?9?5Client@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0FG@NEABJAHD@FLT?5?9?5CheckMAReadPArams?5?9?5Client@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0GD@DEPIDMO@FLT?5?9?5CheckMAReadPArams?5?9?5Client@FNODOBFM@
text$s	SEGMENT
??_C@_0GD@DEPIDMO@FLT?5?9?5CheckMAReadPArams?5?9?5Client@FNODOBFM@ DB 'FL'
	DB	'T - CheckMAReadPArams - Client buffer not aligned; required a'
	DB	'lignment: %#x, buffer address: %#p', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0FG@NEABJAHD@FLT?5?9?5CheckMAReadPArams?5?9?5Client@FNODOBFM@
text$s	SEGMENT
??_C@_0FG@NEABJAHD@FLT?5?9?5CheckMAReadPArams?5?9?5Client@FNODOBFM@ DB 'F'
	DB	'LT - CheckMAReadPArams - Client buffer too small; minimum req'
	DB	'uired: %d, current: %d', 0aH, 00H		;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?CheckMAReadParams@@YGJPAU_IRP@@PAU_DEVICE_OBJECT@@PAPAU_IO_STACK_LOCATION@@PAPAU_ACCESS_DEVICES_LIST@@@Z
_TEXT	SEGMENT
_status$ = -12						; size = 4
_pStack$ = -8						; size = 4
_pAdl$ = -4						; size = 4
_pIrp$ = 8						; size = 4
_pDevObj$ = 12						; size = 4
_ppStack$ = 16						; size = 4
_ppAdl$ = 20						; size = 4
?CheckMAReadParams@@YGJPAU_IRP@@PAU_DEVICE_OBJECT@@PAPAU_IO_STACK_LOCATION@@PAPAU_ACCESS_DEVICES_LIST@@@Z PROC ; CheckMAReadParams, COMDAT

; 755  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 756  : 	PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);

	mov	eax, DWORD PTR _pIrp$[ebp]
	push	eax
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _pStack$[ebp], eax

; 757  : 	*ppStack = pStack;

	mov	ecx, DWORD PTR _ppStack$[ebp]
	mov	edx, DWORD PTR _pStack$[ebp]
	mov	DWORD PTR [ecx], edx

; 758  : 	if (pStack->Parameters.Read.Length < 
; 759  : 		FIELD_OFFSET(ACCESS_DEVICES_LIST, TargDevVect)) {

	mov	eax, DWORD PTR _pStack$[ebp]
	cmp	DWORD PTR [eax+4], 12			; 0000000cH
	jae	SHORT $LN3@CheckMARea

; 760  : 			DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 761  : 				"FLT - CheckMAReadPArams - Client buffer too small; "
; 762  : 				"minimum required: %d, current: %d\n",
; 763  : 				FIELD_OFFSET(ACCESS_DEVICES_LIST, TargDevVect),
; 764  : 				pStack->Parameters.Read.Length);

	mov	ecx, DWORD PTR _pStack$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	12					; 0000000cH
	push	OFFSET ??_C@_0FG@NEABJAHD@FLT?5?9?5CheckMAReadPArams?5?9?5Client@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 20					; 00000014H

; 765  : 		return STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; c000000dH
	jmp	SHORT $LN4@CheckMARea
$LN3@CheckMARea:

; 766  : 	}
; 767  : 
; 768  : 	PACCESS_DEVICES_LIST pAdl;
; 769  : 	NTSTATUS status = GetRWIrpBuffer(pIrp, pDevObj, (PVOID *) &pAdl);

	lea	eax, DWORD PTR _pAdl$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pDevObj$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pIrp$[ebp]
	push	edx
	call	?GetRWIrpBuffer@@YGJPAU_IRP@@PAU_DEVICE_OBJECT@@PAPAX@Z ; GetRWIrpBuffer
	mov	DWORD PTR _status$[ebp], eax

; 770  : 	if (!NT_SUCCESS(status)) return status;

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN2@CheckMARea
	mov	eax, DWORD PTR _status$[ebp]
	jmp	SHORT $LN4@CheckMARea
$LN2@CheckMARea:

; 771  : 	*ppAdl = pAdl;

	mov	eax, DWORD PTR _ppAdl$[ebp]
	mov	ecx, DWORD PTR _pAdl$[ebp]
	mov	DWORD PTR [eax], ecx

; 772  : 
; 773  : 	// Check that the buffer is properly aligned for the structure we
; 774  : 	// will return
; 775  : 	//
; 776  : 	if ((ULONG_PTR) pAdl &
; 777  : 		(TYPE_ALIGNMENT(ACCESS_DEVICES_LIST) - 1)) {

	mov	edx, DWORD PTR _pAdl$[ebp]
	and	edx, 3
	je	SHORT $LN1@CheckMARea

; 778  : 			DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 779  : 				"FLT - CheckMAReadPArams - Client buffer not aligned; "
; 780  : 				"required alignment: %#x, buffer address: %#p\n",
; 781  : 				TYPE_ALIGNMENT(ACCESS_DEVICES_LIST),
; 782  : 				pAdl);

	mov	eax, DWORD PTR _pAdl$[ebp]
	push	eax
	push	4
	push	OFFSET ??_C@_0GD@DEPIDMO@FLT?5?9?5CheckMAReadPArams?5?9?5Client@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 20					; 00000014H

; 783  : 		return STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; c000000dH
	jmp	SHORT $LN4@CheckMARea
$LN1@CheckMARea:

; 784  : 	}
; 785  : 	return STATUS_SUCCESS;

	xor	eax, eax
$LN4@CheckMARea:

; 786  : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?CheckMAReadParams@@YGJPAU_IRP@@PAU_DEVICE_OBJECT@@PAPAU_IO_STACK_LOCATION@@PAPAU_ACCESS_DEVICES_LIST@@@Z ENDP ; CheckMAReadParams
_TEXT	ENDS
PUBLIC	??_C@_0EF@BMIAKKGE@FLT?5?9?5GetRWIrpBuffer?5?9?5MmGetSyst@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0EF@BMIAKKGE@FLT?5?9?5GetRWIrpBuffer?5?9?5MmGetSyst@FNODOBFM@
text$s	SEGMENT
??_C@_0EF@BMIAKKGE@FLT?5?9?5GetRWIrpBuffer?5?9?5MmGetSyst@FNODOBFM@ DB 'F'
	DB	'LT - GetRWIrpBuffer - MmGetSystemAddressForMdlSafe() returned'
	DB	' NULL', 0aH, 00H				;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?GetRWIrpBuffer@@YGJPAU_IRP@@PAU_DEVICE_OBJECT@@PAPAX@Z
_TEXT	SEGMENT
tv85 = -8						; size = 4
_pMdl$26592 = -4					; size = 4
_pIrp$ = 8						; size = 4
_pDevObj$ = 12						; size = 4
_ppBuffer$ = 16						; size = 4
?GetRWIrpBuffer@@YGJPAU_IRP@@PAU_DEVICE_OBJECT@@PAPAX@Z PROC ; GetRWIrpBuffer, COMDAT

; 1857 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1858 : 	if (pDevObj->Flags & DO_BUFFERED_IO) {

	mov	eax, DWORD PTR _pDevObj$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	and	ecx, 4
	je	SHORT $LN5@GetRWIrpBu

; 1859 : 		*ppBuffer = pIrp->AssociatedIrp.SystemBuffer;

	mov	edx, DWORD PTR _ppBuffer$[ebp]
	mov	eax, DWORD PTR _pIrp$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx], ecx

; 1860 : 		return STATUS_SUCCESS;

	xor	eax, eax
	jmp	SHORT $LN6@GetRWIrpBu
	jmp	SHORT $LN6@GetRWIrpBu
$LN5@GetRWIrpBu:

; 1861 : 	} else if (pDevObj->Flags & DO_DIRECT_IO) {

	mov	edx, DWORD PTR _pDevObj$[ebp]
	mov	eax, DWORD PTR [edx+28]
	and	eax, 16					; 00000010H
	je	SHORT $LN3@GetRWIrpBu

; 1862 : 		PMDL pMdl = pIrp->MdlAddress;

	mov	ecx, DWORD PTR _pIrp$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _pMdl$26592[ebp], edx

; 1863 : 		*ppBuffer = 
; 1864 : 			MmGetSystemAddressForMdlSafe(pMdl, LowPagePriority);

	mov	eax, DWORD PTR _pMdl$26592[ebp]
	movsx	ecx, WORD PTR [eax+6]
	and	ecx, 5
	je	SHORT $LN8@GetRWIrpBu
	mov	edx, DWORD PTR _pMdl$26592[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv85[ebp], eax
	jmp	SHORT $LN9@GetRWIrpBu
$LN8@GetRWIrpBu:
	push	0
	push	0
	push	0
	push	1
	push	0
	mov	ecx, DWORD PTR _pMdl$26592[ebp]
	push	ecx
	call	DWORD PTR __imp__MmMapLockedPagesSpecifyCache@24
	mov	DWORD PTR tv85[ebp], eax
$LN9@GetRWIrpBu:
	mov	edx, DWORD PTR _ppBuffer$[ebp]
	mov	eax, DWORD PTR tv85[ebp]
	mov	DWORD PTR [edx], eax

; 1865 : 		if (*ppBuffer == NULL) {

	mov	ecx, DWORD PTR _ppBuffer$[ebp]
	cmp	DWORD PTR [ecx], 0
	jne	SHORT $LN2@GetRWIrpBu

; 1866 : 			DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1867 : 				"FLT - GetRWIrpBuffer - "
; 1868 : 				"MmGetSystemAddressForMdlSafe() returned NULL\n");

	push	OFFSET ??_C@_0EF@BMIAKKGE@FLT?5?9?5GetRWIrpBuffer?5?9?5MmGetSyst@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 12					; 0000000cH

; 1869 : 			return STATUS_NO_MEMORY;

	mov	eax, -1073741801			; c0000017H
	jmp	SHORT $LN6@GetRWIrpBu
$LN2@GetRWIrpBu:

; 1870 : 		}
; 1871 : 		return STATUS_SUCCESS;

	xor	eax, eax
	jmp	SHORT $LN6@GetRWIrpBu

; 1872 : 	} else {

	jmp	SHORT $LN6@GetRWIrpBu
$LN3@GetRWIrpBu:

; 1873 : 		return STATUS_INVALID_PARAMETER;

	mov	eax, -1073741811			; c000000dH
$LN6@GetRWIrpBu:

; 1874 : 	}
; 1875 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?GetRWIrpBuffer@@YGJPAU_IRP@@PAU_DEVICE_OBJECT@@PAPAX@Z ENDP ; GetRWIrpBuffer
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?QueueCltIrp@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
_TEXT	SEGMENT
_pDevExt$ = 8						; size = 4
_pCltIrp$ = 12						; size = 4
?QueueCltIrp@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z PROC	; QueueCltIrp, COMDAT

; 2982 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2983 : 	IoSetCancelRoutine(pCltIrp, FACancel);

	mov	eax, OFFSET ?FACancel@@YGXPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ; FACancel
	mov	ecx, DWORD PTR _pCltIrp$[ebp]
	add	ecx, 56					; 00000038H
	xchg	DWORD PTR [ecx], eax

; 2984 : 	IoMarkIrpPending(pCltIrp);

	mov	edx, DWORD PTR _pCltIrp$[ebp]
	push	edx
	call	_IoMarkIrpPending@4

; 2985 : 	InsertTailList(
; 2986 : 		&pDevExt->pIrpList,
; 2987 : 		&pCltIrp->Tail.Overlay.ListEntry);

	mov	eax, DWORD PTR _pCltIrp$[ebp]
	add	eax, 88					; 00000058H
	push	eax
	mov	ecx, DWORD PTR _pDevExt$[ebp]
	add	ecx, 196				; 000000c4H
	push	ecx
	call	_InsertTailList@8

; 2988 : 
; 2989 : 	// Abount cancellation: this function is called inside the dispatch
; 2990 : 	// routine, therefore phase 1 cannot begin while inside of it,
; 2991 : 	// because it doesn't begin until the dispatch routine returns.
; 2992 : 	//
; 2993 : 	// We can therefore be sure that, if cancellation does occur, this
; 2994 : 	// happens only after we have set up our cancel routine
; 2995 : 	//
; 2996 : 	return STATUS_PENDING;

	mov	eax, 259				; 00000103H

; 2997 : }

	pop	ebp
	ret	8
?QueueCltIrp@@YGJPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z ENDP	; QueueCltIrp
_TEXT	ENDS
PUBLIC	??_C@_0CL@DMKAKDEG@FLT?5?9?5FACancel?5?9?5Client?5IRP?5?$CF?$CDp?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	_RemoveEntryList@4
PUBLIC	??_C@_0CE@KKGIALML@FLT?5?9?5FACancel?5?9?5Entering?0?5IRP?5?$CF@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp__IoReleaseCancelSpinLock@4:PROC
;	COMDAT ??_C@_0CL@DMKAKDEG@FLT?5?9?5FACancel?5?9?5Client?5IRP?5?$CF?$CDp?5@FNODOBFM@
text$s	SEGMENT
??_C@_0CL@DMKAKDEG@FLT?5?9?5FACancel?5?9?5Client?5IRP?5?$CF?$CDp?5@FNODOBFM@ DB 'F'
	DB	'LT - FACancel - Client IRP %#p cancelled', 0aH, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0CE@KKGIALML@FLT?5?9?5FACancel?5?9?5Entering?0?5IRP?5?$CF@FNODOBFM@
text$s	SEGMENT
??_C@_0CE@KKGIALML@FLT?5?9?5FACancel?5?9?5Entering?0?5IRP?5?$CF@FNODOBFM@ DB 'F'
	DB	'LT - FACancel - Entering, IRP %#p', 0aH, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?FACancel@@YGXPAU_DEVICE_OBJECT@@PAU_IRP@@@Z
_TEXT	SEGMENT
_LockHandle$ = -28					; size = 12
_pFaDevExt$ = -16					; size = 4
_pCurrItem$ = -12					; size = 4
_pCurIrp$ = -8						; size = 4
_pFltDevExt$ = -4					; size = 4
_pDevObj$ = 8						; size = 4
_pIrp$ = 12						; size = 4
?FACancel@@YGXPAU_DEVICE_OBJECT@@PAU_IRP@@@Z PROC	; FACancel, COMDAT

; 1442 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 1443 : 	IoReleaseCancelSpinLock(pIrp->CancelIrql);

	mov	eax, DWORD PTR _pIrp$[ebp]
	movzx	ecx, BYTE PTR [eax+37]
	push	ecx
	call	DWORD PTR __imp__IoReleaseCancelSpinLock@4

; 1444 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1445 : 		"FLT - FACancel - Entering, IRP %#p\n", pIrp);

	mov	edx, DWORD PTR _pIrp$[ebp]
	push	edx
	push	OFFSET ??_C@_0CE@KKGIALML@FLT?5?9?5FACancel?5?9?5Entering?0?5IRP?5?$CF@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 16					; 00000010H

; 1446 : 	PFADEVICE_EXTENSION pFaDevExt = 
; 1447 : 		(PFADEVICE_EXTENSION) pDevObj->DeviceExtension;

	mov	eax, DWORD PTR _pDevObj$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _pFaDevExt$[ebp], ecx

; 1448 : 
; 1449 : 	// Get the filter device extension.
; 1450 : 	//
; 1451 : 	PDEVICE_EXTENSION pFltDevExt = pFaDevExt->pFilterDevExt;

	mov	edx, DWORD PTR _pFaDevExt$[ebp]
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR _pFltDevExt$[ebp], eax

; 1452 : 
; 1453 : 	// Look for an IRP to cancel into the internal queue.
; 1454 : 	//
; 1455 : 	KLOCK_QUEUE_HANDLE LockHandle;
; 1456 : 	KeAcquireInStackQueuedSpinLock(&pFltDevExt->DataLock, &LockHandle);

	mov	ecx, DWORD PTR _pFltDevExt$[ebp]
	add	ecx, 68					; 00000044H
	lea	edx, DWORD PTR _LockHandle$[ebp]
	call	DWORD PTR __imp_@KeAcquireInStackQueuedSpinLock@8

; 1457 : 	PLIST_ENTRY pCurrItem;
; 1458 : 	PIRP pCurIrp = NULL;

	mov	DWORD PTR _pCurIrp$[ebp], 0

; 1459 : 	for (
; 1460 : 		pCurrItem = pFltDevExt->pIrpList.Flink; 

	mov	ecx, DWORD PTR _pFltDevExt$[ebp]
	mov	edx, DWORD PTR [ecx+196]
	mov	DWORD PTR _pCurrItem$[ebp], edx

; 1461 : 		pCurrItem != &pFltDevExt->pIrpList;

	jmp	SHORT $LN5@FACancel
$LN4@FACancel:

; 1462 : 		pCurrItem = pCurrItem->Flink) {

	mov	eax, DWORD PTR _pCurrItem$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _pCurrItem$[ebp], ecx
$LN5@FACancel:
	mov	edx, DWORD PTR _pFltDevExt$[ebp]
	add	edx, 196				; 000000c4H
	cmp	DWORD PTR _pCurrItem$[ebp], edx
	je	SHORT $LN3@FACancel

; 1463 : 
; 1464 : 		pCurIrp = CONTAINING_RECORD(pCurrItem, IRP,
; 1465 : 			Tail.Overlay.ListEntry);

	mov	eax, DWORD PTR _pCurrItem$[ebp]
	sub	eax, 88					; 00000058H
	mov	DWORD PTR _pCurIrp$[ebp], eax

; 1466 : 		if (pCurIrp->Cancel) {

	mov	ecx, DWORD PTR _pCurIrp$[ebp]
	movzx	edx, BYTE PTR [ecx+36]
	test	edx, edx
	je	SHORT $LN2@FACancel

; 1467 : 			RemoveEntryList(pCurrItem);

	mov	eax, DWORD PTR _pCurrItem$[ebp]
	push	eax
	call	_RemoveEntryList@4

; 1468 : 			break;

	jmp	SHORT $LN3@FACancel
$LN2@FACancel:

; 1469 : 		}
; 1470 : 		pCurIrp = NULL;

	mov	DWORD PTR _pCurIrp$[ebp], 0

; 1471 : 	}

	jmp	SHORT $LN4@FACancel
$LN3@FACancel:

; 1472 : 	KeReleaseInStackQueuedSpinLock(&LockHandle);

	lea	ecx, DWORD PTR _LockHandle$[ebp]
	call	DWORD PTR __imp_@KeReleaseInStackQueuedSpinLock@4

; 1473 : 	if (pCurIrp != NULL) {

	cmp	DWORD PTR _pCurIrp$[ebp], 0
	je	SHORT $LN6@FACancel

; 1474 : 		pCurIrp->IoStatus.Status = STATUS_CANCELLED;

	mov	ecx, DWORD PTR _pCurIrp$[ebp]
	mov	DWORD PTR [ecx+24], -1073741536		; c0000120H

; 1475 : 		pCurIrp->IoStatus.Information = 0;

	mov	edx, DWORD PTR _pCurIrp$[ebp]
	mov	DWORD PTR [edx+28], 0

; 1476 : 		IoCompleteRequest(pCurIrp, IO_NO_INCREMENT);

	xor	dl, dl
	mov	ecx, DWORD PTR _pCurIrp$[ebp]
	call	DWORD PTR __imp_@IofCompleteRequest@8

; 1477 : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1478 : 			"FLT - FACancel - Client IRP %#p cancelled\n", 
; 1479 : 			pCurIrp);

	mov	eax, DWORD PTR _pCurIrp$[ebp]
	push	eax
	push	OFFSET ??_C@_0CL@DMKAKDEG@FLT?5?9?5FACancel?5?9?5Client?5IRP?5?$CF?$CDp?5@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 16					; 00000010H
$LN6@FACancel:

; 1480 : 	}
; 1481 : 	return;
; 1482 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?FACancel@@YGXPAU_DEVICE_OBJECT@@PAU_IRP@@@Z ENDP	; FACancel
; Function compile flags: /Odtp
; File c:\apps\pw7hp\devpgm\msddk\inc\ddk\wdm.h
_TEXT	ENDS
;	COMDAT _RemoveEntryList@4
_TEXT	SEGMENT
_Blink$ = -8						; size = 4
_Flink$ = -4						; size = 4
_Entry$ = 8						; size = 4
_RemoveEntryList@4 PROC					; COMDAT

; 7569 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 7570 :     PLIST_ENTRY Blink;
; 7571 :     PLIST_ENTRY Flink;
; 7572 : 
; 7573 :     Flink = Entry->Flink;

	mov	eax, DWORD PTR _Entry$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _Flink$[ebp], ecx

; 7574 :     Blink = Entry->Blink;

	mov	edx, DWORD PTR _Entry$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _Blink$[ebp], eax

; 7575 :     Blink->Flink = Flink;

	mov	ecx, DWORD PTR _Blink$[ebp]
	mov	edx, DWORD PTR _Flink$[ebp]
	mov	DWORD PTR [ecx], edx

; 7576 :     Flink->Blink = Blink;

	mov	eax, DWORD PTR _Flink$[ebp]
	mov	ecx, DWORD PTR _Blink$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 7577 :     return (BOOLEAN)(Flink == Blink);

	mov	edx, DWORD PTR _Flink$[ebp]
	cmp	edx, DWORD PTR _Blink$[ebp]
	sete	al

; 7578 : }

	mov	esp, ebp
	pop	ebp
	ret	4
_RemoveEntryList@4 ENDP
_TEXT	ENDS
PUBLIC	??_C@_0P@HGOAEHOJ@ReadCompletion?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0P@HGOAEHOJ@ReadCompletion?$AA@FNODOBFM@
; File b:\programm\wntsys\testfilter\release\1_1\source\driver\drvmain.cpp
text$s	SEGMENT
??_C@_0P@HGOAEHOJ@ReadCompletion?$AA@FNODOBFM@ DB 'ReadCompletion', 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?ReadCompletion@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@PAX@Z
_TEXT	SEGMENT
_pReadData$26923 = -24					; size = 4
_LockHandle$26925 = -20					; size = 12
_cbReadDataLen$26924 = -8				; size = 4
_pDevExt$ = -4						; size = 4
_pDevObj$ = 8						; size = 4
_pIrp$ = 12						; size = 4
_pContext$ = 16						; size = 4
?ReadCompletion@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@PAX@Z PROC ; ReadCompletion, COMDAT

; 3063 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 3064 : 	PDEVICE_EXTENSION pDevExt = 
; 3065 : 		(PDEVICE_EXTENSION) pDevObj->DeviceExtension;

	mov	eax, DWORD PTR _pDevObj$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR _pDevExt$[ebp], ecx

; 3066 : 
; 3067 : 	if (pDevExt->dwMJFlags[IRP_MJ_READ] & FCTL_TRACE_ON) {

	mov	edx, DWORD PTR _pDevExt$[ebp]
	mov	eax, DWORD PTR [edx+88]
	and	eax, 1
	je	SHORT $LN2@ReadComple

; 3068 : 		TraceIrpBasicInfo(pDevExt, "ReadCompletion", pIrp);

	mov	ecx, DWORD PTR _pIrp$[ebp]
	push	ecx
	push	OFFSET ??_C@_0P@HGOAEHOJ@ReadCompletion?$AA@FNODOBFM@
	mov	edx, DWORD PTR _pDevExt$[ebp]
	push	edx
	call	?TraceIrpBasicInfo@@YGXPAU_DEVICE_EXTENSION@@PADPAU_IRP@@@Z ; TraceIrpBasicInfo

; 3069 : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 3070 : 			"\tStatus = %#010x\n"
; 3071 : 			"\tInformation = %#x\n",
; 3072 : 			pIrp->IoStatus.Status,
; 3073 : 			pIrp->IoStatus.Information);

	mov	eax, DWORD PTR _pIrp$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	push	ecx
	mov	edx, DWORD PTR _pIrp$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	push	OFFSET ??_C@_0CF@GHKHGNKG@?7Status?5?$DN?5?$CF?$CD010x?6?7Information?5?$DN?5@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 20					; 00000014H

; 3074 : 
; 3075 : 		// Get the IRP data, if any.
; 3076 : 		//
; 3077 : 		PVOID pReadData;
; 3078 : 		SIZE_T cbReadDataLen;
; 3079 : 		GetReadData(pIrp, pDevExt, &pReadData, &cbReadDataLen);

	lea	ecx, DWORD PTR _cbReadDataLen$26924[ebp]
	push	ecx
	lea	edx, DWORD PTR _pReadData$26923[ebp]
	push	edx
	mov	eax, DWORD PTR _pDevExt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pIrp$[ebp]
	push	ecx
	call	?GetReadData@@YGXPAU_IRP@@PAU_DEVICE_EXTENSION@@PAPAXPAK@Z ; GetReadData

; 3080 : 
; 3081 : 		KLOCK_QUEUE_HANDLE	LockHandle;
; 3082 : 		KeAcquireInStackQueuedSpinLock(
; 3083 : 			&pDevExt->DataLock,
; 3084 : 			&LockHandle);

	mov	ecx, DWORD PTR _pDevExt$[ebp]
	add	ecx, 68					; 00000044H
	lea	edx, DWORD PTR _LockHandle$26925[ebp]
	call	DWORD PTR __imp_@KeAcquireInStackQueuedSpinLock@8

; 3085 : 		InterceptIrpAndData(pIrp, pReadData, cbReadDataLen, pDevExt);

	mov	edx, DWORD PTR _pDevExt$[ebp]
	push	edx
	mov	eax, DWORD PTR _cbReadDataLen$26924[ebp]
	push	eax
	mov	ecx, DWORD PTR _pReadData$26923[ebp]
	push	ecx
	mov	edx, DWORD PTR _pIrp$[ebp]
	push	edx
	call	?InterceptIrpAndData@@YGXPAU_IRP@@PAXKPAU_DEVICE_EXTENSION@@@Z ; InterceptIrpAndData

; 3086 : 		SendIrpDataToClt(pDevExt);

	mov	eax, DWORD PTR _pDevExt$[ebp]
	push	eax
	call	?SendIrpDataToClt@@YGXPAU_DEVICE_EXTENSION@@@Z ; SendIrpDataToClt

; 3087 : 		KeReleaseInStackQueuedSpinLock(&LockHandle);

	lea	ecx, DWORD PTR _LockHandle$26925[ebp]
	call	DWORD PTR __imp_@KeReleaseInStackQueuedSpinLock@4
$LN2@ReadComple:

; 3088 : 	}
; 3089 : 
; 3090 : 	if (pIrp->PendingReturned) IoMarkIrpPending(pIrp);

	mov	ecx, DWORD PTR _pIrp$[ebp]
	movzx	edx, BYTE PTR [ecx+33]
	test	edx, edx
	je	SHORT $LN1@ReadComple
	mov	eax, DWORD PTR _pIrp$[ebp]
	push	eax
	call	_IoMarkIrpPending@4
$LN1@ReadComple:

; 3091 : 	return STATUS_SUCCESS;

	xor	eax, eax

; 3092 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?ReadCompletion@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@PAX@Z ENDP ; ReadCompletion
_TEXT	ENDS
PUBLIC	??_C@_0DJ@OOGMKJA@FLT?5?9?5GetReadData?5?9?5Read?5data?5ad@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
;	COMDAT ??_C@_0DJ@OOGMKJA@FLT?5?9?5GetReadData?5?9?5Read?5data?5ad@FNODOBFM@
text$s	SEGMENT
??_C@_0DJ@OOGMKJA@FLT?5?9?5GetReadData?5?9?5Read?5data?5ad@FNODOBFM@ DB 'F'
	DB	'LT - GetReadData - Read data address: %#p, length: %#x', 0aH, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?GetReadData@@YGXPAU_IRP@@PAU_DEVICE_EXTENSION@@PAPAXPAK@Z
_TEXT	SEGMENT
tv87 = -12						; size = 4
_pBufStart$26577 = -8					; size = 4
_pMdl$26576 = -4					; size = 4
_pReadIrp$ = 8						; size = 4
_pDevExt$ = 12						; size = 4
_ppReadData$ = 16					; size = 4
_pcbDataLen$ = 20					; size = 4
?GetReadData@@YGXPAU_IRP@@PAU_DEVICE_EXTENSION@@PAPAXPAK@Z PROC ; GetReadData, COMDAT

; 1792 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 1793 : 	*ppReadData = NULL;

	mov	eax, DWORD PTR _ppReadData$[ebp]
	mov	DWORD PTR [eax], 0

; 1794 : 	*pcbDataLen = 0;

	mov	ecx, DWORD PTR _pcbDataLen$[ebp]
	mov	DWORD PTR [ecx], 0

; 1795 : 
; 1796 : 	if (!NT_SUCCESS(pReadIrp->IoStatus.Status)) return;

	mov	edx, DWORD PTR _pReadIrp$[ebp]
	cmp	DWORD PTR [edx+24], 0
	jge	SHORT $LN6@GetReadDat
	jmp	$LN7@GetReadDat
$LN6@GetReadDat:

; 1797 : 	*pcbDataLen = pReadIrp->IoStatus.Information;

	mov	eax, DWORD PTR _pcbDataLen$[ebp]
	mov	ecx, DWORD PTR _pReadIrp$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax], edx

; 1798 : 	if (!*pcbDataLen) return;

	mov	eax, DWORD PTR _pcbDataLen$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@GetReadDat
	jmp	$LN7@GetReadDat
$LN5@GetReadDat:

; 1799 : 
; 1800 : 	// Determine the buffering mode
; 1801 : 	//
; 1802 : 	if (pDevExt->hdr.pDevice->Flags & DO_DIRECT_IO) {

	mov	ecx, DWORD PTR _pDevExt$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [edx+28]
	and	eax, 16					; 00000010H
	je	SHORT $LN4@GetReadDat

; 1803 : 
; 1804 : 		PMDL pMdl = pReadIrp->MdlAddress;

	mov	ecx, DWORD PTR _pReadIrp$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _pMdl$26576[ebp], edx

; 1805 : 		PCHAR pBufStart = (PCHAR) MmGetSystemAddressForMdlSafe(pMdl, 
; 1806 : 				LowPagePriority);

	mov	eax, DWORD PTR _pMdl$26576[ebp]
	movsx	ecx, WORD PTR [eax+6]
	and	ecx, 5
	je	SHORT $LN9@GetReadDat
	mov	edx, DWORD PTR _pMdl$26576[ebp]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR tv87[ebp], eax
	jmp	SHORT $LN10@GetReadDat
$LN9@GetReadDat:
	push	0
	push	0
	push	0
	push	1
	push	0
	mov	ecx, DWORD PTR _pMdl$26576[ebp]
	push	ecx
	call	DWORD PTR __imp__MmMapLockedPagesSpecifyCache@24
	mov	DWORD PTR tv87[ebp], eax
$LN10@GetReadDat:
	mov	edx, DWORD PTR tv87[ebp]
	mov	DWORD PTR _pBufStart$26577[ebp], edx

; 1807 : 		if (pBufStart != NULL) {

	cmp	DWORD PTR _pBufStart$26577[ebp], 0
	je	SHORT $LN3@GetReadDat

; 1808 : 			*ppReadData = pBufStart;

	mov	eax, DWORD PTR _ppReadData$[ebp]
	mov	ecx, DWORD PTR _pBufStart$26577[ebp]
	mov	DWORD PTR [eax], ecx

; 1809 : 		} else {

	jmp	SHORT $LN2@GetReadDat
$LN3@GetReadDat:

; 1810 : 
; 1811 : 			// This should never happen, because the client buffer
; 1812 : 			// has already been locked in place by who issued the
; 1813 : 			// read IRP.
; 1814 : 			//
; 1815 : 			*pcbDataLen = 0;

	mov	edx, DWORD PTR _pcbDataLen$[ebp]
	mov	DWORD PTR [edx], 0
$LN2@GetReadDat:

; 1816 : 		}
; 1817 : 	} else {

	jmp	SHORT $LN1@GetReadDat
$LN4@GetReadDat:

; 1818 : 
; 1819 : 		// Buffered I/O
; 1820 : 		//
; 1821 : 		*ppReadData = pReadIrp->AssociatedIrp.SystemBuffer;

	mov	eax, DWORD PTR _ppReadData$[ebp]
	mov	ecx, DWORD PTR _pReadIrp$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR [eax], edx
$LN1@GetReadDat:

; 1822 : 	}
; 1823 : 
; 1824 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 1825 : 		"FLT - GetReadData - Read data address: %#p, length: %#x\n",
; 1826 : 		*ppReadData, *pcbDataLen);

	mov	eax, DWORD PTR _pcbDataLen$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _ppReadData$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	push	OFFSET ??_C@_0DJ@OOGMKJA@FLT?5?9?5GetReadData?5?9?5Read?5data?5ad@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 20					; 00000014H
$LN7@GetReadDat:

; 1827 : 
; 1828 : 	return;
; 1829 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?GetReadData@@YGXPAU_IRP@@PAU_DEVICE_EXTENSION@@PAPAXPAK@Z ENDP ; GetReadData
_TEXT	ENDS
PUBLIC	??_C@_0DC@JPOPAAME@FLT?5?9?5SendIrpDataToClt?5?9?5Client?5@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	?CBDataBufferEmpty@@YGEPAU_CIRCULAR_BUFFER@@@Z:PROC ; CBDataBufferEmpty
;	COMDAT ??_C@_0DC@JPOPAAME@FLT?5?9?5SendIrpDataToClt?5?9?5Client?5@FNODOBFM@
text$s	SEGMENT
??_C@_0DC@JPOPAAME@FLT?5?9?5SendIrpDataToClt?5?9?5Client?5@FNODOBFM@ DB 'F'
	DB	'LT - SendIrpDataToClt - Client IRP %#p dequeued', 0aH, 00H ;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?SendIrpDataToClt@@YGXPAU_DEVICE_EXTENSION@@@Z
_TEXT	SEGMENT
_pFirst$26936 = -12					; size = 4
_pClientIrp$26937 = -8					; size = 4
_pIrpList$ = -4						; size = 4
_pDevExt$ = 8						; size = 4
?SendIrpDataToClt@@YGXPAU_DEVICE_EXTENSION@@@Z PROC	; SendIrpDataToClt, COMDAT

; 3115 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 3116 : 	PLIST_ENTRY pIrpList = &pDevExt->pIrpList;

	mov	eax, DWORD PTR _pDevExt$[ebp]
	add	eax, 196				; 000000c4H
	mov	DWORD PTR _pIrpList$[ebp], eax
$LN3@SendIrpDat:

; 3117 : 
; 3118 : 	// Pass the intercepted IRPs and their data to any
; 3119 : 	// waiting client IRP.
; 3120 : 	//
; 3121 : 	while (!IsListEmpty(pIrpList)) {

	mov	ecx, DWORD PTR _pIrpList$[ebp]
	push	ecx
	call	_IsListEmpty@4
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN4@SendIrpDat

; 3122 : 		if (CBDataBufferEmpty(&pDevExt->DataBuffer)) break;

	mov	eax, DWORD PTR _pDevExt$[ebp]
	add	eax, 40					; 00000028H
	push	eax
	call	?CBDataBufferEmpty@@YGEPAU_CIRCULAR_BUFFER@@@Z ; CBDataBufferEmpty
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@SendIrpDat
	jmp	SHORT $LN4@SendIrpDat
$LN1@SendIrpDat:

; 3123 : 		PLIST_ENTRY pFirst = RemoveHeadList(pIrpList);

	mov	edx, DWORD PTR _pIrpList$[ebp]
	push	edx
	call	_RemoveHeadList@4
	mov	DWORD PTR _pFirst$26936[ebp], eax

; 3124 : 
; 3125 : 		// About IRP cancellation: we are removing the IRP from the
; 3126 : 		// queue, so, should the I/O manager cancel it, the cancel 
; 3127 : 		// routine will not process it.
; 3128 : 		//
; 3129 : 		// This is OK, because from now on, the IRP will not be held
; 3130 : 		// into a queue waiting for something (namely, the presence
; 3131 : 		// of intercepted data). It will instead, be completed. So,
; 3132 : 		// we are not interested in its cancellation: what's important 
; 3133 : 		// is not to hold indefinitely into a queue an IRP which must be 
; 3134 : 		// cancelled.
; 3135 : 		//
; 3136 : 		// True, the IRP will be queued waiting for the DPC which will
; 3137 : 		// complete it, but this is bound to happen. That is the
; 3138 : 		// IRP will not be held indefinitely, waiting for some event
; 3139 : 		// to occur, as is the case when it's in the queue waiting for
; 3140 : 		// intercepted data.
; 3141 : 
; 3142 : 		PIRP pClientIrp = CONTAINING_RECORD(pFirst, IRP, 
; 3143 : 			Tail.Overlay.ListEntry);

	mov	eax, DWORD PTR _pFirst$26936[ebp]
	sub	eax, 88					; 00000058H
	mov	DWORD PTR _pClientIrp$26937[ebp], eax

; 3144 : 
; 3145 : 		DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 3146 : 			"FLT - SendIrpDataToClt - Client IRP %#p dequeued\n", 
; 3147 : 			pClientIrp);

	mov	ecx, DWORD PTR _pClientIrp$26937[ebp]
	push	ecx
	push	OFFSET ??_C@_0DC@JPOPAAME@FLT?5?9?5SendIrpDataToClt?5?9?5Client?5@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 16					; 00000010H

; 3148 : 
; 3149 : 		MoveIrpDataToCltIrp(pDevExt, pClientIrp);

	mov	edx, DWORD PTR _pClientIrp$26937[ebp]
	push	edx
	mov	eax, DWORD PTR _pDevExt$[ebp]
	push	eax
	call	?MoveIrpDataToCltIrp@@YGXPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z ; MoveIrpDataToCltIrp

; 3150 : 		QueueCltIrpForCompletion(pDevExt, pClientIrp);

	mov	ecx, DWORD PTR _pClientIrp$26937[ebp]
	push	ecx
	mov	edx, DWORD PTR _pDevExt$[ebp]
	push	edx
	call	?QueueCltIrpForCompletion@@YGXPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z ; QueueCltIrpForCompletion

; 3151 : 	}

	jmp	SHORT $LN3@SendIrpDat
$LN4@SendIrpDat:

; 3152 : 	return;
; 3153 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?SendIrpDataToClt@@YGXPAU_DEVICE_EXTENSION@@@Z ENDP	; SendIrpDataToClt
_TEXT	ENDS
PUBLIC	??_C@_0EB@GMMKCGII@FLT?5?9?5MoveIrpDataToCltIrp?5?9?5Pass@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_0EC@MMEJNLGB@FLT?5?9?5MoveIrpDataToCltIrp?5?9?5Clie@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	?CBFreeOldestDataBlock@@YGXPAU_CIRCULAR_BUFFER@@@Z:PROC ; CBFreeOldestDataBlock
EXTRN	?CBXtractFromStart@@YGJPAU_CIRCULAR_BUFFER@@PAKPAPAD111@Z:PROC ; CBXtractFromStart
;	COMDAT ??_C@_0EB@GMMKCGII@FLT?5?9?5MoveIrpDataToCltIrp?5?9?5Pass@FNODOBFM@
text$s	SEGMENT
??_C@_0EB@GMMKCGII@FLT?5?9?5MoveIrpDataToCltIrp?5?9?5Pass@FNODOBFM@ DB 'F'
	DB	'LT - MoveIrpDataToCltIrp - Passed %#x bytes of data to IRP %#'
	DB	'p', 0aH, 00H				;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_0EC@MMEJNLGB@FLT?5?9?5MoveIrpDataToCltIrp?5?9?5Clie@FNODOBFM@
text$s	SEGMENT
??_C@_0EC@MMEJNLGB@FLT?5?9?5MoveIrpDataToCltIrp?5?9?5Clie@FNODOBFM@ DB 'F'
	DB	'LT - MoveIrpDataToCltIrp - Client IRP %#p: buffer %#p, len: %'
	DB	'#x', 0aH, 00H				;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?MoveIrpDataToCltIrp@@YGXPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
_TEXT	SEGMENT
tv77 = -56						; size = 4
_cbXtractOffset$ = -52					; size = 4
_pIoStack$ = -48					; size = 4
_status$ = -44						; size = 4
_irpHeader$ = -40					; size = 8
_cbBytesToRead$ = -32					; size = 4
_pCbuf$ = -28						; size = 4
_tmpRemaining$ = -24					; size = 4
_pMdl$ = -20						; size = 4
_pOutBuf$ = -16						; size = 4
_cbRemaining$ = -12					; size = 4
_maxDataLen$ = -8					; size = 4
_pTmpRecvPointer$ = -4					; size = 4
_pDevExt$ = 8						; size = 4
_pCltIrp$ = 12						; size = 4
?MoveIrpDataToCltIrp@@YGXPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z PROC ; MoveIrpDataToCltIrp, COMDAT

; 2837 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 56					; 00000038H

; 2838 : 	NTSTATUS status;
; 2839 : 
; 2840 : 	// The client IRP is for the filter access device, which does
; 2841 : 	// direct I/O.
; 2842 : 	//
; 2843 : 	PMDL pMdl = pCltIrp->MdlAddress;

	mov	eax, DWORD PTR _pCltIrp$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _pMdl$[ebp], ecx

; 2844 : 	PCHAR pOutBuf = (PCHAR) MmGetSystemAddressForMdlSafe(pMdl, 
; 2845 : 			LowPagePriority);

	mov	edx, DWORD PTR _pMdl$[ebp]
	movsx	eax, WORD PTR [edx+6]
	and	eax, 5
	je	SHORT $LN6@MoveIrpDat
	mov	ecx, DWORD PTR _pMdl$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	mov	DWORD PTR tv77[ebp], edx
	jmp	SHORT $LN7@MoveIrpDat
$LN6@MoveIrpDat:
	push	0
	push	0
	push	0
	push	1
	push	0
	mov	eax, DWORD PTR _pMdl$[ebp]
	push	eax
	call	DWORD PTR __imp__MmMapLockedPagesSpecifyCache@24
	mov	DWORD PTR tv77[ebp], eax
$LN7@MoveIrpDat:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR _pOutBuf$[ebp], ecx

; 2846 : 	if (pOutBuf == NULL) {

	cmp	DWORD PTR _pOutBuf$[ebp], 0
	jne	SHORT $LN3@MoveIrpDat

; 2847 : 
; 2848 : 		// This should never happen, because the MDL has already been
; 2849 : 		// locked by the I/O manager.
; 2850 : 		//
; 2851 : 		pCltIrp->IoStatus.Status = STATUS_NO_MEMORY;

	mov	edx, DWORD PTR _pCltIrp$[ebp]
	mov	DWORD PTR [edx+24], -1073741801		; c0000017H

; 2852 : 		pCltIrp->IoStatus.Information = 0;

	mov	eax, DWORD PTR _pCltIrp$[ebp]
	mov	DWORD PTR [eax+28], 0

; 2853 : 		return;

	jmp	$LN4@MoveIrpDat
$LN3@MoveIrpDat:

; 2854 : 	}
; 2855 : 	PIO_STACK_LOCATION pIoStack = IoGetCurrentIrpStackLocation(pCltIrp);

	mov	ecx, DWORD PTR _pCltIrp$[ebp]
	push	ecx
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _pIoStack$[ebp], eax

; 2856 : 	SIZE_T cbRemaining = pIoStack->Parameters.Read.Length;

	mov	edx, DWORD PTR _pIoStack$[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR _cbRemaining$[ebp], eax

; 2857 : 
; 2858 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 2859 : 		"FLT - MoveIrpDataToCltIrp - Client IRP %#p: buffer %#p, "
; 2860 : 		"len: %#x\n",
; 2861 : 		pCltIrp,
; 2862 : 		pOutBuf,
; 2863 : 		cbRemaining);

	mov	ecx, DWORD PTR _cbRemaining$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pOutBuf$[ebp]
	push	edx
	mov	eax, DWORD PTR _pCltIrp$[ebp]
	push	eax
	push	OFFSET ??_C@_0EC@MMEJNLGB@FLT?5?9?5MoveIrpDataToCltIrp?5?9?5Clie@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 24					; 00000018H

; 2864 : 
; 2865 : 	// We know that the data block is header + IRP + I/O stack +
; 2866 : 	// (optionally) data.
; 2867 : 	//
; 2868 : 	// We also know that cbRemaining is >= the length of header, IRP and
; 2869 : 	// I/O stack, because this is checked when client IRPs are received.
; 2870 : 	//
; 2871 : 	// Let's start by transferring the header.
; 2872 : 	//
; 2873 : 	PCIRCULAR_BUFFER pCbuf = &pDevExt->DataBuffer;

	mov	ecx, DWORD PTR _pDevExt$[ebp]
	add	ecx, 40					; 00000028H
	mov	DWORD PTR _pCbuf$[ebp], ecx

; 2874 : 
; 2875 : 	// Extract the IRP header into a local variable, because we will 
; 2876 : 	// need to access it here.
; 2877 : 	//
; 2878 : 	IRP_HEADER irpHeader;
; 2879 : 	PCHAR pTmpRecvPointer = (PCHAR) &irpHeader;

	lea	edx, DWORD PTR _irpHeader$[ebp]
	mov	DWORD PTR _pTmpRecvPointer$[ebp], edx

; 2880 : 	SIZE_T tmpRemaining = sizeof irpHeader;

	mov	DWORD PTR _tmpRemaining$[ebp], 8

; 2881 : 	SIZE_T cbBytesToRead = sizeof irpHeader;

	mov	DWORD PTR _cbBytesToRead$[ebp], 8

; 2882 : 	SIZE_T cbXtractOffset = 0;

	mov	DWORD PTR _cbXtractOffset$[ebp], 0

; 2883 : 	status = CBXtractFromStart(
; 2884 : 		pCbuf,
; 2885 : 		&cbXtractOffset,
; 2886 : 		&pTmpRecvPointer,
; 2887 : 		&tmpRemaining,
; 2888 : 		&cbBytesToRead,
; 2889 : 		NULL);

	push	0
	lea	eax, DWORD PTR _cbBytesToRead$[ebp]
	push	eax
	lea	ecx, DWORD PTR _tmpRemaining$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pTmpRecvPointer$[ebp]
	push	edx
	lea	eax, DWORD PTR _cbXtractOffset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCbuf$[ebp]
	push	ecx
	call	?CBXtractFromStart@@YGJPAU_CIRCULAR_BUFFER@@PAKPAPAD111@Z ; CBXtractFromStart
	mov	DWORD PTR _status$[ebp], eax

; 2890 : 	if (!NT_SUCCESS(status)) {

	cmp	DWORD PTR _status$[ebp], 0
	jge	SHORT $LN2@MoveIrpDat

; 2891 : 
; 2892 : 		// This should not happen. It means that there is no data
; 2893 : 		// into the buffer, which should be prevented by design.
; 2894 : 		//
; 2895 : 		pCltIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;

	mov	edx, DWORD PTR _pCltIrp$[ebp]
	mov	DWORD PTR [edx+24], -1073741823		; c0000001H

; 2896 : 		pCltIrp->IoStatus.Information = 0;

	mov	eax, DWORD PTR _pCltIrp$[ebp]
	mov	DWORD PTR [eax+28], 0

; 2897 : 		return;

	jmp	$LN4@MoveIrpDat
$LN2@MoveIrpDat:

; 2898 : 	}
; 2899 : 
; 2900 : 	// Look into the header to see if there are data bytes following 
; 2901 : 	// the IRP and set a flag if the buffer isn't big enough.
; 2902 : 	//
; 2903 : 	SIZE_T maxDataLen  = cbRemaining - sizeof (IRP_HEADER) -
; 2904 : 		sizeof (IRP) - sizeof(IO_STACK_LOCATION);

	mov	ecx, DWORD PTR _cbRemaining$[ebp]
	sub	ecx, 156				; 0000009cH
	mov	DWORD PTR _maxDataLen$[ebp], ecx

; 2905 : 	if (irpHeader.cbDataLen > maxDataLen) {

	mov	edx, DWORD PTR _irpHeader$[ebp+4]
	cmp	edx, DWORD PTR _maxDataLen$[ebp]
	jbe	SHORT $LN1@MoveIrpDat

; 2906 : 		irpHeader.dwFlags |= IRPSTAT_DATA_LOST;

	mov	eax, DWORD PTR _irpHeader$[ebp]
	or	eax, 1
	mov	DWORD PTR _irpHeader$[ebp], eax

; 2907 : 
; 2908 : 		// Adjust the data length returned to the client.
; 2909 : 		//
; 2910 : 		irpHeader.cbDataLen = maxDataLen;

	mov	ecx, DWORD PTR _maxDataLen$[ebp]
	mov	DWORD PTR _irpHeader$[ebp+4], ecx
$LN1@MoveIrpDat:

; 2911 : 	}
; 2912 : 
; 2913 : 	// Copy the header content into the output buffer.
; 2914 : 	//
; 2915 : 	RtlCopyMemory(pOutBuf, &irpHeader, sizeof irpHeader);

	mov	edx, DWORD PTR _pOutBuf$[ebp]
	mov	eax, DWORD PTR _irpHeader$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR _irpHeader$[ebp+4]
	mov	DWORD PTR [edx+4], ecx

; 2916 : 	pOutBuf += sizeof irpHeader;

	mov	edx, DWORD PTR _pOutBuf$[ebp]
	add	edx, 8
	mov	DWORD PTR _pOutBuf$[ebp], edx

; 2917 : 	cbRemaining -= sizeof irpHeader;

	mov	eax, DWORD PTR _cbRemaining$[ebp]
	sub	eax, 8
	mov	DWORD PTR _cbRemaining$[ebp], eax

; 2918 : 
; 2919 : 	// Extract the remainder of the data block directly into the output 
; 2920 : 	// buffer.
; 2921 : 	//
; 2922 : 	// We are sure we have at least the IRP and the I/O stack location 
; 2923 : 	// to tansfer. Optionally, we'll transfer some data, if there are 
; 2924 : 	// any and if there's room in the client buffer.
; 2925 : 	//
; 2926 : 	CBXtractFromStart(
; 2927 : 		pCbuf,
; 2928 : 		&cbXtractOffset,
; 2929 : 		&pOutBuf,
; 2930 : 		&cbRemaining,
; 2931 : 		NULL,
; 2932 : 		NULL);

	push	0
	push	0
	lea	ecx, DWORD PTR _cbRemaining$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pOutBuf$[ebp]
	push	edx
	lea	eax, DWORD PTR _cbXtractOffset$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCbuf$[ebp]
	push	ecx
	call	?CBXtractFromStart@@YGJPAU_CIRCULAR_BUFFER@@PAKPAPAD111@Z ; CBXtractFromStart

; 2933 : 
; 2934 : 	// cbRemaining was originally set to the client buffer size, so we
; 2935 : 	// can compute the number of bytes transferred.
; 2936 : 	//
; 2937 : 	pCltIrp->IoStatus.Information = pIoStack->Parameters.Read.Length -
; 2938 : 		cbRemaining;

	mov	edx, DWORD PTR _pIoStack$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _cbRemaining$[ebp]
	mov	ecx, DWORD PTR _pCltIrp$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 2939 : 	pCltIrp->IoStatus.Status = STATUS_SUCCESS;

	mov	edx, DWORD PTR _pCltIrp$[ebp]
	mov	DWORD PTR [edx+24], 0

; 2940 : 
; 2941 : 
; 2942 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 2943 : 		"FLT - MoveIrpDataToCltIrp - Passed %#x bytes of data to "
; 2944 : 		"IRP %#p\n", 
; 2945 : 		pCltIrp->IoStatus.Information, pCltIrp);

	mov	eax, DWORD PTR _pCltIrp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pCltIrp$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	push	edx
	push	OFFSET ??_C@_0EB@GMMKCGII@FLT?5?9?5MoveIrpDataToCltIrp?5?9?5Pass@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 20					; 00000014H

; 2946 : 
; 2947 : 	// Discard the data block from the buffer
; 2948 : 	//
; 2949 : 	CBFreeOldestDataBlock(pCbuf);

	mov	eax, DWORD PTR _pCbuf$[ebp]
	push	eax
	call	?CBFreeOldestDataBlock@@YGXPAU_CIRCULAR_BUFFER@@@Z ; CBFreeOldestDataBlock
$LN4@MoveIrpDat:

; 2950 : 	return;
; 2951 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?MoveIrpDataToCltIrp@@YGXPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z ENDP ; MoveIrpDataToCltIrp
_TEXT	ENDS
PUBLIC	??_C@_0EH@FIHPDACL@FLT?5?9?5QueueCltIrpForCompletion?5?9@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp__KeInsertQueueDpc@12:PROC
;	COMDAT ??_C@_0EH@FIHPDACL@FLT?5?9?5QueueCltIrpForCompletion?5?9@FNODOBFM@
text$s	SEGMENT
??_C@_0EH@FIHPDACL@FLT?5?9?5QueueCltIrpForCompletion?5?9@FNODOBFM@ DB 'FL'
	DB	'T - QueueCltIrpForCompletion - Client IRP %#p queued for comp'
	DB	'letion', 0aH, 00H				;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?QueueCltIrpForCompletion@@YGXPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z
_TEXT	SEGMENT
_pDevExt$ = 8						; size = 4
_pCltIrp$ = 12						; size = 4
?QueueCltIrpForCompletion@@YGXPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z PROC ; QueueCltIrpForCompletion, COMDAT

; 3027 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 3028 : 	InsertTailList(
; 3029 : 		&pDevExt->pWaitingComplIrpList,
; 3030 : 		&pCltIrp->Tail.Overlay.ListEntry);

	mov	eax, DWORD PTR _pCltIrp$[ebp]
	add	eax, 88					; 00000058H
	push	eax
	mov	ecx, DWORD PTR _pDevExt$[ebp]
	add	ecx, 208				; 000000d0H
	push	ecx
	call	_InsertTailList@8

; 3031 : 	KeInsertQueueDpc(
; 3032 : 		&pDevExt->ComplDpc,
; 3033 : 		NULL,
; 3034 : 		NULL);

	push	0
	push	0
	mov	edx, DWORD PTR _pDevExt$[ebp]
	add	edx, 8
	push	edx
	call	DWORD PTR __imp__KeInsertQueueDpc@12

; 3035 : 
; 3036 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 3037 : 		"FLT - QueueCltIrpForCompletion - Client IRP %#p queued "
; 3038 : 		"for completion\n", 
; 3039 : 		pCltIrp);

	mov	eax, DWORD PTR _pCltIrp$[ebp]
	push	eax
	push	OFFSET ??_C@_0EH@FIHPDACL@FLT?5?9?5QueueCltIrpForCompletion?5?9@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 16					; 00000010H

; 3040 : }

	pop	ebp
	ret	8
?QueueCltIrpForCompletion@@YGXPAU_DEVICE_EXTENSION@@PAU_IRP@@@Z ENDP ; QueueCltIrpForCompletion
_TEXT	ENDS
EXTRN	__imp__KeWaitForSingleObject@20:PROC
EXTRN	__imp__KeClearEvent@4:PROC
; Function compile flags: /Odtp
;	COMDAT ?SendIrpSync@@YGJPAU_IRP@@PAU_KEVENT@@@Z
_TEXT	SEGMENT
_status$ = -8						; size = 4
_pNextStack$ = -4					; size = 4
_pIrp$ = 8						; size = 4
_pEvent$ = 12						; size = 4
?SendIrpSync@@YGJPAU_IRP@@PAU_KEVENT@@@Z PROC		; SendIrpSync, COMDAT

; 3178 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3179 : 	KeClearEvent (pEvent);

	mov	eax, DWORD PTR _pEvent$[ebp]
	push	eax
	call	DWORD PTR __imp__KeClearEvent@4

; 3180 : 	IoSetCompletionRoutine(pIrp, SendIrpSyncCompletion, pEvent, TRUE, 
; 3181 : 		TRUE, TRUE);

	push	1
	push	1
	push	1
	mov	ecx, DWORD PTR _pEvent$[ebp]
	push	ecx
	push	OFFSET ?SendIrpSyncCompletion@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@PAX@Z ; SendIrpSyncCompletion
	mov	edx, DWORD PTR _pIrp$[ebp]
	push	edx
	call	_IoSetCompletionRoutine@24

; 3182 : 	PIO_STACK_LOCATION pNextStack = IoGetNextIrpStackLocation(pIrp);

	mov	eax, DWORD PTR _pIrp$[ebp]
	push	eax
	call	_IoGetNextIrpStackLocation@4
	mov	DWORD PTR _pNextStack$[ebp], eax

; 3183 : 	NTSTATUS status = IoCallDriver(
; 3184 : 		pNextStack->DeviceObject,
; 3185 : 		pIrp);

	mov	edx, DWORD PTR _pIrp$[ebp]
	mov	ecx, DWORD PTR _pNextStack$[ebp]
	mov	ecx, DWORD PTR [ecx+20]
	call	DWORD PTR __imp_@IofCallDriver@8
	mov	DWORD PTR _status$[ebp], eax

; 3186 : 	if (status == STATUS_PENDING) {

	cmp	DWORD PTR _status$[ebp], 259		; 00000103H
	jne	SHORT $LN1@SendIrpSyn

; 3187 : 		KeWaitForSingleObject(pEvent, Executive, KernelMode, FALSE, NULL);

	push	0
	push	0
	push	0
	push	0
	mov	edx, DWORD PTR _pEvent$[ebp]
	push	edx
	call	DWORD PTR __imp__KeWaitForSingleObject@20

; 3188 : 		status = pIrp->IoStatus.Status;

	mov	eax, DWORD PTR _pIrp$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR _status$[ebp], ecx
$LN1@SendIrpSyn:

; 3189 : 	}
; 3190 : 	return status;

	mov	eax, DWORD PTR _status$[ebp]

; 3191 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?SendIrpSync@@YGJPAU_IRP@@PAU_KEVENT@@@Z ENDP		; SendIrpSync
_TEXT	ENDS
EXTRN	__imp__KeSetEvent@12:PROC
; Function compile flags: /Odtp
;	COMDAT ?SendIrpSyncCompletion@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@PAX@Z
_TEXT	SEGMENT
_pDevObj$ = 8						; size = 4
_pIrp$ = 12						; size = 4
_Context$ = 16						; size = 4
?SendIrpSyncCompletion@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@PAX@Z PROC ; SendIrpSyncCompletion, COMDAT

; 3214 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 3215 : 	KeSetEvent((PKEVENT) Context, IO_NO_INCREMENT, FALSE);

	push	0
	push	0
	mov	eax, DWORD PTR _Context$[ebp]
	push	eax
	call	DWORD PTR __imp__KeSetEvent@12

; 3216 : 	return STATUS_MORE_PROCESSING_REQUIRED;

	mov	eax, -1073741802			; c0000016H

; 3217 : }

	pop	ebp
	ret	12					; 0000000cH
?SendIrpSyncCompletion@@YGJPAU_DEVICE_OBJECT@@PAU_IRP@@PAX@Z ENDP ; SendIrpSyncCompletion
_TEXT	ENDS
PUBLIC	??_C@_0IJ@HMLMAHPH@FLT?5?9?5?$CFs?5?9?5Tracing?5IRP?5?$CF?$CDp?6?7Majo@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	__$ArrayPad$
;	COMDAT ??_C@_0IJ@HMLMAHPH@FLT?5?9?5?$CFs?5?9?5Tracing?5IRP?5?$CF?$CDp?6?7Majo@FNODOBFM@
text$s	SEGMENT
??_C@_0IJ@HMLMAHPH@FLT?5?9?5?$CFs?5?9?5Tracing?5IRP?5?$CF?$CDp?6?7Majo@FNODOBFM@ DB 'F'
	DB	'LT - %s - Tracing IRP %#p', 0aH, 09H, 'MajorFunction = %s', 0aH
	DB	09H, 'MinorFunction = %s', 0aH, 09H, 'Filter %#p', 0aH, 09H, 't'
	DB	'arget text    %S', 0aH, 09H, 'target HW ID   %S', 0aH, 09H, 't'
	DB	'arget inst ID %S', 0aH, 00H			;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?TraceIrpBasicInfo@@YGXPAU_DEVICE_EXTENSION@@PADPAU_IRP@@@Z
_TEXT	SEGMENT
_pTargInf$ = -236					; size = 4
_pStack$ = -232						; size = 4
_pwszInstID$ = -228					; size = 4
_szBufMin$ = -224					; size = 101
_pwszDevText$ = -120					; size = 4
_pwszHwID$ = -116					; size = 4
_szBuf$ = -112						; size = 101
__$ArrayPad$ = -4					; size = 4
_pFltDevExt$ = 8					; size = 4
_pszCallingFunction$ = 12				; size = 4
_pIrp$ = 16						; size = 4
?TraceIrpBasicInfo@@YGXPAU_DEVICE_EXTENSION@@PADPAU_IRP@@@Z PROC ; TraceIrpBasicInfo, COMDAT

; 3243 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 3244 : 	PIO_STACK_LOCATION pStack = 
; 3245 : 		IoGetCurrentIrpStackLocation(pIrp);

	mov	eax, DWORD PTR _pIrp$[ebp]
	push	eax
	call	_IoGetCurrentIrpStackLocation@4
	mov	DWORD PTR _pStack$[ebp], eax

; 3246 : 	CHAR szBuf[101];
; 3247 : 	CHAR szBufMin[101];
; 3248 : 
; 3249 : 	// Retrieve the device text and IDs
; 3250 : 	//
; 3251 : 	PTARGET_DEVICE_INFO pTargInf = &pFltDevExt->pFADevExt->TargDevInfo;

	mov	ecx, DWORD PTR _pFltDevExt$[ebp]
	mov	edx, DWORD PTR [ecx+192]
	add	edx, 12					; 0000000cH
	mov	DWORD PTR _pTargInf$[ebp], edx

; 3252 : 	PWCHAR pwszDevText = pTargInf->DeviceText;

	mov	eax, DWORD PTR _pTargInf$[ebp]
	add	eax, 508				; 000001fcH
	mov	DWORD PTR _pwszDevText$[ebp], eax

; 3253 : 	PWCHAR pwszHwID = pTargInf->HardwareIDs;

	mov	ecx, DWORD PTR _pTargInf$[ebp]
	add	ecx, 710				; 000002c6H
	mov	DWORD PTR _pwszHwID$[ebp], ecx

; 3254 : 	PWCHAR pwszInstID = pTargInf->InstanceId;

	mov	edx, DWORD PTR _pTargInf$[ebp]
	add	edx, 912				; 00000390H
	mov	DWORD PTR _pwszInstID$[ebp], edx

; 3255 : 	DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,
; 3256 : 		"FLT - %s - Tracing IRP %#p\n"
; 3257 : 		"\tMajorFunction = %s\n"
; 3258 : 		"\tMinorFunction = %s\n"
; 3259 : 		"\tFilter %#p\n"
; 3260 : 		"\ttarget text    %S\n"
; 3261 : 		"\ttarget HW ID   %S\n"
; 3262 : 		"\ttarget inst ID %S\n",
; 3263 : 		pszCallingFunction,
; 3264 : 		pIrp,
; 3265 : 		MajorFunctionDes(pStack->MajorFunction, szBuf, 
; 3266 : 			sizeof szBuf), 
; 3267 : 		MinorFunctionDes(pStack->MajorFunction, 
; 3268 : 			pStack->MinorFunction, szBufMin, sizeof szBufMin),
; 3269 : 			pFltDevExt->hdr.pDevice,
; 3270 : 		pwszDevText,
; 3271 : 		pwszHwID,
; 3272 : 		pwszInstID
; 3273 : 		);

	mov	eax, DWORD PTR _pwszInstID$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pwszHwID$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pwszDevText$[ebp]
	push	edx
	mov	eax, DWORD PTR _pFltDevExt$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	101					; 00000065H
	lea	edx, DWORD PTR _szBufMin$[ebp]
	push	edx
	mov	eax, DWORD PTR _pStack$[ebp]
	movzx	ecx, BYTE PTR [eax+1]
	push	ecx
	mov	edx, DWORD PTR _pStack$[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	call	?MinorFunctionDes@@YGPADEEPADK@Z	; MinorFunctionDes
	push	eax
	push	101					; 00000065H
	lea	ecx, DWORD PTR _szBuf$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pStack$[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	call	?MajorFunctionDes@@YGPADEPADK@Z		; MajorFunctionDes
	push	eax
	mov	ecx, DWORD PTR _pIrp$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszCallingFunction$[ebp]
	push	edx
	push	OFFSET ??_C@_0IJ@HMLMAHPH@FLT?5?9?5?$CFs?5?9?5Tracing?5IRP?5?$CF?$CDp?6?7Majo@FNODOBFM@
	push	0
	push	77					; 0000004dH
	call	DWORD PTR __imp__DbgPrintEx
	add	esp, 44					; 0000002cH

; 3274 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?TraceIrpBasicInfo@@YGXPAU_DEVICE_EXTENSION@@PADPAU_IRP@@@Z ENDP ; TraceIrpBasicInfo
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?MajorFunctionDes@@YGPADEPADK@Z
_TEXT	SEGMENT
_MajorFunction$ = 8					; size = 1
_pszDecodeBuf$ = 12					; size = 4
_cbBufSize$ = 16					; size = 4
?MajorFunctionDes@@YGPADEPADK@Z PROC			; MajorFunctionDes, COMDAT

; 2653 : {

	npad	2
	push	ebp
	mov	ebp, esp

; 2654 : 	return DecodeEnum(
; 2655 : 		MajorFunction,
; 2656 : 		0,
; 2657 : 		pszMajorFunctionV,
; 2658 : 		sizeof pszMajorFunctionV / sizeof(PSTR),
; 2659 : 		pszDecodeBuf,
; 2660 : 		cbBufSize);

	mov	eax, DWORD PTR _cbBufSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszDecodeBuf$[ebp]
	push	ecx
	push	28					; 0000001cH
	push	OFFSET ?pszMajorFunctionV@@3PAPADA	; pszMajorFunctionV
	push	0
	movzx	edx, BYTE PTR _MajorFunction$[ebp]
	push	edx
	call	?DecodeEnum@@YGPADHHQAPADHPADK@Z	; DecodeEnum

; 2661 : }

	pop	ebp
	ret	12					; 0000000cH
?MajorFunctionDes@@YGPADEPADK@Z ENDP			; MajorFunctionDes
_TEXT	ENDS
PUBLIC	_RtlStringCbPrintfA
PUBLIC	??_C@_03JELKHEKI@?$CF?$CDx?$AA@FNODOBFM@	;  ?? ::FNODOBFM::`string'
PUBLIC	_RtlStringCbCopyA@12
;	COMDAT ??_C@_03JELKHEKI@?$CF?$CDx?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_03JELKHEKI@?$CF?$CDx?$AA@FNODOBFM@ DB '%#x', 00H	;  ?? ::FNODOBFM::`string'
; Function compile flags: /Odtp
text$s	ENDS
;	COMDAT ?DecodeEnum@@YGPADHHQAPADHPADK@Z
_TEXT	SEGMENT
_Index$ = -4						; size = 4
_Value$ = 8						; size = 4
_Base$ = 12						; size = 4
_pszDecodeV$ = 16					; size = 4
_VectLen$ = 20						; size = 4
_pszOutBuf$ = 24					; size = 4
_cbBufSize$ = 28					; size = 4
?DecodeEnum@@YGPADHHQAPADHPADK@Z PROC			; DecodeEnum, COMDAT

; 1125 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 1126 : 	INT Index = Value - Base;

	mov	eax, DWORD PTR _Value$[ebp]
	sub	eax, DWORD PTR _Base$[ebp]
	mov	DWORD PTR _Index$[ebp], eax

; 1127 : 	if ((Index >= 0) && ((INT) Index < VectLen)) {

	js	SHORT $LN2@DecodeEnum
	mov	ecx, DWORD PTR _Index$[ebp]
	cmp	ecx, DWORD PTR _VectLen$[ebp]
	jge	SHORT $LN2@DecodeEnum

; 1128 : 		RtlStringCbCopyA(pszOutBuf, cbBufSize, pszDecodeV[Index]);

	mov	edx, DWORD PTR _Index$[ebp]
	mov	eax, DWORD PTR _pszDecodeV$[ebp]
	mov	ecx, DWORD PTR [eax+edx*4]
	push	ecx
	mov	edx, DWORD PTR _cbBufSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszOutBuf$[ebp]
	push	eax
	call	_RtlStringCbCopyA@12

; 1129 : 	} else {

	jmp	SHORT $LN1@DecodeEnum
$LN2@DecodeEnum:

; 1130 : 		RtlStringCbPrintfA(pszOutBuf, cbBufSize, "%#x", Value);

	mov	ecx, DWORD PTR _Value$[ebp]
	push	ecx
	push	OFFSET ??_C@_03JELKHEKI@?$CF?$CDx?$AA@FNODOBFM@
	mov	edx, DWORD PTR _cbBufSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszOutBuf$[ebp]
	push	eax
	call	_RtlStringCbPrintfA
	add	esp, 16					; 00000010H
$LN1@DecodeEnum:

; 1131 : 	}
; 1132 : 
; 1133 : 	return pszOutBuf;

	mov	eax, DWORD PTR _pszOutBuf$[ebp]

; 1134 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?DecodeEnum@@YGPADHHQAPADHPADK@Z ENDP			; DecodeEnum
; Function compile flags: /Odtp
; File c:\apps\pw7hp\devpgm\msddk\inc\ddk\ntstrsafe.h
_TEXT	ENDS
;	COMDAT _RtlStringCbCopyA@12
_TEXT	SEGMENT
_cchDest$ = -8						; size = 4
_status$ = -4						; size = 4
_pszDest$ = 8						; size = 4
_cbDest$ = 12						; size = 4
_pszSrc$ = 16						; size = 4
_RtlStringCbCopyA@12 PROC				; COMDAT

; 632  : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 633  :     NTSTATUS status;
; 634  :     size_t cchDest = cbDest / sizeof(char);

	mov	eax, DWORD PTR _cbDest$[ebp]
	mov	DWORD PTR _cchDest$[ebp], eax

; 635  : 
; 636  :     status = RtlStringValidateDestA(pszDest, cchDest, NTSTRSAFE_MAX_CCH);

	push	2147483647				; 7fffffffH
	mov	ecx, DWORD PTR _cchDest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszDest$[ebp]
	push	edx
	call	_RtlStringValidateDestA@12
	mov	DWORD PTR _status$[ebp], eax

; 637  : 
; 638  :     if (NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jl	SHORT $LN1@RtlStringC

; 639  :     {
; 640  :         status = RtlStringCopyWorkerA(pszDest,
; 641  :                                cchDest,
; 642  :                                NULL,
; 643  :                                pszSrc,
; 644  :                                NTSTRSAFE_MAX_LENGTH);

	push	2147483646				; 7ffffffeH
	mov	eax, DWORD PTR _pszSrc$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _cchDest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszDest$[ebp]
	push	edx
	call	_RtlStringCopyWorkerA@20
	mov	DWORD PTR _status$[ebp], eax
$LN1@RtlStringC:

; 645  :     }
; 646  : 
; 647  :     return status;

	mov	eax, DWORD PTR _status$[ebp]

; 648  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_RtlStringCbCopyA@12 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _RtlStringCbPrintfA
_TEXT	SEGMENT
_argList$23782 = -12					; size = 4
_cchDest$ = -8						; size = 4
_status$ = -4						; size = 4
_pszDest$ = 8						; size = 4
_cbDest$ = 12						; size = 4
_pszFormat$ = 16					; size = 4
_RtlStringCbPrintfA PROC				; COMDAT

; 4503 : {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 4504 :     NTSTATUS status;
; 4505 :     size_t cchDest = cbDest / sizeof(char);

	mov	eax, DWORD PTR _cbDest$[ebp]
	mov	DWORD PTR _cchDest$[ebp], eax

; 4506 : 
; 4507 :     status = RtlStringValidateDestA(pszDest, cchDest, NTSTRSAFE_MAX_CCH);

	push	2147483647				; 7fffffffH
	mov	ecx, DWORD PTR _cchDest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszDest$[ebp]
	push	edx
	call	_RtlStringValidateDestA@12
	mov	DWORD PTR _status$[ebp], eax

; 4508 :     
; 4509 :     if (NT_SUCCESS(status))

	cmp	DWORD PTR _status$[ebp], 0
	jl	SHORT $LN1@RtlStringC@2

; 4510 :     {
; 4511 :         va_list argList;
; 4512 : 
; 4513 :         va_start(argList, pszFormat);

	lea	eax, DWORD PTR _pszFormat$[ebp+4]
	mov	DWORD PTR _argList$23782[ebp], eax

; 4514 : 
; 4515 :         status = RtlStringVPrintfWorkerA(pszDest,
; 4516 :                                   cchDest,
; 4517 :                                   NULL,
; 4518 :                                   pszFormat,
; 4519 :                                   argList);

	mov	ecx, DWORD PTR _argList$23782[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszFormat$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _cchDest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszDest$[ebp]
	push	ecx
	call	_RtlStringVPrintfWorkerA@20
	mov	DWORD PTR _status$[ebp], eax

; 4520 : 
; 4521 :         va_end(argList);

	mov	DWORD PTR _argList$23782[ebp], 0
$LN1@RtlStringC@2:

; 4522 :     }
; 4523 : 
; 4524 :     return status;

	mov	eax, DWORD PTR _status$[ebp]

; 4525 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_RtlStringCbPrintfA ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _RtlStringValidateDestA@12
_TEXT	SEGMENT
_status$ = -4						; size = 4
_pszDest$ = 8						; size = 4
_cchDest$ = 12						; size = 4
_cchMax$ = 16						; size = 4
_RtlStringValidateDestA@12 PROC				; COMDAT

; 11550: {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 11551:     NTSTATUS status = STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 11552: 
; 11553:     if ((cchDest == 0) || (cchDest > cchMax))

	cmp	DWORD PTR _cchDest$[ebp], 0
	je	SHORT $LN1@RtlStringV
	mov	eax, DWORD PTR _cchDest$[ebp]
	cmp	eax, DWORD PTR _cchMax$[ebp]
	jbe	SHORT $LN2@RtlStringV
$LN1@RtlStringV:

; 11554:     {
; 11555:         status = STATUS_INVALID_PARAMETER;

	mov	DWORD PTR _status$[ebp], -1073741811	; c000000dH
$LN2@RtlStringV:

; 11556:     }
; 11557: 
; 11558:     return status;

	mov	eax, DWORD PTR _status$[ebp]

; 11559: }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_RtlStringValidateDestA@12 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _RtlStringCopyWorkerA@20
_TEXT	SEGMENT
_status$ = -8						; size = 4
_cchNewDestLength$ = -4					; size = 4
_pszDest$ = 8						; size = 4
_cchDest$ = 12						; size = 4
_pcchNewDestLength$ = 16				; size = 4
_pszSrc$ = 20						; size = 4
_cchToCopy$ = 24					; size = 4
_RtlStringCopyWorkerA@20 PROC				; COMDAT

; 11776: {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 11777:     NTSTATUS status = STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 11778:     size_t cchNewDestLength = 0;

	mov	DWORD PTR _cchNewDestLength$[ebp], 0
$LN4@RtlStringC@3:

; 11779:     
; 11780:     // ASSERT(cchDest != 0);
; 11781: 
; 11782:     while (cchDest && cchToCopy && (*pszSrc != '\0'))

	cmp	DWORD PTR _cchDest$[ebp], 0
	je	SHORT $LN3@RtlStringC@3
	cmp	DWORD PTR _cchToCopy$[ebp], 0
	je	SHORT $LN3@RtlStringC@3
	mov	eax, DWORD PTR _pszSrc$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN3@RtlStringC@3

; 11783:     {
; 11784:         *pszDest++ = *pszSrc++;

	mov	edx, DWORD PTR _pszDest$[ebp]
	mov	eax, DWORD PTR _pszSrc$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR [edx], cl
	mov	edx, DWORD PTR _pszDest$[ebp]
	add	edx, 1
	mov	DWORD PTR _pszDest$[ebp], edx
	mov	eax, DWORD PTR _pszSrc$[ebp]
	add	eax, 1
	mov	DWORD PTR _pszSrc$[ebp], eax

; 11785:         cchDest--;

	mov	ecx, DWORD PTR _cchDest$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _cchDest$[ebp], ecx

; 11786:         cchToCopy--;

	mov	edx, DWORD PTR _cchToCopy$[ebp]
	sub	edx, 1
	mov	DWORD PTR _cchToCopy$[ebp], edx

; 11787: 
; 11788:         cchNewDestLength++;

	mov	eax, DWORD PTR _cchNewDestLength$[ebp]
	add	eax, 1
	mov	DWORD PTR _cchNewDestLength$[ebp], eax

; 11789:     }

	jmp	SHORT $LN4@RtlStringC@3
$LN3@RtlStringC@3:

; 11790: 
; 11791:     if (cchDest == 0)

	cmp	DWORD PTR _cchDest$[ebp], 0
	jne	SHORT $LN2@RtlStringC@3

; 11792:     {
; 11793:         // we are going to truncate pszDest
; 11794:         pszDest--;

	mov	ecx, DWORD PTR _pszDest$[ebp]
	sub	ecx, 1
	mov	DWORD PTR _pszDest$[ebp], ecx

; 11795:         cchNewDestLength--;

	mov	edx, DWORD PTR _cchNewDestLength$[ebp]
	sub	edx, 1
	mov	DWORD PTR _cchNewDestLength$[ebp], edx

; 11796: 
; 11797:         status = STATUS_BUFFER_OVERFLOW;

	mov	DWORD PTR _status$[ebp], -2147483643	; 80000005H
$LN2@RtlStringC@3:

; 11798:     }
; 11799: 
; 11800:     *pszDest = '\0';

	mov	eax, DWORD PTR _pszDest$[ebp]
	mov	BYTE PTR [eax], 0

; 11801: 
; 11802:     if (pcchNewDestLength)

	cmp	DWORD PTR _pcchNewDestLength$[ebp], 0
	je	SHORT $LN1@RtlStringC@3

; 11803:     {
; 11804:         *pcchNewDestLength = cchNewDestLength;

	mov	ecx, DWORD PTR _pcchNewDestLength$[ebp]
	mov	edx, DWORD PTR _cchNewDestLength$[ebp]
	mov	DWORD PTR [ecx], edx
$LN1@RtlStringC@3:

; 11805:     }
; 11806: 
; 11807:     return status;

	mov	eax, DWORD PTR _status$[ebp]

; 11808: }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_RtlStringCopyWorkerA@20 ENDP
_TEXT	ENDS
EXTRN	__imp___vsnprintf:PROC
; Function compile flags: /Odtp
;	COMDAT _RtlStringVPrintfWorkerA@20
_TEXT	SEGMENT
_status$ = -16						; size = 4
_iRet$ = -12						; size = 4
_cchMax$ = -8						; size = 4
_cchNewDestLength$ = -4					; size = 4
_pszDest$ = 8						; size = 4
_cchDest$ = 12						; size = 4
_pcchNewDestLength$ = 16				; size = 4
_pszFormat$ = 20					; size = 4
_argList$ = 24						; size = 4
_RtlStringVPrintfWorkerA@20 PROC			; COMDAT

; 11858: {

	npad	2
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 11859:     NTSTATUS status = STATUS_SUCCESS;

	mov	DWORD PTR _status$[ebp], 0

; 11860:     int iRet;
; 11861:     size_t cchMax;
; 11862:     size_t cchNewDestLength = 0;

	mov	DWORD PTR _cchNewDestLength$[ebp], 0

; 11863: 
; 11864:     // leave the last space for the null terminator
; 11865:     cchMax = cchDest - 1;

	mov	eax, DWORD PTR _cchDest$[ebp]
	sub	eax, 1
	mov	DWORD PTR _cchMax$[ebp], eax

; 11866: 
; 11867: #if (NTSTRSAFE_USE_SECURE_CRT == 1) && !defined(NTSTRSAFE_LIB_IMPL)
; 11868:     iRet = _vsnprintf_s(pszDest, cchDest, cchMax, pszFormat, argList);
; 11869: #else
; 11870:     #pragma warning(push)
; 11871:     #pragma warning(disable: __WARNING_BANNED_API_USAGE)// "STRSAFE not included"
; 11872:     iRet = _vsnprintf(pszDest, cchMax, pszFormat, argList);

	mov	ecx, DWORD PTR _argList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszFormat$[ebp]
	push	edx
	mov	eax, DWORD PTR _cchMax$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszDest$[ebp]
	push	ecx
	call	DWORD PTR __imp___vsnprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iRet$[ebp], eax

; 11873:     #pragma warning(pop)
; 11874: #endif
; 11875:     // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));
; 11876: 
; 11877:     if ((iRet < 0) || (((size_t)iRet) > cchMax))

	cmp	DWORD PTR _iRet$[ebp], 0
	jl	SHORT $LN5@RtlStringV@2
	mov	edx, DWORD PTR _iRet$[ebp]
	cmp	edx, DWORD PTR _cchMax$[ebp]
	jbe	SHORT $LN6@RtlStringV@2
$LN5@RtlStringV@2:

; 11878:     {
; 11879:         // need to null terminate the string
; 11880:         pszDest += cchMax;

	mov	eax, DWORD PTR _pszDest$[ebp]
	add	eax, DWORD PTR _cchMax$[ebp]
	mov	DWORD PTR _pszDest$[ebp], eax

; 11881:         *pszDest = '\0';

	mov	ecx, DWORD PTR _pszDest$[ebp]
	mov	BYTE PTR [ecx], 0

; 11882: 
; 11883:         cchNewDestLength = cchMax;

	mov	edx, DWORD PTR _cchMax$[ebp]
	mov	DWORD PTR _cchNewDestLength$[ebp], edx

; 11884: 
; 11885:         // we have truncated pszDest
; 11886:         status = STATUS_BUFFER_OVERFLOW;

	mov	DWORD PTR _status$[ebp], -2147483643	; 80000005H
	jmp	SHORT $LN4@RtlStringV@2
$LN6@RtlStringV@2:

; 11887:     }
; 11888:     else if (((size_t)iRet) == cchMax)

	mov	eax, DWORD PTR _iRet$[ebp]
	cmp	eax, DWORD PTR _cchMax$[ebp]
	jne	SHORT $LN3@RtlStringV@2

; 11889:     {
; 11890:         // need to null terminate the string
; 11891:         pszDest += cchMax;

	mov	ecx, DWORD PTR _pszDest$[ebp]
	add	ecx, DWORD PTR _cchMax$[ebp]
	mov	DWORD PTR _pszDest$[ebp], ecx

; 11892:         *pszDest = '\0';

	mov	edx, DWORD PTR _pszDest$[ebp]
	mov	BYTE PTR [edx], 0

; 11893: 
; 11894:         cchNewDestLength = cchMax;

	mov	eax, DWORD PTR _cchMax$[ebp]
	mov	DWORD PTR _cchNewDestLength$[ebp], eax

; 11895:     }
; 11896:     else

	jmp	SHORT $LN4@RtlStringV@2
$LN3@RtlStringV@2:

; 11897:     {
; 11898:         cchNewDestLength = (size_t)iRet;

	mov	ecx, DWORD PTR _iRet$[ebp]
	mov	DWORD PTR _cchNewDestLength$[ebp], ecx
$LN4@RtlStringV@2:

; 11899:     }
; 11900: 
; 11901:     if (pcchNewDestLength)

	cmp	DWORD PTR _pcchNewDestLength$[ebp], 0
	je	SHORT $LN1@RtlStringV@2

; 11902:     {
; 11903:         *pcchNewDestLength = cchNewDestLength;

	mov	edx, DWORD PTR _pcchNewDestLength$[ebp]
	mov	eax, DWORD PTR _cchNewDestLength$[ebp]
	mov	DWORD PTR [edx], eax
$LN1@RtlStringV@2:

; 11904:     }
; 11905: 
; 11906:     return status;

	mov	eax, DWORD PTR _status$[ebp]

; 11907: }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_RtlStringVPrintfWorkerA@20 ENDP
; Function compile flags: /Odtp
; File b:\programm\wntsys\testfilter\release\1_1\source\driver\drvmain.cpp
_TEXT	ENDS
;	COMDAT ?MinorFunctionDes@@YGPADEEPADK@Z
_TEXT	SEGMENT
tv65 = -4						; size = 4
_MajorFunction$ = 8					; size = 1
_MinorFunction$ = 12					; size = 1
_pszDecodeBuf$ = 16					; size = 4
_cbBufSize$ = 20					; size = 4
?MinorFunctionDes@@YGPADEEPADK@Z PROC			; MinorFunctionDes, COMDAT

; 2745 : {

	npad	2
	push	ebp
	mov	ebp, esp
	push	ecx

; 2746 : 	switch (MajorFunction) {

	mov	al, BYTE PTR _MajorFunction$[ebp]
	mov	BYTE PTR tv65[ebp], al
	cmp	BYTE PTR tv65[ebp], 22			; 00000016H
	je	SHORT $LN2@MinorFunct
	cmp	BYTE PTR tv65[ebp], 27			; 0000001bH
	je	SHORT $LN3@MinorFunct
	jmp	SHORT $LN1@MinorFunct
$LN3@MinorFunct:

; 2747 : 		case IRP_MJ_PNP:
; 2748 : 			return DecodeEnum(
; 2749 : 				MinorFunction,
; 2750 : 				0,
; 2751 : 				pszPnpMinorFunctionV,
; 2752 : 				sizeof pszPnpMinorFunctionV / sizeof (PSTR),
; 2753 : 				pszDecodeBuf,
; 2754 : 				cbBufSize);

	mov	ecx, DWORD PTR _cbBufSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszDecodeBuf$[ebp]
	push	edx
	push	24					; 00000018H
	push	OFFSET ?pszPnpMinorFunctionV@@3PAPADA	; pszPnpMinorFunctionV
	push	0
	movzx	eax, BYTE PTR _MinorFunction$[ebp]
	push	eax
	call	?DecodeEnum@@YGPADHHQAPADHPADK@Z	; DecodeEnum
	jmp	SHORT $LN6@MinorFunct

; 2755 : 			break;

	jmp	SHORT $LN6@MinorFunct
$LN2@MinorFunct:

; 2756 : 		case IRP_MJ_POWER:
; 2757 : 			return DecodeEnum(
; 2758 : 				MinorFunction,
; 2759 : 				0,
; 2760 : 				pszPowerMinorFunctionV,
; 2761 : 				sizeof pszPowerMinorFunctionV / sizeof (PSTR),
; 2762 : 				pszDecodeBuf,
; 2763 : 				cbBufSize);

	mov	ecx, DWORD PTR _cbBufSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszDecodeBuf$[ebp]
	push	edx
	push	4
	push	OFFSET ?pszPowerMinorFunctionV@@3PAPADA	; pszPowerMinorFunctionV
	push	0
	movzx	eax, BYTE PTR _MinorFunction$[ebp]
	push	eax
	call	?DecodeEnum@@YGPADHHQAPADHPADK@Z	; DecodeEnum
	jmp	SHORT $LN6@MinorFunct

; 2764 : 			break;

	jmp	SHORT $LN6@MinorFunct
$LN1@MinorFunct:

; 2765 : 		default:
; 2766 : 			RtlStringCbPrintfA(
; 2767 : 				pszDecodeBuf,
; 2768 : 				cbBufSize,
; 2769 : 				"%#x",
; 2770 : 				MinorFunction);

	movzx	ecx, BYTE PTR _MinorFunction$[ebp]
	push	ecx
	push	OFFSET ??_C@_03JELKHEKI@?$CF?$CDx?$AA@FNODOBFM@
	mov	edx, DWORD PTR _cbBufSize$[ebp]
	push	edx
	mov	eax, DWORD PTR _pszDecodeBuf$[ebp]
	push	eax
	call	_RtlStringCbPrintfA
	add	esp, 16					; 00000010H

; 2771 : 			return pszDecodeBuf;

	mov	eax, DWORD PTR _pszDecodeBuf$[ebp]
$LN6@MinorFunct:

; 2772 : 	}
; 2773 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?MinorFunctionDes@@YGPADEEPADK@Z ENDP			; MinorFunctionDes
_TEXT	ENDS
END
