; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

include listing.inc

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG83922 DB	01H DUP (?)
	ALIGN	4

$SG83940 DW	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG84463 DB	'11:00:31', 00H
	ORG $+7
$SG84464 DB	'May  1 2013', 00H
$SG84616 DB	'.', 00H
	ORG $+2
$SG84465 DB	0aH, 00H, 'T', 00H, 'e', 00H, 's', 00H, 't', 00H, ' ', 00H
	DB	'c', 00H, 'l', 00H, 'i', 00H, 'e', 00H, 'n', 00H, 't', 00H, ','
	DB	00H, ' ', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'i', 00H
	DB	'l', 00H, 'e', 00H, 'd', 00H, ' ', 00H, '%', 00H, 'S', 00H, ' '
	DB	00H, '%', 00H, 'S', 00H, 0aH, 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG84476 DB	0aH, 00H, 'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'm'
	DB	00H, 'a', 00H, 'n', 00H, 'd', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	's', 00H, 00H, 00H
	ORG $+6
$SG84483 DB	0aH, 00H, 0aH, 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H
	DB	'a', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 'm', 00H, 'i', 00H, 's'
	DB	00H, 's', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 0aH, 00H, 00H, 00H
	ORG $+10
$SG84485 DB	0aH, 00H, 0aH, 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H
	DB	'a', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r'
	DB	00H, 'm', 00H, 'a', 00H, 't', 00H, ' ', 00H, 'n', 00H, 'o', 00H
	DB	't', 00H, ' ', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd'
	DB	00H, ':', 00H, ' ', 00H, '%', 00H, 's', 00H, 0aH, 00H, 00H, 00H
$SG84487 DB	0aH, 00H, 0aH, 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H
	DB	'a', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r'
	DB	00H, 'm', 00H, 'a', 00H, 't', 00H, ' ', 00H, 'n', 00H, 'o', 00H
	DB	't', 00H, ' ', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd'
	DB	00H, ':', 00H, ' ', 00H, '%', 00H, 's', 00H, 0aH, 00H, 00H, 00H
$SG84495 DB	0aH, 00H, 0aH, 00H, 'M', 00H, 'i', 00H, 's', 00H, 's', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'p', 00H, 'a', 00H, 'r'
	DB	00H, 'a', 00H, 'm', 00H, 'e', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	'(', 00H, 's', 00H, ')', 00H, 0aH, 00H, 00H, 00H
$SG84497 DB	0aH, 00H, 0aH, 00H, 'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H
	DB	'l', 00H, 'i', 00H, 'd', 00H, ' ', 00H, 's', 00H, 'u', 00H, 'b'
	DB	00H, 'f', 00H, 'u', 00H, 'n', 00H, 'c', 00H, 't', 00H, 'i', 00H
	DB	'o', 00H, 'n', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e'
	DB	00H, ':', 00H, ' ', 00H, '%', 00H, 's', 00H, 0aH, 00H, 00H, 00H
$SG84500 DB	0aH, 00H, 0aH, 00H, 'M', 00H, 'i', 00H, 's', 00H, 's', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'p', 00H, 'a', 00H, 'r'
	DB	00H, 'a', 00H, 'm', 00H, 'e', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	'(', 00H, 's', 00H, ')', 00H, 0aH, 00H, 00H, 00H
$SG84503 DB	0aH, 00H, 0aH, 00H, 'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H
	DB	'l', 00H, 'i', 00H, 'd', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'm'
	DB	00H, 'm', 00H, 'a', 00H, 'n', 00H, 'd', 00H, ':', 00H, ' ', 00H
	DB	'%', 00H, 's', 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG84509 DB	0aH, 00H, 0aH, 00H, 'T', 00H, 'o', 00H, ' ', 00H, 'b', 00H
	DB	'e', 00H, ' ', 00H, 'i', 00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e'
	DB	00H, 'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'd', 00H
	DB	'.', 00H, '.', 00H, '.', 00H, 0aH, 00H, 00H, 00H
$SG84520 DB	'0', 00H, 'x', 00H, '%', 00H, 'x', 00H, 00H, 00H
	ORG $+6
$SG84521 DB	0aH, 00H, 'P', 00H, 'a', 00H, 'r', 00H, 'a', 00H, 'm', 00H
	DB	'e', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'p', 00H, 'a'
	DB	00H, 'r', 00H, 's', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H
	DB	'e', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ':', 00H, ' '
	DB	00H, '%', 00H, 's', 00H, 00H, 00H
	ORG $+6
$SG84523 DB	'0', 00H, 'x', 00H, '%', 00H, 'x', 00H, 00H, 00H
	ORG $+6
$SG84524 DB	0aH, 00H, 'P', 00H, 'a', 00H, 'r', 00H, 'a', 00H, 'm', 00H
	DB	'e', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'p', 00H, 'a'
	DB	00H, 'r', 00H, 's', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H
	DB	'e', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ':', 00H, ' '
	DB	00H, '%', 00H, 's', 00H, 00H, 00H
	ORG $+6
$SG84525 DB	0aH, 00H, 'S', 00H, 'e', 00H, 't', 00H, 't', 00H, 'i', 00H
	DB	'n', 00H, 'g', 00H, ' ', 00H, 'f', 00H, 'l', 00H, 'a', 00H, 'g'
	DB	00H, 's', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'M', 00H, 'a', 00H, 'j', 00H, 'o', 00H, 'r', 00H, 'F', 00H, 'u'
	DB	00H, 'n', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H
	DB	' ', 00H, '=', 00H, ' ', 00H, '%', 00H, '#', 00H, '0', 00H, '1'
	DB	00H, '0', 00H, 'x', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H
	DB	'%', 00H, '#', 00H, '0', 00H, '1', 00H, '0', 00H, 'x', 00H, 00H
	DB	00H
$SG84548 DB	0aH, 00H, 'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T'
	DB	00H, 'L', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	':', 00H, ' ', 00H, '%', 00H, 'c', 00H, 00H, 00H
$SG84562 DB	'%', 00H, 's', 00H, 0aH, 00H, 00H, 00H
$SG84574 DB	0aH, 00H, 0aH, 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, 00H, 00H
$SG84618 DB	'%c', 00H
	ORG $+1
$SG84575 DB	0aH, 00H, 0aH, 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'd', 00H, ' ', 00H, 'I', 00H, 'R', 00H, 'P', 00H, 00H
	DB	00H
	ORG $+6
$SG84576 DB	0aH, 00H, 0aH, 00H, 'D', 00H, 'a', 00H, 't', 00H, 'a', 00H
	DB	' ', 00H, 'L', 00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h'
	DB	00H, ':', 00H, ' ', 00H, '%', 00H, '#', 00H, 'x', 00H, 00H, 00H
	ORG $+2
$SG84577 DB	0aH, 00H, 0aH, 00H, 'I', 00H, 'R', 00H, 'P', 00H, ':', 00H
	DB	0aH, 00H, 0aH, 00H, 00H, 00H
	ORG $+6
$SG84579 DB	0aH, 00H, 0aH, 00H, 'I', 00H, '/', 00H, 'O', 00H, ' ', 00H
	DB	'S', 00H, 't', 00H, 'a', 00H, 'c', 00H, 'k', 00H, ' ', 00H, 'l'
	DB	00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, ':', 00H, 0aH, 00H, 0aH, 00H, 00H, 00H
$SG84593 DB	'%', 00H, 's', 00H, 0aH, 00H, 00H, 00H
$SG84606 DB	0aH, '0x%08x -', 00H
	ORG $+2
$SG84608 DB	' %02x', 00H
	ORG $+2
$SG84610 DB	' -- ', 00H
	ORG $+7
$SG84635 DB	'x', 00H, '8', 00H, '6', 00H, 00H, 00H
$SG84638 DB	'x', 00H, '6', 00H, '4', 00H, 00H, 00H
$SG84640 DB	0aH, 00H, 'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'c'
	DB	00H, 'e', 00H, 's', 00H, 's', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H, 'i', 00H, 't', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, ':', 00H
	DB	' ', 00H, '"', 00H, '%', 00H, 's', 00H, '"', 00H, 00H, 00H
$SG84735 DB	0aH, 00H, 00H, 00H
$SG84642 DB	'w', 00H, 'x', 00H, 'p', 00H, 00H, 00H
$SG84645 DB	'w', 00H, 'l', 00H, 'h', 00H, 00H, 00H
$SG84648 DB	'w', 00H, 'i', 00H, 'n', 00H, '7', 00H, 00H, 00H
	ORG $+6
$SG84650 DB	0aH, 00H, 'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd'
	DB	00H, 'o', 00H, 'w', 00H, 's', 00H, ' ', 00H, 'V', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ':', 00H, ' '
	DB	00H, '"', 00H, '%', 00H, 's', 00H, '"', 00H, 00H, 00H
	ORG $+2
$SG84657 DB	'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	' ', 00H, 's', 00H, 'u', 00H, 'c', 00H, 'c', 00H, 'e', 00H, 's'
	DB	00H, 'f', 00H, 'u', 00H, 'l', 00H, 'l', 00H, 'y', 00H, ' ', 00H
	DB	'o', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'd', 00H, 0aH
	DB	00H, 00H, 00H
	ORG $+10
$SG84674 DB	0aH, 00H, 'G', 00H, 'e', 00H, 't', 00H, 'P', 00H, 'r', 00H
	DB	'o', 00H, 'c', 00H, 'e', 00H, 's', 00H, 's', 00H, 'H', 00H, 'e'
	DB	00H, 'a', 00H, 'p', 00H, ' ', 00H, 'f', 00H, 'a', 00H, 'i', 00H
	DB	'l', 00H, 'e', 00H, 'd', 00H, ';', 00H, ' ', 00H, 'G', 00H, 'e'
	DB	00H, 't', 00H, 'L', 00H, 'a', 00H, 's', 00H, 't', 00H, 'E', 00H
	DB	'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, '(', 00H, ')', 00H, ' '
	DB	00H, '=', 00H, ' ', 00H, '%', 00H, '#', 00H, '0', 00H, '1', 00H
	DB	'0', 00H, 'x', 00H, ' ', 00H, '(', 00H, '%', 00H, 'd', 00H, ')'
	DB	00H, 00H, 00H
	ORG $+6
$SG84685 DB	0aH, 00H, 'H', 00H, 'e', 00H, 'a', 00H, 'p', 00H, 'A', 00H
	DB	'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, ' ', 00H, 'f', 00H, 'a'
	DB	00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, 00H, 00H
$SG84737 DB	0aH, 00H, 00H, 00H
$SG84692 DB	'F', 00H, 'i', 00H, 'l', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	'M', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'D'
	DB	00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG84707 DB	'\', 00H, '\', 00H, '.', 00H, '\', 00H, '%', 00H, 's', 00H
	DB	00H, 00H
	ORG $+2
$SG84710 DB	0aH, 00H, 'O', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'D', 00H
	DB	'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, ' ', 00H, '-'
	DB	00H, ' ', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, 'C', 00H, 'b', 00H, 'P', 00H, 'r', 00H, 'i', 00H, 'n'
	DB	00H, 't', 00H, 'f', 00H, 'W', 00H, '(', 00H, ')', 00H, ' ', 00H
	DB	'r', 00H, 'e', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'n', 00H, 'e'
	DB	00H, 'd', 00H, ' ', 00H, '%', 00H, '#', 00H, 'x', 00H, 00H, 00H
	ORG $+6
$SG84718 DB	'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'o', 00H, 'b', 00H, 't'
	DB	00H, 'a', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 'f', 00H, 'i', 00H
	DB	'l', 00H, 'e', 00H, ' ', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'd'
	DB	00H, 'l', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H
	DB	'%', 00H, 'l', 00H, 's', 00H, '.', 00H, ' ', 00H, 'G', 00H, 'e'
	DB	00H, 't', 00H, 'L', 00H, 'a', 00H, 's', 00H, 't', 00H, 'E', 00H
	DB	'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, '(', 00H, ')', 00H, ' '
	DB	00H, '=', 00H, ' ', 00H, '%', 00H, 'd', 00H, ' ', 00H, '(', 00H
	DB	'0', 00H, 'x', 00H, '%', 00H, 'x', 00H, ')', 00H, 0aH, 00H, 00H
	DB	00H
	ORG $+2
$SG84723 DB	'n', 00H, 'o', 00H, 00H, 00H
	ORG $+6
$SG84724 DB	'y', 00H, 'e', 00H, 's', 00H, 00H, 00H
$SG84725 DB	0aH, 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'l', 00H
	DB	'e', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'd', 00H, 'a', 00H, 't'
	DB	00H, 'a', 00H, ':', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, '%', 00H, 's', 00H, 0aH, 00H, 00H
	DB	00H
$SG84752 DB	0aH, 00H, 00H, 00H
$SG84726 DB	0aH, 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	' ', 00H, 'n', 00H, 'e', 00H, 'e', 00H, 'd', 00H, 'e', 00H, 'd'
	DB	00H, ':', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, '%', 00H, 'd', 00H, 0aH, 00H, 00H
	DB	00H
	ORG $+4
$SG84730 DB	0aH, 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H
	DB	'e', 00H, ':', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, '%', 00H, 's', 00H
	DB	0aH, 00H, 00H, 00H
	ORG $+6
$SG84731 DB	'T', 00H, 'e', 00H, 'x', 00H, 't', 00H, ':', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	'%', 00H, 's', 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG84732 DB	'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	' ', 00H, 'I', 00H, 'D', 00H, ':', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	'%', 00H, 's', 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG84733 DB	'I', 00H, 'n', 00H, 's', 00H, 't', 00H, 'a', 00H, 'n', 00H
	DB	'c', 00H, 'e', 00H, ' ', 00H, 'I', 00H, 'D', 00H, ':', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	'%', 00H, 's', 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG84734 DB	'H', 00H, 'a', 00H, 'r', 00H, 'd', 00H, 'w', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, ' ', 00H, 'I', 00H, 'D', 00H, 's', 00H, ':'
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	00H, 00H
$SG84736 DB	'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't', 00H
	DB	'i', 00H, 'b', 00H, 'l', 00H, 'e', 00H, ' ', 00H, 'I', 00H, 'D'
	DB	00H, 's', 00H, ':', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	00H, 00H
$SG84739 DB	0aH, 00H, 0aH, 00H, 'U', 00H, 's', 00H, 'a', 00H, 'g', 00H
	DB	'e', 00H, ':', 00H, 00H, 00H
	ORG $+6
$SG84740 DB	0aH, 00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	'L', 00H, 'i', 00H, 's', 00H, 't', 00H, ' ', 00H, 'd', 00H, 'e'
	DB	00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, ':', 00H
	DB	00H, 00H
$SG84741 DB	0aH, 00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'T', 00H, 'e', 00H, 's'
	DB	00H, 't', 00H, 'C', 00H, 'l', 00H, 't', 00H, ' ', 00H, '/', 00H
	DB	'l', 00H, 00H, 00H
	ORG $+14
$SG84742 DB	0aH, 00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	'S', 00H, 'e', 00H, 't', 00H, ' ', 00H, 'f', 00H, 'l', 00H, 'a'
	DB	00H, 'g', 00H, 's', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, 'I', 00H, 'R', 00H, 'P', 00H, ' ', 00H, 'm', 00H, 'a'
	DB	00H, 'j', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'f', 00H, 'u', 00H
	DB	'n', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' '
	DB	00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, ':', 00H, 00H, 00H
	ORG $+6
$SG84743 DB	0aH, 00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'T', 00H, 'e', 00H, 's'
	DB	00H, 't', 00H, 'C', 00H, 'l', 00H, 't', 00H, ' ', 00H, '/', 00H
	DB	'c', 00H, ' ', 00H, 's', 00H, ' ', 00H, 'm', 00H, 'a', 00H, 'j'
	DB	00H, 'o', 00H, 'r', 00H, '_', 00H, 'f', 00H, 'u', 00H, 'n', 00H
	DB	'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 'f'
	DB	00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H, ' ', 00H, 's', 00H
	DB	'y', 00H, 'm', 00H, 'b', 00H, 'o', 00H, 'l', 00H, 'i', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'i', 00H, 'n', 00H, 'k', 00H, 00H, 00H
$SG84761 DB	',', 00H, ' ', 00H, 00H, 00H
	ORG $+6
$SG84744 DB	0aH, 00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, 'm', 00H, 'a', 00H, 'j', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'f', 00H, 'u', 00H, 'n', 00H, 'c', 00H, 't', 00H, 'i'
	DB	00H, 'o', 00H, 'n', 00H, ':', 00H, ' ', 00H, 'I', 00H, 'R', 00H
	DB	'P', 00H, ' ', 00H, 'm', 00H, 'a', 00H, 'j', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, 'f', 00H, 'u', 00H, 'n', 00H, 'c', 00H, 't', 00H
	DB	'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'd'
	DB	00H, 'e', 00H, ' ', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 'h', 00H
	DB	'e', 00H, 'x', 00H, 00H, 00H
	ORG $+6
$SG84745 DB	0aH, 00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, 'f', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ':', 00H, ' ', 00H, 'f', 00H, 'l', 00H
	DB	'a', 00H, 'g', 00H, 's', 00H, ' ', 00H, 'v', 00H, 'a', 00H, 'l'
	DB	00H, 'u', 00H, 'e', 00H, ' ', 00H, 'i', 00H, 'n', 00H, ' ', 00H
	DB	'h', 00H, 'e', 00H, 'x', 00H, 00H, 00H
	ORG $+14
$SG84746 DB	0aH, 00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, 's', 00H, 'y', 00H, 'm', 00H, 'b', 00H, 'o', 00H
	DB	'l', 00H, 'i', 00H, 'c', 00H, '_', 00H, 'l', 00H, 'i', 00H, 'n'
	DB	00H, 'k', 00H, ' ', 00H, ':', 00H, ' ', 00H, 's', 00H, 'y', 00H
	DB	'm', 00H, ' ', 00H, 'l', 00H, 'i', 00H, 'n', 00H, 'k', 00H, ' '
	DB	00H, 'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 't', 00H, 'h', 00H
	DB	'e', 00H, ' ', 00H, 'F', 00H, 'A', 00H, ' ', 00H, 'd', 00H, 'e'
	DB	00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 00H, 00H
	ORG $+6
$SG84747 DB	0aH, 00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	'G', 00H, 'e', 00H, 't', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'p', 00H, 't', 00H
	DB	'e', 00H, 'd', 00H, ' ', 00H, 'd', 00H, 'a', 00H, 't', 00H, 'a'
	DB	00H, ':', 00H, 00H, 00H
$SG84748 DB	0aH, 00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'T', 00H, 'e', 00H, 's'
	DB	00H, 't', 00H, 'C', 00H, 'l', 00H, 't', 00H, ' ', 00H, '/', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H, 'i'
	DB	00H, 't', 00H, ' ', 00H, 'o', 00H, 's', 00H, 'v', 00H, 'e', 00H
	DB	'r', 00H, ' ', 00H, 's', 00H, 'y', 00H, 'm', 00H, 'b', 00H, 'o'
	DB	00H, 'l', 00H, 'i', 00H, 'c', 00H, '_', 00H, 'l', 00H, 'i', 00H
	DB	'n', 00H, 'k', 00H, 00H, 00H
$SG84749 DB	0aH, 00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H, 'i', 00H
	DB	't', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ':', 00H, ' ', 00H, 'p', 00H, 'r', 00H
	DB	'o', 00H, 'c', 00H, 'e', 00H, 's', 00H, 's', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e'
	DB	00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H, '6', 00H, ',', 00H
	DB	' ', 00H, 'x', 00H, '6', 00H, '4', 00H, ')', 00H, 00H, 00H
$SG84750 DB	0aH, 00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, 'o', 00H, 's', 00H, 'v', 00H, 'e', 00H, 'r', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ':', 00H, ' ', 00H, 'w', 00H, 'i', 00H
	DB	'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 's', 00H, ' ', 00H, 'v'
	DB	00H, 'e', 00H, 'r', 00H, 's', 00H, 'i', 00H, 'o', 00H, 'n', 00H
	DB	' ', 00H, '(', 00H, 'w', 00H, 'x', 00H, 'p', 00H, ',', 00H, ' '
	DB	00H, 'v', 00H, 'i', 00H, 's', 00H, 't', 00H, 'a', 00H, ',', 00H
	DB	' ', 00H, 'w', 00H, 'i', 00H, 'n', 00H, '7', 00H, ')', 00H, 00H
	DB	00H
	ORG $+14
$SG84751 DB	0aH, 00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, 's', 00H, 'y', 00H, 'm', 00H, 'b', 00H, 'o', 00H
	DB	'l', 00H, 'i', 00H, 'c', 00H, '_', 00H, 'l', 00H, 'i', 00H, 'n'
	DB	00H, 'k', 00H, ' ', 00H, ':', 00H, ' ', 00H, 's', 00H, 'y', 00H
	DB	'm', 00H, ' ', 00H, 'l', 00H, 'i', 00H, 'n', 00H, 'k', 00H, ' '
	DB	00H, 'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 't', 00H, 'h', 00H
	DB	'e', 00H, ' ', 00H, 'F', 00H, 'A', 00H, ' ', 00H, 'd', 00H, 'e'
	DB	00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 00H, 00H
	ORG $+14
$SG84779 DB	'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 's', 00H, 'e', 00H, 'n'
	DB	00H, 'd', 00H, ' ', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '.', 00H, ' ', 00H, 'C', 00H, 'o', 00H, 'd', 00H, 'e'
	DB	00H, ':', 00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H, '8', 00H
	DB	'x', 00H, ',', 00H, ' ', 00H, 'G', 00H, 'e', 00H, 't', 00H, 'L'
	DB	00H, 'a', 00H, 's', 00H, 't', 00H, 'E', 00H, 'r', 00H, 'r', 00H
	DB	'o', 00H, 'r', 00H, '(', 00H, ')', 00H, ' ', 00H, '=', 00H, ' '
	DB	00H, '0', 00H, 'x', 00H, '%', 00H, '8', 00H, 'x', 00H, ',', 00H
	DB	' ', 00H, '(', 00H, '%', 00H, 'i', 00H, ')', 00H, 00H, 00H
_DATA	ENDS
PUBLIC	GetData
PUBLIC	DeviceControl
PUBLIC	ListDevices
PUBLIC	PrintHelp
PUBLIC	CheckParams
PUBLIC	wmain
EXTRN	wprintf:PROC
pdata	SEGMENT
$pdata$wmain DD	imagerel $LN11
	DD	imagerel $LN11+241
	DD	imagerel $unwind$wmain
pdata	ENDS
xdata	SEGMENT
$unwind$wmain DD 011201H
	DD	06212H
; Function compile flags: /Odtp
; File b:\programm\wntsys\testfilter\release\1_1\source\testclt\testclt.c
xdata	ENDS
_TEXT	SEGMENT
function$ = 32
RetCode$ = 36
tv75 = 40
argC$ = 64
lpwszArgV$ = 72
lpwszEnvV$ = 80
wmain	PROC

; 134  : int wmain( int argC, wchar_t *lpwszArgV[], wchar_t *lpwszEnvV[]) {

$LN11:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 135  : 
; 136  : 
; 137  : 	wchar_t	function;
; 138  : 	int		RetCode;
; 139  : 
; 140  : 	wprintf(L"\nTest client, compiled %S %S\n\n",__DATE__, __TIME__);

	lea	r8, OFFSET FLAT:$SG84463
	lea	rdx, OFFSET FLAT:$SG84464
	lea	rcx, OFFSET FLAT:$SG84465
	call	wprintf

; 141  : 
; 142  : 	if (!CheckParams(argC, lpwszArgV)) {

	mov	rdx, QWORD PTR lpwszArgV$[rsp]
	mov	ecx, DWORD PTR argC$[rsp]
	call	CheckParams
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN8@wmain

; 143  : 		PrintHelp();

	call	PrintHelp

; 144  : 		return CLT_ERROR;

	mov	eax, 100				; 00000064H
	jmp	$LN9@wmain
$LN8@wmain:

; 145  : 	}
; 146  : 	function = *(lpwszArgV[1] + 1);

	mov	rax, QWORD PTR lpwszArgV$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, WORD PTR [rax+2]
	mov	WORD PTR function$[rsp], ax

; 147  : 	switch (function) {

	movzx	eax, WORD PTR function$[rsp]
	mov	DWORD PTR tv75[rsp], eax
	cmp	DWORD PTR tv75[rsp], 99			; 00000063H
	je	SHORT $LN4@wmain
	cmp	DWORD PTR tv75[rsp], 100		; 00000064H
	je	SHORT $LN3@wmain
	cmp	DWORD PTR tv75[rsp], 104		; 00000068H
	je	SHORT $LN2@wmain
	cmp	DWORD PTR tv75[rsp], 108		; 0000006cH
	je	SHORT $LN5@wmain
	jmp	SHORT $LN1@wmain
$LN5@wmain:

; 148  : 		case CLTFUN_LIST:
; 149  : 			RetCode = ListDevices();

	call	ListDevices
	mov	DWORD PTR RetCode$[rsp], eax

; 150  : 			break;

	jmp	SHORT $LN6@wmain
$LN4@wmain:

; 151  : 		case CLTFUN_CONTROL:
; 152  : 			RetCode = DeviceControl(argC, lpwszArgV);

	mov	rdx, QWORD PTR lpwszArgV$[rsp]
	mov	ecx, DWORD PTR argC$[rsp]
	call	DeviceControl
	mov	DWORD PTR RetCode$[rsp], eax

; 153  : 			break;

	jmp	SHORT $LN6@wmain
$LN3@wmain:

; 154  : 		case CLTFUN_GETDATA:
; 155  : 			RetCode = GetData(argC, lpwszArgV);

	mov	rdx, QWORD PTR lpwszArgV$[rsp]
	mov	ecx, DWORD PTR argC$[rsp]
	call	GetData
	mov	DWORD PTR RetCode$[rsp], eax

; 156  : 			break;

	jmp	SHORT $LN6@wmain
$LN2@wmain:

; 157  : 		case CLTFUN_HELP:
; 158  : 			PrintHelp();

	call	PrintHelp

; 159  : 			RetCode = 0;

	mov	DWORD PTR RetCode$[rsp], 0

; 160  : 			break;

	jmp	SHORT $LN6@wmain
$LN1@wmain:

; 161  : 		default:
; 162  : 			wprintf(L"\nInvalid command: %s", lpwszArgV[1]);

	mov	rdx, QWORD PTR lpwszArgV$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, OFFSET FLAT:$SG84476
	call	wprintf

; 163  : 			RetCode = CLT_ERROR;

	mov	DWORD PTR RetCode$[rsp], 100		; 00000064H
$LN6@wmain:

; 164  : 	}
; 165  : 	return RetCode;

	mov	eax, DWORD PTR RetCode$[rsp]
$LN9@wmain:

; 166  : }

	add	rsp, 56					; 00000038H
	ret	0
wmain	ENDP
_TEXT	ENDS
EXTRN	wcslen:PROC
pdata	SEGMENT
$pdata$CheckParams DD imagerel $LN16
	DD	imagerel $LN16+349
	DD	imagerel $unwind$CheckParams
pdata	ENDS
xdata	SEGMENT
$unwind$CheckParams DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
_TEXT	SEGMENT
tv83 = 32
argC$ = 64
lpwszArgV$ = 72
CheckParams PROC

; 188  : {

$LN16:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 189  : 	if (argC < 2) {

	cmp	DWORD PTR argC$[rsp], 2
	jge	SHORT $LN13@CheckParam

; 190  : 		wprintf(L"\n\nCommand missing\n");

	lea	rcx, OFFSET FLAT:$SG84483
	call	wprintf

; 191  : 		return FALSE;

	xor	al, al
	jmp	$LN14@CheckParam
$LN13@CheckParam:

; 192  : 	}
; 193  : 	if (wcslen(lpwszArgV[1]) != 2) {

	mov	rcx, QWORD PTR lpwszArgV$[rsp]
	mov	rcx, QWORD PTR [rcx+8]
	call	wcslen
	cmp	rax, 2
	je	SHORT $LN12@CheckParam

; 194  : 		wprintf(L"\n\nCommand format not valid: %s\n", lpwszArgV[1]);

	mov	rdx, QWORD PTR lpwszArgV$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, OFFSET FLAT:$SG84485
	call	wprintf

; 195  : 		return FALSE;

	xor	al, al
	jmp	$LN14@CheckParam
$LN12@CheckParam:

; 196  : 	}
; 197  : 	if (*lpwszArgV[1] != L'/') {

	mov	rax, QWORD PTR lpwszArgV$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN11@CheckParam

; 198  : 		wprintf(L"\n\nCommand format not valid: %s\n", lpwszArgV[1]);

	mov	rdx, QWORD PTR lpwszArgV$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, OFFSET FLAT:$SG84487
	call	wprintf

; 199  : 		return FALSE;

	xor	al, al
	jmp	$LN14@CheckParam
$LN11@CheckParam:

; 200  : 	}
; 201  : 	switch (*(lpwszArgV[1] + 1)) {

	mov	rax, QWORD PTR lpwszArgV$[rsp]
	mov	rax, QWORD PTR [rax+8]
	movzx	eax, WORD PTR [rax+2]
	mov	DWORD PTR tv83[rsp], eax
	cmp	DWORD PTR tv83[rsp], 99			; 00000063H
	je	SHORT $LN7@CheckParam
	cmp	DWORD PTR tv83[rsp], 100		; 00000064H
	je	SHORT $LN4@CheckParam
	cmp	DWORD PTR tv83[rsp], 104		; 00000068H
	je	$LN2@CheckParam
	cmp	DWORD PTR tv83[rsp], 108		; 0000006cH
	je	SHORT $LN8@CheckParam
	jmp	$LN1@CheckParam
$LN8@CheckParam:

; 202  : 		case CLTFUN_LIST:
; 203  : 			return TRUE;

	mov	al, 1
	jmp	$LN14@CheckParam

; 204  : 			break;

	jmp	$LN9@CheckParam
$LN7@CheckParam:

; 205  : 		case CLTFUN_CONTROL:
; 206  : 			if (argC < 5) {

	cmp	DWORD PTR argC$[rsp], 5
	jge	SHORT $LN6@CheckParam

; 207  : 				wprintf(L"\n\nMissing parameter(s)\n");

	lea	rcx, OFFSET FLAT:$SG84495
	call	wprintf

; 208  : 				return FALSE;

	xor	al, al
	jmp	SHORT $LN14@CheckParam
$LN6@CheckParam:

; 209  : 			}
; 210  : 			if ((*lpwszArgV[2] != CONTROL_SUBFUNC_GET) &&
; 211  : 				(*lpwszArgV[2] != CONTROL_SUBFUNC_SET)) {

	mov	rax, QWORD PTR lpwszArgV$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 103				; 00000067H
	je	SHORT $LN5@CheckParam
	mov	rax, QWORD PTR lpwszArgV$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, WORD PTR [rax]
	cmp	eax, 115				; 00000073H
	je	SHORT $LN5@CheckParam

; 212  : 				wprintf(L"\n\nInvalid subfunction code: %s\n",
; 213  : 					lpwszArgV[2]);

	mov	rdx, QWORD PTR lpwszArgV$[rsp]
	mov	rdx, QWORD PTR [rdx+16]
	lea	rcx, OFFSET FLAT:$SG84497
	call	wprintf

; 214  : 				return FALSE;

	xor	al, al
	jmp	SHORT $LN14@CheckParam
$LN5@CheckParam:

; 215  : 			}
; 216  : 			return TRUE;

	mov	al, 1
	jmp	SHORT $LN14@CheckParam

; 217  : 			break;

	jmp	SHORT $LN9@CheckParam
$LN4@CheckParam:

; 218  : 		case CLTFUN_GETDATA:
; 219  : 			if (argC < 4) {

	cmp	DWORD PTR argC$[rsp], 4
	jge	SHORT $LN3@CheckParam

; 220  : 				wprintf(L"\n\nMissing parameter(s)\n");

	lea	rcx, OFFSET FLAT:$SG84500
	call	wprintf

; 221  : 				return FALSE;

	xor	al, al
	jmp	SHORT $LN14@CheckParam
$LN3@CheckParam:

; 222  : 			}
; 223  : 			return TRUE;

	mov	al, 1
	jmp	SHORT $LN14@CheckParam

; 224  : 			break;

	jmp	SHORT $LN9@CheckParam
$LN2@CheckParam:

; 225  : 		case CLTFUN_HELP:
; 226  : 			return TRUE;

	mov	al, 1
	jmp	SHORT $LN14@CheckParam

; 227  : 			break;

	jmp	SHORT $LN9@CheckParam
$LN1@CheckParam:

; 228  : 		default:
; 229  : 			wprintf(L"\n\nInvalid command: %s\n", lpwszArgV[1]);

	mov	rdx, QWORD PTR lpwszArgV$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, OFFSET FLAT:$SG84503
	call	wprintf

; 230  : 			return FALSE;

	xor	al, al
$LN9@CheckParam:
$LN14@CheckParam:

; 231  : 	}
; 232  : }

	add	rsp, 56					; 00000038H
	ret	0
CheckParams ENDP
_TEXT	ENDS
PUBLIC	DCGetMJFFlags
pdata	SEGMENT
$pdata$DCGetMJFFlags DD imagerel $LN3
	DD	imagerel $LN3+35
	DD	imagerel $unwind$DCGetMJFFlags
pdata	ENDS
xdata	SEGMENT
$unwind$DCGetMJFFlags DD 010d01H
	DD	0420dH
; Function compile flags: /Odtp
xdata	ENDS
_TEXT	SEGMENT
argC$ = 48
lpwszArgV$ = 56
DCGetMJFFlags PROC

; 249  : {

$LN3:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 40					; 00000028H

; 250  : 	wprintf(L"\n\nTo be implemented...\n");

	lea	rcx, OFFSET FLAT:$SG84509
	call	wprintf

; 251  : 	return CLT_ERROR;

	mov	eax, 100				; 00000064H

; 252  : }

	add	rsp, 40					; 00000028H
	ret	0
DCGetMJFFlags ENDP
_TEXT	ENDS
PUBLIC	SendIoCtl
PUBLIC	OpenDevice
PUBLIC	DCSetMJFFlags
EXTRN	swscanf_s:PROC
pdata	SEGMENT
$pdata$DCSetMJFFlags DD imagerel $LN8
	DD	imagerel $LN8+274
	DD	imagerel $unwind$DCSetMJFFlags
pdata	ENDS
xdata	SEGMENT
$unwind$DCSetMJFFlags DD 010d01H
	DD	0a20dH
; Function compile flags: /Odtp
xdata	ENDS
_TEXT	SEGMENT
iMajFun$ = 48
iFlags$ = 52
hFA$ = 56
MJFCtl$ = 64
argC$ = 96
lpwszArgV$ = 104
DCSetMJFFlags PROC

; 269  : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 88					; 00000058H

; 270  : 	// lpwszArgV[3] = MajorFunction
; 271  : 	// lpwszArgV[4] = flags
; 272  : 	// lpwszArgV[5] = device name
; 273  : 
; 274  : 	HANDLE		hFA;
; 275  : 	int			iMajFun;
; 276  : 	int			iFlags;
; 277  : 	MJF_CONTROL MJFCtl;
; 278  : 
; 279  : 	if (swscanf_s(lpwszArgV[3], L"0x%x", &iMajFun) != 1) {

	lea	r8, QWORD PTR iMajFun$[rsp]
	lea	rdx, OFFSET FLAT:$SG84520
	mov	rcx, QWORD PTR lpwszArgV$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	call	swscanf_s
	cmp	eax, 1
	je	SHORT $LN5@DCSetMJFFl

; 280  : 		wprintf(L"\nParameter parsing error: %s", lpwszArgV[3]);

	mov	rdx, QWORD PTR lpwszArgV$[rsp]
	mov	rdx, QWORD PTR [rdx+24]
	lea	rcx, OFFSET FLAT:$SG84521
	call	wprintf

; 281  : 		return CLT_ERROR;

	mov	eax, 100				; 00000064H
	jmp	$LN6@DCSetMJFFl
$LN5@DCSetMJFFl:

; 282  : 	}
; 283  : 	if (swscanf_s(lpwszArgV[4], L"0x%x", &iFlags) != 1) {

	lea	r8, QWORD PTR iFlags$[rsp]
	lea	rdx, OFFSET FLAT:$SG84523
	mov	rcx, QWORD PTR lpwszArgV$[rsp]
	mov	rcx, QWORD PTR [rcx+32]
	call	swscanf_s
	cmp	eax, 1
	je	SHORT $LN4@DCSetMJFFl

; 284  : 		wprintf(L"\nParameter parsing error: %s", lpwszArgV[4]);

	mov	rdx, QWORD PTR lpwszArgV$[rsp]
	mov	rdx, QWORD PTR [rdx+32]
	lea	rcx, OFFSET FLAT:$SG84524
	call	wprintf

; 285  : 		return CLT_ERROR;

	mov	eax, 100				; 00000064H
	jmp	$LN6@DCSetMJFFl
$LN4@DCSetMJFFl:

; 286  : 	}
; 287  : 	wprintf(L"\nSetting flags for MajorFunction = %#010x to %#010x",
; 288  : 		iMajFun,
; 289  : 		iFlags);

	mov	r8d, DWORD PTR iFlags$[rsp]
	mov	edx, DWORD PTR iMajFun$[rsp]
	lea	rcx, OFFSET FLAT:$SG84525
	call	wprintf

; 290  : 	MJFCtl.MajorFunction = (UCHAR) iMajFun;

	movzx	r11d, BYTE PTR iMajFun$[rsp]
	mov	BYTE PTR MJFCtl$[rsp], r11b

; 291  : 	MJFCtl.dwFlags = (DWORD) iFlags;

	mov	eax, DWORD PTR iFlags$[rsp]
	mov	DWORD PTR MJFCtl$[rsp+4], eax

; 292  : 	hFA = OpenDevice(lpwszArgV[5]);

	mov	rcx, QWORD PTR lpwszArgV$[rsp]
	mov	rcx, QWORD PTR [rcx+40]
	call	OpenDevice
	mov	QWORD PTR hFA$[rsp], rax

; 293  : 	if (hFA == INVALID_HANDLE_VALUE) return CLT_ERROR;

	cmp	QWORD PTR hFA$[rsp], -1
	jne	SHORT $LN3@DCSetMJFFl
	mov	eax, 100				; 00000064H
	jmp	SHORT $LN6@DCSetMJFFl
$LN3@DCSetMJFFl:

; 294  : 	if (!SendIoCtl(hFA, IOCTL_FILTER_SET_MJF_FLAGS, &MJFCtl, 
; 295  : 		sizeof MJFCtl, NULL, 0)) {

	mov	DWORD PTR [rsp+40], 0
	mov	QWORD PTR [rsp+32], 0
	mov	r9d, 8
	lea	r8, QWORD PTR MJFCtl$[rsp]
	mov	edx, 2269188				; 0022a004H
	mov	rcx, QWORD PTR hFA$[rsp]
	call	SendIoCtl
	test	eax, eax
	jne	SHORT $LN2@DCSetMJFFl

; 296  : 		return CLT_ERROR;

	mov	eax, 100				; 00000064H
	jmp	SHORT $LN6@DCSetMJFFl

; 297  : 	} else {

	jmp	SHORT $LN1@DCSetMJFFl
$LN2@DCSetMJFFl:

; 298  : 		return 0;

	xor	eax, eax
$LN1@DCSetMJFFl:
$LN6@DCSetMJFFl:

; 299  : 	}
; 300  : 
; 301  : }

	add	rsp, 88					; 00000058H
	ret	0
DCSetMJFFlags ENDP
_TEXT	ENDS
pdata	SEGMENT
$pdata$DeviceControl DD imagerel $LN8
	DD	imagerel $LN8+129
	DD	imagerel $unwind$DeviceControl
pdata	ENDS
xdata	SEGMENT
$unwind$DeviceControl DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
_TEXT	SEGMENT
IoCtl$ = 32
ret$ = 36
tv67 = 40
argC$ = 64
lpwszArgV$ = 72
DeviceControl PROC

; 318  : {

$LN8:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 56					; 00000038H

; 319  : 	int ret;
; 320  : 	WCHAR	IoCtl;
; 321  : 	IoCtl = *lpwszArgV[2];

	mov	rax, QWORD PTR lpwszArgV$[rsp]
	mov	rax, QWORD PTR [rax+16]
	movzx	eax, WORD PTR [rax]
	mov	WORD PTR IoCtl$[rsp], ax

; 322  : 
; 323  : 	switch (IoCtl) {

	movzx	eax, WORD PTR IoCtl$[rsp]
	mov	DWORD PTR tv67[rsp], eax
	cmp	DWORD PTR tv67[rsp], 103		; 00000067H
	je	SHORT $LN3@DeviceCont
	cmp	DWORD PTR tv67[rsp], 115		; 00000073H
	je	SHORT $LN2@DeviceCont
	jmp	SHORT $LN1@DeviceCont
$LN3@DeviceCont:

; 324  : 		case CONTROL_SUBFUNC_GET:
; 325  : 			ret = DCGetMJFFlags(argC, lpwszArgV);

	mov	rdx, QWORD PTR lpwszArgV$[rsp]
	mov	ecx, DWORD PTR argC$[rsp]
	call	DCGetMJFFlags
	mov	DWORD PTR ret$[rsp], eax

; 326  : 			break;

	jmp	SHORT $LN4@DeviceCont
$LN2@DeviceCont:

; 327  : 		case CONTROL_SUBFUNC_SET:
; 328  : 			ret = DCSetMJFFlags(argC, lpwszArgV);

	mov	rdx, QWORD PTR lpwszArgV$[rsp]
	mov	ecx, DWORD PTR argC$[rsp]
	call	DCSetMJFFlags
	mov	DWORD PTR ret$[rsp], eax

; 329  : 			break;

	jmp	SHORT $LN4@DeviceCont
$LN1@DeviceCont:

; 330  : 		default:
; 331  : 			wprintf(L"\nInvalid IOCTL code: %c", IoCtl);

	movzx	edx, WORD PTR IoCtl$[rsp]
	lea	rcx, OFFSET FLAT:$SG84548
	call	wprintf

; 332  : 			ret = CLT_ERROR;

	mov	DWORD PTR ret$[rsp], 100		; 00000064H
$LN4@DeviceCont:

; 333  : 	}
; 334  : 	return ret;

	mov	eax, DWORD PTR ret$[rsp]

; 335  : }

	add	rsp, 56					; 00000038H
	ret	0
DeviceControl ENDP
_TEXT	ENDS
PUBLIC	DumpIoStackLocData
EXTRN	FreeFmtStack:PROC
EXTRN	FormatIoStack:PROC
pdata	SEGMENT
$pdata$DumpIoStackLocData DD imagerel $LN7
	DD	imagerel $LN7+133
	DD	imagerel $unwind$DumpIoStackLocData
pdata	ENDS
xdata	SEGMENT
$unwind$DumpIoStackLocData DD 011201H
	DD	06212H
; Function compile flags: /Odtp
xdata	ENDS
_TEXT	SEGMENT
pScan$ = 32
pFStack$ = 40
pStackData$ = 64
Arch$ = 72
OsVer$ = 80
DumpIoStackLocData PROC

; 354  : {

$LN7:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 355  : 	PWCHAR		pFStack, pScan;
; 356  : 	if (FormatIoStack(pStackData, &pFStack, Arch, OsVer)) {

	mov	r9d, DWORD PTR OsVer$[rsp]
	mov	r8d, DWORD PTR Arch$[rsp]
	lea	rdx, QWORD PTR pFStack$[rsp]
	mov	rcx, QWORD PTR pStackData$[rsp]
	call	FormatIoStack
	test	eax, eax
	je	SHORT $LN4@DumpIoStac

; 357  : 		for (pScan = pFStack;*pScan != L'\0';pScan += wcslen(pScan) + 1) {

	mov	rax, QWORD PTR pFStack$[rsp]
	mov	QWORD PTR pScan$[rsp], rax
	jmp	SHORT $LN3@DumpIoStac
$LN2@DumpIoStac:
	mov	rcx, QWORD PTR pScan$[rsp]
	call	wcslen
	mov	r11, rax
	mov	rax, QWORD PTR pScan$[rsp]
	lea	rax, QWORD PTR [rax+r11*2+2]
	mov	QWORD PTR pScan$[rsp], rax
$LN3@DumpIoStac:
	mov	rax, QWORD PTR pScan$[rsp]
	movzx	eax, WORD PTR [rax]
	test	eax, eax
	je	SHORT $LN1@DumpIoStac

; 358  : 			wprintf(L"%s\n", pScan);

	mov	rdx, QWORD PTR pScan$[rsp]
	lea	rcx, OFFSET FLAT:$SG84562
	call	wprintf

; 359  : 		}

	jmp	SHORT $LN2@DumpIoStac
$LN1@DumpIoStac:

; 360  : 		FreeFmtStack(pFStack);

	mov	rcx, QWORD PTR pFStack$[rsp]
	call	FreeFmtStack
$LN4@DumpIoStac:

; 361  : 	}
; 362  : 	return;
; 363  : }

	add	rsp, 56					; 00000038H
	ret	0
DumpIoStackLocData ENDP
_TEXT	ENDS
PUBLIC	DumpMemory
PUBLIC	DumpIrpData
PUBLIC	DumpIrp
EXTRN	IoStackSize:PROC
EXTRN	IrpSize:PROC
EXTRN	memcpy:PROC
pdata	SEGMENT
$pdata$DumpIrp DD imagerel $LN3
	DD	imagerel $LN3+267
	DD	imagerel $unwind$DumpIrp
pdata	ENDS
xdata	SEGMENT
$unwind$DumpIrp DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
_TEXT	SEGMENT
offset$ = 32
IrpHea$ = 40
pIrpData$ = 80
len$ = 88
Arch$ = 96
OsVer$ = 104
DumpIrp	PROC

; 373  : {

$LN3:
	mov	DWORD PTR [rsp+32], r9d
	mov	DWORD PTR [rsp+24], r8d
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 374  : 	IRP_HEADER	IrpHea;
; 375  : 	SIZE_T		offset;
; 376  : 
; 377  : 	memcpy(&IrpHea, pIrpData, sizeof IrpHea);

	mov	r8d, 16
	mov	rdx, QWORD PTR pIrpData$[rsp]
	lea	rcx, QWORD PTR IrpHea$[rsp]
	call	memcpy

; 378  : 	wprintf(L"\n\n---------------------------------------");

	lea	rcx, OFFSET FLAT:$SG84574
	call	wprintf

; 379  : 	wprintf(L"\n\nTraced IRP");

	lea	rcx, OFFSET FLAT:$SG84575
	call	wprintf

; 380  : 	wprintf(L"\n\nData Length: %#x", IrpHea.cbDataLen);

	mov	rdx, QWORD PTR IrpHea$[rsp+8]
	lea	rcx, OFFSET FLAT:$SG84576
	call	wprintf

; 381  : 	wprintf(L"\n\nIRP:\n\n");

	lea	rcx, OFFSET FLAT:$SG84577
	call	wprintf

; 382  : 	offset = sizeof(IRP_HEADER);

	mov	QWORD PTR offset$[rsp], 16

; 383  : 	DumpIrpData(pIrpData + offset, Arch, OsVer);

	mov	rax, QWORD PTR offset$[rsp]
	mov	rcx, QWORD PTR pIrpData$[rsp]
	add	rcx, rax
	mov	r8d, DWORD PTR OsVer$[rsp]
	mov	edx, DWORD PTR Arch$[rsp]
	call	DumpIrpData

; 384  : 	offset += IrpSize(Arch, OsVer);

	mov	edx, DWORD PTR OsVer$[rsp]
	mov	ecx, DWORD PTR Arch$[rsp]
	call	IrpSize
	mov	r11, rax
	mov	rax, QWORD PTR offset$[rsp]
	add	rax, r11
	mov	QWORD PTR offset$[rsp], rax

; 385  : 	wprintf(L"\n\nI/O Stack location:\n\n");

	lea	rcx, OFFSET FLAT:$SG84579
	call	wprintf

; 386  : 	DumpIoStackLocData(pIrpData + offset, Arch, OsVer);

	mov	r11, QWORD PTR offset$[rsp]
	mov	rcx, QWORD PTR pIrpData$[rsp]
	add	rcx, r11
	mov	r8d, DWORD PTR OsVer$[rsp]
	mov	edx, DWORD PTR Arch$[rsp]
	call	DumpIoStackLocData

; 387  : 	offset += IoStackSize(Arch, OsVer);

	mov	edx, DWORD PTR OsVer$[rsp]
	mov	ecx, DWORD PTR Arch$[rsp]
	call	IoStackSize
	mov	r11, rax
	mov	rax, QWORD PTR offset$[rsp]
	add	rax, r11
	mov	QWORD PTR offset$[rsp], rax

; 388  : 	DumpMemory(pIrpData + offset, len - offset);

	mov	rax, QWORD PTR offset$[rsp]
	mov	rdx, QWORD PTR len$[rsp]
	sub	rdx, rax
	mov	rax, QWORD PTR offset$[rsp]
	mov	rcx, QWORD PTR pIrpData$[rsp]
	add	rcx, rax
	call	DumpMemory

; 389  : }

	add	rsp, 72					; 00000048H
	ret	0
DumpIrp	ENDP
_TEXT	ENDS
EXTRN	FreeFmtIrp:PROC
EXTRN	FormatIrp:PROC
pdata	SEGMENT
$pdata$DumpIrpData DD imagerel $LN7
	DD	imagerel $LN7+133
	DD	imagerel $unwind$DumpIrpData
pdata	ENDS
xdata	SEGMENT
$unwind$DumpIrpData DD 011201H
	DD	06212H
; Function compile flags: /Odtp
xdata	ENDS
_TEXT	SEGMENT
pScan$ = 32
pFIrp$ = 40
pIrpData$ = 64
Arch$ = 72
OsVer$ = 80
DumpIrpData PROC

; 407  : {

$LN7:
	mov	DWORD PTR [rsp+24], r8d
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 408  : 	PWCHAR		pFIrp, pScan;
; 409  : 	if (FormatIrp(pIrpData, &pFIrp, Arch, OsVer)) {

	mov	r9d, DWORD PTR OsVer$[rsp]
	mov	r8d, DWORD PTR Arch$[rsp]
	lea	rdx, QWORD PTR pFIrp$[rsp]
	mov	rcx, QWORD PTR pIrpData$[rsp]
	call	FormatIrp
	test	eax, eax
	je	SHORT $LN4@DumpIrpDat

; 410  : 		for (pScan = pFIrp;*pScan != L'\0';pScan += wcslen(pScan) + 1) {

	mov	rax, QWORD PTR pFIrp$[rsp]
	mov	QWORD PTR pScan$[rsp], rax
	jmp	SHORT $LN3@DumpIrpDat
$LN2@DumpIrpDat:
	mov	rcx, QWORD PTR pScan$[rsp]
	call	wcslen
	mov	r11, rax
	mov	rax, QWORD PTR pScan$[rsp]
	lea	rax, QWORD PTR [rax+r11*2+2]
	mov	QWORD PTR pScan$[rsp], rax
$LN3@DumpIrpDat:
	mov	rax, QWORD PTR pScan$[rsp]
	movzx	eax, WORD PTR [rax]
	test	eax, eax
	je	SHORT $LN1@DumpIrpDat

; 411  : 			wprintf(L"%s\n", pScan);

	mov	rdx, QWORD PTR pScan$[rsp]
	lea	rcx, OFFSET FLAT:$SG84593
	call	wprintf

; 412  : 		}

	jmp	SHORT $LN2@DumpIrpDat
$LN1@DumpIrpDat:

; 413  : 		FreeFmtIrp(pFIrp);

	mov	rcx, QWORD PTR pFIrp$[rsp]
	call	FreeFmtIrp
$LN4@DumpIrpDat:

; 414  : 	}
; 415  : 	return;
; 416  : }

	add	rsp, 56					; 00000038H
	ret	0
DumpIrpData ENDP
_TEXT	ENDS
EXTRN	printf:PROC
pdata	SEGMENT
$pdata$DumpMemory DD imagerel $LN13
	DD	imagerel $LN13+261
	DD	imagerel $unwind$DumpMemory
pdata	ENDS
xdata	SEGMENT
$unwind$DumpMemory DD 010e01H
	DD	0620eH
; Function compile flags: /Odtp
xdata	ENDS
_TEXT	SEGMENT
value$ = 32
i$ = 36
j$ = 40
ch$84614 = 44
pMem$ = 64
cbLen$ = 72
DumpMemory PROC

; 423  : {

$LN13:
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 424  : 	UINT i, j, value;
; 425  : 	for (i = 0; i < cbLen; i++) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN10@DumpMemory
$LN9@DumpMemory:
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 1
	mov	DWORD PTR i$[rsp], eax
$LN10@DumpMemory:
	mov	eax, DWORD PTR i$[rsp]
	cmp	rax, QWORD PTR cbLen$[rsp]
	jae	$LN8@DumpMemory

; 426  : 		if (i % BYTES_PER_LINE == 0) printf ("\n0x%08x -", i);

	xor	edx, edx
	mov	eax, DWORD PTR i$[rsp]
	mov	ecx, 16
	div	ecx
	test	edx, edx
	jne	SHORT $LN7@DumpMemory
	mov	edx, DWORD PTR i$[rsp]
	lea	rcx, OFFSET FLAT:$SG84606
	call	printf
$LN7@DumpMemory:

; 427  : 		value = (UCHAR) *(pMem + i);

	mov	ecx, DWORD PTR i$[rsp]
	mov	rax, QWORD PTR pMem$[rsp]
	movzx	eax, BYTE PTR [rax+rcx]
	mov	DWORD PTR value$[rsp], eax

; 428  : 		printf(" %02x", value);

	mov	edx, DWORD PTR value$[rsp]
	lea	rcx, OFFSET FLAT:$SG84608
	call	printf

; 429  : 		if (((i + 1) % BYTES_PER_LINE == 0) && (i > 0)) {

	mov	eax, DWORD PTR i$[rsp]
	add	eax, 1
	xor	edx, edx
	mov	ecx, 16
	div	ecx
	test	edx, edx
	jne	SHORT $LN6@DumpMemory
	cmp	DWORD PTR i$[rsp], 0
	jbe	SHORT $LN6@DumpMemory

; 430  : 			printf(" -- ");

	lea	rcx, OFFSET FLAT:$SG84610
	call	printf

; 431  : 			for (j = 0; j < BYTES_PER_LINE; j++) {

	mov	DWORD PTR j$[rsp], 0
	jmp	SHORT $LN5@DumpMemory
$LN4@DumpMemory:
	mov	eax, DWORD PTR j$[rsp]
	add	eax, 1
	mov	DWORD PTR j$[rsp], eax
$LN5@DumpMemory:
	cmp	DWORD PTR j$[rsp], 16
	jae	SHORT $LN3@DumpMemory

; 432  : 				CHAR ch = *(pMem + i - BYTES_PER_LINE + 1 + j);

	mov	eax, DWORD PTR i$[rsp]
	mov	rcx, QWORD PTR pMem$[rsp]
	add	rcx, rax
	mov	eax, DWORD PTR j$[rsp]
	movzx	eax, BYTE PTR [rcx+rax-15]
	mov	BYTE PTR ch$84614[rsp], al

; 433  : 				if (ch < 0x20) {

	movsx	eax, BYTE PTR ch$84614[rsp]
	cmp	eax, 32					; 00000020H
	jge	SHORT $LN2@DumpMemory

; 434  : 					printf(".");

	lea	rcx, OFFSET FLAT:$SG84616
	call	printf

; 435  : 				} else {

	jmp	SHORT $LN1@DumpMemory
$LN2@DumpMemory:

; 436  : 					printf("%c", ch);

	movsx	edx, BYTE PTR ch$84614[rsp]
	lea	rcx, OFFSET FLAT:$SG84618
	call	printf
$LN1@DumpMemory:

; 437  : 				}
; 438  : 			}

	jmp	SHORT $LN4@DumpMemory
$LN3@DumpMemory:
$LN6@DumpMemory:

; 439  : 		}
; 440  : 	}

	jmp	$LN9@DumpMemory
$LN8@DumpMemory:

; 441  : }

	add	rsp, 56					; 00000038H
	ret	0
DumpMemory ENDP
_TEXT	ENDS
PUBLIC	HeapAllocWrap
PUBLIC	GetProcessHeapWrap
EXTRN	__imp_HeapFree:PROC
EXTRN	__imp_CloseHandle:PROC
EXTRN	__imp_ReadFile:PROC
EXTRN	wcscmp:PROC
pdata	SEGMENT
$pdata$GetData DD imagerel $LN21
	DD	imagerel $LN21+503
	DD	imagerel $unwind$GetData
pdata	ENDS
xdata	SEGMENT
$unwind$GetData DD 010d01H
	DD	0c20dH
; Function compile flags: /Odtp
xdata	ENDS
_TEXT	SEGMENT
hDevice$ = 48
pData$ = 56
OsVer$ = 64
Ret$ = 68
hHeap$ = 72
Arch$ = 80
dwBytesRead$ = 84
argC$ = 112
lpwszArgV$ = 120
GetData	PROC

; 460  : {

$LN21:
	mov	QWORD PTR [rsp+16], rdx
	mov	DWORD PTR [rsp+8], ecx
	sub	rsp, 104				; 00000068H

; 461  : 	// lpwszArgV[2] = archit
; 462  : 	// lpwszArgV[3] = OS ver
; 463  : 	// lpwszArgV[4] = dev name
; 464  : 
; 465  : 	ARCHIT	Arch;
; 466  :     HANDLE  hDevice = INVALID_HANDLE_VALUE;

	mov	QWORD PTR hDevice$[rsp], -1

; 467  : 	HANDLE	hHeap;
; 468  : 	DWORD	dwBytesRead;
; 469  : 	OSVER	OsVer;
; 470  : 	PCHAR	pData = NULL;

	mov	QWORD PTR pData$[rsp], 0

; 471  : 	int		Ret = CLT_ERROR;

	mov	DWORD PTR Ret$[rsp], 100		; 00000064H

; 472  : 
; 473  : 	if (!wcscmp(lpwszArgV[2], ARCH_STR_X86)) {

	lea	rdx, OFFSET FLAT:$SG84635
	mov	rcx, QWORD PTR lpwszArgV$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	call	wcscmp
	test	eax, eax
	jne	SHORT $LN18@GetData

; 474  : 		Arch = ARCH_X86;

	mov	DWORD PTR Arch$[rsp], 0
	jmp	SHORT $LN17@GetData
$LN18@GetData:

; 475  : 	} else if (!wcscmp(lpwszArgV[2], ARCH_STR_X64)) {

	lea	rdx, OFFSET FLAT:$SG84638
	mov	rcx, QWORD PTR lpwszArgV$[rsp]
	mov	rcx, QWORD PTR [rcx+16]
	call	wcscmp
	test	eax, eax
	jne	SHORT $LN16@GetData

; 476  : 		Arch = ARCH_X64;

	mov	DWORD PTR Arch$[rsp], 1

; 477  : 	} else {

	jmp	SHORT $LN15@GetData
$LN16@GetData:

; 478  : 		wprintf(L"\nInvalid processor architecture: \"%s\"",
; 479  : 			lpwszArgV[2]);

	mov	rdx, QWORD PTR lpwszArgV$[rsp]
	mov	rdx, QWORD PTR [rdx+16]
	lea	rcx, OFFSET FLAT:$SG84640
	call	wprintf

; 480  : 		return CLT_ERROR;

	mov	eax, 100				; 00000064H
	jmp	$LN19@GetData
$LN15@GetData:
$LN17@GetData:

; 481  : 	}
; 482  : 
; 483  : 	if (!wcscmp(lpwszArgV[3], OSVER_STR_WXP)) {

	lea	rdx, OFFSET FLAT:$SG84642
	mov	rcx, QWORD PTR lpwszArgV$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	call	wcscmp
	test	eax, eax
	jne	SHORT $LN14@GetData

; 484  : 		OsVer = OSVER_XP;

	mov	DWORD PTR OsVer$[rsp], 0
	jmp	SHORT $LN13@GetData
$LN14@GetData:

; 485  : 	} else if (!wcscmp(lpwszArgV[3], OSVER_STR_WLH)) {

	lea	rdx, OFFSET FLAT:$SG84645
	mov	rcx, QWORD PTR lpwszArgV$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	call	wcscmp
	test	eax, eax
	jne	SHORT $LN12@GetData

; 486  : 		OsVer = OSVER_VISTA;

	mov	DWORD PTR OsVer$[rsp], 1
	jmp	SHORT $LN11@GetData
$LN12@GetData:

; 487  : 	} else if (!wcscmp(lpwszArgV[3], OSVER_STR_WIN7)) {

	lea	rdx, OFFSET FLAT:$SG84648
	mov	rcx, QWORD PTR lpwszArgV$[rsp]
	mov	rcx, QWORD PTR [rcx+24]
	call	wcscmp
	test	eax, eax
	jne	SHORT $LN10@GetData

; 488  : 		OsVer = OSVER_WIN7;

	mov	DWORD PTR OsVer$[rsp], 2

; 489  : 	} else {

	jmp	SHORT $LN9@GetData
$LN10@GetData:

; 490  : 		wprintf(L"\nInvalid Windows Version: \"%s\"",
; 491  : 			lpwszArgV[3]);

	mov	rdx, QWORD PTR lpwszArgV$[rsp]
	mov	rdx, QWORD PTR [rdx+24]
	lea	rcx, OFFSET FLAT:$SG84650
	call	wprintf

; 492  : 		return CLT_ERROR;

	mov	eax, 100				; 00000064H
	jmp	$LN19@GetData
$LN9@GetData:
$LN11@GetData:
$LN13@GetData:

; 493  : 	}
; 494  : 
; 495  : 
; 496  : 	if (!GetProcessHeapWrap(&hHeap)) {

	lea	rcx, QWORD PTR hHeap$[rsp]
	call	GetProcessHeapWrap
	test	eax, eax
	jne	SHORT $LN8@GetData

; 497  : 		return CLT_ERROR;

	mov	eax, 100				; 00000064H
	jmp	$LN19@GetData
$LN8@GetData:

; 498  : 	}
; 499  : 	if (!HeapAllocWrap(hHeap, DATA_BUFFER_SIZE, &pData)) {

	lea	r8, QWORD PTR pData$[rsp]
	mov	edx, 65536				; 00010000H
	mov	rcx, QWORD PTR hHeap$[rsp]
	call	HeapAllocWrap
	test	eax, eax
	jne	SHORT $LN7@GetData

; 500  : 		return CLT_ERROR;

	mov	eax, 100				; 00000064H
	jmp	$LN19@GetData
$LN7@GetData:

; 501  : 	}
; 502  : 	hDevice = OpenDevice(lpwszArgV[4]);

	mov	rcx, QWORD PTR lpwszArgV$[rsp]
	mov	rcx, QWORD PTR [rcx+32]
	call	OpenDevice
	mov	QWORD PTR hDevice$[rsp], rax

; 503  : 	if (hDevice == INVALID_HANDLE_VALUE) goto CLEANUP;

	cmp	QWORD PTR hDevice$[rsp], -1
	jne	SHORT $LN6@GetData
	jmp	SHORT $CLEANUP$84656
$LN6@GetData:

; 504  : 	_tprintf(TEXT("Device succesfully opened\n"));

	lea	rcx, OFFSET FLAT:$SG84657
	call	wprintf
$LN5@GetData:

; 505  : 	for (;;) {
; 506  : 		if (ReadFile(hDevice, pData, DATA_BUFFER_SIZE, &dwBytesRead, 
; 507  : 			NULL)) {

	mov	QWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR dwBytesRead$[rsp]
	mov	r8d, 65536				; 00010000H
	mov	rdx, QWORD PTR pData$[rsp]
	mov	rcx, QWORD PTR hDevice$[rsp]
	call	QWORD PTR __imp_ReadFile
	test	eax, eax
	je	SHORT $LN3@GetData

; 508  : 			DumpIrp(pData, dwBytesRead, Arch, OsVer);

	mov	edx, DWORD PTR dwBytesRead$[rsp]
	mov	r9d, DWORD PTR OsVer$[rsp]
	mov	r8d, DWORD PTR Arch$[rsp]
	mov	rcx, QWORD PTR pData$[rsp]
	call	DumpIrp
$LN3@GetData:

; 509  : 		}
; 510  : 	}

	jmp	SHORT $LN5@GetData

; 511  : 	Ret = 0;

	mov	DWORD PTR Ret$[rsp], 0
$CLEANUP$84656:

; 512  : CLEANUP:
; 513  : 	
; 514  : 	if (hDevice != INVALID_HANDLE_VALUE) CloseHandle(hDevice);

	cmp	QWORD PTR hDevice$[rsp], -1
	je	SHORT $LN2@GetData
	mov	rcx, QWORD PTR hDevice$[rsp]
	call	QWORD PTR __imp_CloseHandle
$LN2@GetData:

; 515  : 	if (pData != NULL) HeapFree(hHeap, 0, pData);

	cmp	QWORD PTR pData$[rsp], 0
	je	SHORT $LN1@GetData
	mov	r8, QWORD PTR pData$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR hHeap$[rsp]
	call	QWORD PTR __imp_HeapFree
$LN1@GetData:

; 516  : 	return Ret;

	mov	eax, DWORD PTR Ret$[rsp]
$LN19@GetData:

; 517  : }

	add	rsp, 104				; 00000068H
	ret	0
GetData	ENDP
_TEXT	ENDS
EXTRN	__imp_GetLastError:PROC
EXTRN	__imp_GetProcessHeap:PROC
pdata	SEGMENT
$pdata$GetProcessHeapWrap DD imagerel $LN5
	DD	imagerel $LN5+84
	DD	imagerel $unwind$GetProcessHeapWrap
pdata	ENDS
xdata	SEGMENT
$unwind$GetProcessHeapWrap DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
_TEXT	SEGMENT
dwLastErr$ = 32
phHeap$ = 64
GetProcessHeapWrap PROC

; 533  : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 534  : 	DWORD dwLastErr;
; 535  : 	*phHeap = GetProcessHeap();

	call	QWORD PTR __imp_GetProcessHeap
	mov	r11, rax
	mov	rax, QWORD PTR phHeap$[rsp]
	mov	QWORD PTR [rax], r11

; 536  : 	if (*phHeap == NULL) {

	mov	rax, QWORD PTR phHeap$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN2@GetProcess

; 537  : 		dwLastErr = GetLastError();

	call	QWORD PTR __imp_GetLastError
	mov	DWORD PTR dwLastErr$[rsp], eax

; 538  : 		wprintf(
; 539  : 			L"\nGetProcessHeap failed; GetLastError() = %#010x (%d)",
; 540  : 			dwLastErr,
; 541  : 			dwLastErr);

	mov	r8d, DWORD PTR dwLastErr$[rsp]
	mov	edx, DWORD PTR dwLastErr$[rsp]
	lea	rcx, OFFSET FLAT:$SG84674
	call	wprintf

; 542  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN3@GetProcess

; 543  : 	} else {

	jmp	SHORT $LN1@GetProcess
$LN2@GetProcess:

; 544  : 		return TRUE;

	mov	eax, 1
$LN1@GetProcess:
$LN3@GetProcess:

; 545  : 	}
; 546  : }

	add	rsp, 56					; 00000038H
	ret	0
GetProcessHeapWrap ENDP
_TEXT	ENDS
EXTRN	__imp_HeapAlloc:PROC
pdata	SEGMENT
$pdata$HeapAllocWrap DD imagerel $LN5
	DD	imagerel $LN5+87
	DD	imagerel $unwind$HeapAllocWrap
pdata	ENDS
xdata	SEGMENT
$unwind$HeapAllocWrap DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
_TEXT	SEGMENT
hHeap$ = 48
cbSize$ = 56
ppBuf$ = 64
HeapAllocWrap PROC

; 564  : {

$LN5:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 40					; 00000028H

; 565  : 	*ppBuf = HeapAlloc(hHeap, 0, cbSize);

	mov	r8, QWORD PTR cbSize$[rsp]
	xor	edx, edx
	mov	rcx, QWORD PTR hHeap$[rsp]
	call	QWORD PTR __imp_HeapAlloc
	mov	r11, rax
	mov	rax, QWORD PTR ppBuf$[rsp]
	mov	QWORD PTR [rax], r11

; 566  : 	if (*ppBuf == NULL) {

	mov	rax, QWORD PTR ppBuf$[rsp]
	cmp	QWORD PTR [rax], 0
	jne	SHORT $LN2@HeapAllocW

; 567  : 		wprintf(L"\nHeapAlloc failed");

	lea	rcx, OFFSET FLAT:$SG84685
	call	wprintf

; 568  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN3@HeapAllocW

; 569  : 	} else {

	jmp	SHORT $LN1@HeapAllocW
$LN2@HeapAllocW:

; 570  : 		return TRUE;

	mov	eax, 1
$LN1@HeapAllocW:
$LN3@HeapAllocW:

; 571  : 	}
; 572  : }

	add	rsp, 40					; 00000028H
	ret	0
HeapAllocWrap ENDP
_TEXT	ENDS
PUBLIC	PrintAccDevList
pdata	SEGMENT
$pdata$ListDevices DD imagerel $LN7
	DD	imagerel $LN7+139
	DD	imagerel $unwind$ListDevices
pdata	ENDS
xdata	SEGMENT
$unwind$ListDevices DD 010401H
	DD	0a204H
; Function compile flags: /Odtp
xdata	ENDS
_TEXT	SEGMENT
pAdl$ = 48
hMasterDev$ = 56
hHeap$ = 64
dwBytesRead$ = 72
ListDevices PROC

; 578  : {

$LN7:
	sub	rsp, 88					; 00000058H

; 579  : 	DWORD					dwBytesRead;
; 580  : 	HANDLE					hHeap;
; 581  : 	HANDLE					hMasterDev;
; 582  : 	PACCESS_DEVICES_LIST	pAdl;
; 583  : 
; 584  : 	hMasterDev = OpenDevice(MASTER_DEVICE_NAME);

	lea	rcx, OFFSET FLAT:$SG84692
	call	OpenDevice
	mov	QWORD PTR hMasterDev$[rsp], rax

; 585  : 	if (hMasterDev == INVALID_HANDLE_VALUE) return FALSE;

	cmp	QWORD PTR hMasterDev$[rsp], -1
	jne	SHORT $LN4@ListDevice
	xor	eax, eax
	jmp	SHORT $LN5@ListDevice
$LN4@ListDevice:

; 586  : 	if (!GetProcessHeapWrap(&hHeap)) return FALSE;

	lea	rcx, QWORD PTR hHeap$[rsp]
	call	GetProcessHeapWrap
	test	eax, eax
	jne	SHORT $LN3@ListDevice
	xor	eax, eax
	jmp	SHORT $LN5@ListDevice
$LN3@ListDevice:

; 587  : 	if (!HeapAllocWrap(
; 588  : 		hHeap,
; 589  : 		4096, 
; 590  : 		&pAdl)) return FALSE;

	lea	r8, QWORD PTR pAdl$[rsp]
	mov	edx, 4096				; 00001000H
	mov	rcx, QWORD PTR hHeap$[rsp]
	call	HeapAllocWrap
	test	eax, eax
	jne	SHORT $LN2@ListDevice
	xor	eax, eax
	jmp	SHORT $LN5@ListDevice
$LN2@ListDevice:

; 591  : 	if (ReadFile(hMasterDev, pAdl, 4096, &dwBytesRead, NULL)) {

	mov	QWORD PTR [rsp+32], 0
	lea	r9, QWORD PTR dwBytesRead$[rsp]
	mov	r8d, 4096				; 00001000H
	mov	rdx, QWORD PTR pAdl$[rsp]
	mov	rcx, QWORD PTR hMasterDev$[rsp]
	call	QWORD PTR __imp_ReadFile
	test	eax, eax
	je	SHORT $LN1@ListDevice

; 592  : 		PrintAccDevList((PACCESS_DEVICES_LIST) pAdl);

	mov	rcx, QWORD PTR pAdl$[rsp]
	call	PrintAccDevList
$LN1@ListDevice:

; 593  : 	}
; 594  : 	return TRUE;

	mov	eax, 1
$LN5@ListDevice:

; 595  : }

	add	rsp, 88					; 00000058H
	ret	0
ListDevices ENDP
_TEXT	ENDS
PUBLIC	StringCbPrintfW
PUBLIC	__$ArrayPad$
EXTRN	__GSHandlerCheck:PROC
EXTRN	__imp_CreateFileW:PROC
EXTRN	__security_cookie:QWORD
EXTRN	__security_check_cookie:PROC
pdata	SEGMENT
$pdata$OpenDevice DD imagerel $LN5
	DD	imagerel $LN5+237
	DD	imagerel $unwind$OpenDevice
pdata	ENDS
xdata	SEGMENT
$unwind$OpenDevice DD 031f19H
	DD	08c010dH
	DD	03006H
	DD	imagerel __GSHandlerCheck
	DD	0450H
; Function compile flags: /Odtp
xdata	ENDS
_TEXT	SEGMENT
hDevice$ = 64
res$ = 72
wszDevPath$ = 96
__$ArrayPad$ = 1104
lpwszDevName$ = 1136
OpenDevice PROC

; 601  : {

$LN5:
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 1120				; 00000460H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 602  : 	HANDLE		hDevice;
; 603  : 	WCHAR		wszDevPath[501];
; 604  : 
; 605  : 	HRESULT res = StringCbPrintfW(
; 606  : 		wszDevPath,
; 607  : 		sizeof wszDevPath,
; 608  : 		L"\\\\.\\%s",
; 609  : 		lpwszDevName);

	mov	r9, QWORD PTR lpwszDevName$[rsp]
	lea	r8, OFFSET FLAT:$SG84707
	mov	edx, 1002				; 000003eaH
	lea	rcx, QWORD PTR wszDevPath$[rsp]
	call	StringCbPrintfW
	mov	DWORD PTR res$[rsp], eax

; 610  : 	if (!SUCCEEDED(res)) {

	cmp	DWORD PTR res$[rsp], 0
	jge	SHORT $LN2@OpenDevice

; 611  : 		wprintf(L"\nOpenDevice - StringCbPrintfW() returned %#x", res);

	mov	edx, DWORD PTR res$[rsp]
	lea	rcx, OFFSET FLAT:$SG84710
	call	wprintf

; 612  : 		return INVALID_HANDLE_VALUE;

	mov	rax, -1
	jmp	SHORT $LN3@OpenDevice
$LN2@OpenDevice:

; 613  : 	}
; 614  : 
; 615  :     hDevice =
; 616  :         CreateFile( wszDevPath,
; 617  : 					GENERIC_READ | GENERIC_WRITE,
; 618  : 					FILE_SHARE_READ | FILE_SHARE_WRITE,
; 619  : 					NULL,	// no security
; 620  : 					OPEN_EXISTING,
; 621  : 					FILE_ATTRIBUTE_NORMAL,
; 622  : 					NULL );		// no template

	mov	QWORD PTR [rsp+48], 0
	mov	DWORD PTR [rsp+40], 128			; 00000080H
	mov	DWORD PTR [rsp+32], 3
	xor	r9d, r9d
	mov	r8d, 3
	mov	edx, -1073741824			; c0000000H
	lea	rcx, QWORD PTR wszDevPath$[rsp]
	call	QWORD PTR __imp_CreateFileW
	mov	QWORD PTR hDevice$[rsp], rax

; 623  : 
; 624  : 	if ( hDevice == INVALID_HANDLE_VALUE ) {

	cmp	QWORD PTR hDevice$[rsp], -1
	jne	SHORT $LN1@OpenDevice

; 625  : 		wprintf( L"Failed to obtain file handle to %ls. "
; 626  : 			L"GetLastError() = %d (0x%x)\n",
; 627  : 			lpwszDevName,
; 628  : 			GetLastError(),
; 629  : 			GetLastError());

	call	QWORD PTR __imp_GetLastError
	mov	ebx, eax
	call	QWORD PTR __imp_GetLastError
	mov	r9d, ebx
	mov	r8d, eax
	mov	rdx, QWORD PTR lpwszDevName$[rsp]
	lea	rcx, OFFSET FLAT:$SG84718
	call	wprintf

; 630  :         return hDevice;

	mov	rax, QWORD PTR hDevice$[rsp]
	jmp	SHORT $LN3@OpenDevice
$LN1@OpenDevice:

; 631  : 	}
; 632  :     return hDevice;

	mov	rax, QWORD PTR hDevice$[rsp]
$LN3@OpenDevice:

; 633  : 
; 634  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 1120				; 00000460H
	pop	rbx
	ret	0
OpenDevice ENDP
_TEXT	ENDS
;	COMDAT pdata
; File c:\apps\pw7hp\devpgm\mssdk\include\strsafe.h
pdata	SEGMENT
$pdata$StringCbPrintfW DD imagerel $LN4
	DD	imagerel $LN4+141
	DD	imagerel $unwind$StringCbPrintfW
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$StringCbPrintfW DD 011801H
	DD	0a218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT StringCbPrintfW
_TEXT	SEGMENT
hr$ = 48
cchDest$ = 56
argList$83070 = 64
pszDest$ = 96
cbDest$ = 104
pszFormat$ = 112
StringCbPrintfW PROC					; COMDAT

; 4797 : {

$LN4:
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+32], r9
	sub	rsp, 88					; 00000058H

; 4798 :     HRESULT hr;
; 4799 :     size_t cchDest = cbDest / sizeof(wchar_t);

	xor	edx, edx
	mov	rax, QWORD PTR cbDest$[rsp]
	mov	ecx, 2
	div	rcx
	mov	QWORD PTR cchDest$[rsp], rax

; 4800 : 
; 4801 :     hr = StringValidateDestW(pszDest, cchDest, STRSAFE_MAX_CCH);

	mov	r8d, 2147483647				; 7fffffffH
	mov	rdx, QWORD PTR cchDest$[rsp]
	mov	rcx, QWORD PTR pszDest$[rsp]
	call	StringValidateDestW
	mov	DWORD PTR hr$[rsp], eax

; 4802 :     
; 4803 :     if (SUCCEEDED(hr))

	cmp	DWORD PTR hr$[rsp], 0
	jl	SHORT $LN1@StringCbPr

; 4804 :     {
; 4805 :         va_list argList;
; 4806 : 
; 4807 :         va_start(argList, pszFormat);

	lea	rax, QWORD PTR pszFormat$[rsp+8]
	mov	QWORD PTR argList$83070[rsp], rax

; 4808 : 
; 4809 :         hr = StringVPrintfWorkerW(pszDest,
; 4810 :                                   cchDest,
; 4811 :                                   NULL,
; 4812 :                                   pszFormat,
; 4813 :                                   argList);

	mov	rax, QWORD PTR argList$83070[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9, QWORD PTR pszFormat$[rsp]
	xor	r8d, r8d
	mov	rdx, QWORD PTR cchDest$[rsp]
	mov	rcx, QWORD PTR pszDest$[rsp]
	call	StringVPrintfWorkerW
	mov	DWORD PTR hr$[rsp], eax

; 4814 : 
; 4815 :         va_end(argList);

	mov	QWORD PTR argList$83070[rsp], 0
$LN1@StringCbPr:

; 4816 :     }
; 4817 : 
; 4818 :     return hr;

	mov	eax, DWORD PTR hr$[rsp]

; 4819 : }

	add	rsp, 88					; 00000058H
	ret	0
StringCbPrintfW ENDP
_TEXT	ENDS
pdata	SEGMENT
$pdata$StringValidateDestW DD imagerel StringValidateDestW
	DD	imagerel StringValidateDestW+61
	DD	imagerel $unwind$StringValidateDestW
pdata	ENDS
xdata	SEGMENT
$unwind$StringValidateDestW DD 011301H
	DD	02213H
; Function compile flags: /Odtp
xdata	ENDS
_TEXT	SEGMENT
hr$ = 0
pszDest$ = 32
cchDest$ = 40
cchMax$ = 48
StringValidateDestW PROC

; 8769 : {

	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 24

; 8770 :     HRESULT hr = S_OK;

	mov	DWORD PTR hr$[rsp], 0

; 8771 : 
; 8772 :     if ((cchDest == 0) || (cchDest > cchMax))

	cmp	QWORD PTR cchDest$[rsp], 0
	je	SHORT $LN1@StringVali
	mov	rax, QWORD PTR cchMax$[rsp]
	cmp	QWORD PTR cchDest$[rsp], rax
	jbe	SHORT $LN2@StringVali
$LN1@StringVali:

; 8773 :     {
; 8774 :         hr = STRSAFE_E_INVALID_PARAMETER;

	mov	DWORD PTR hr$[rsp], -2147024809		; ffffffff80070057H
$LN2@StringVali:

; 8775 :     }
; 8776 : 
; 8777 :     return hr;

	mov	eax, DWORD PTR hr$[rsp]

; 8778 : }

	add	rsp, 24
	ret	0
StringValidateDestW ENDP
_TEXT	ENDS
EXTRN	_vsnwprintf:PROC
pdata	SEGMENT
$pdata$StringVPrintfWorkerW DD imagerel StringVPrintfWorkerW
	DD	imagerel StringVPrintfWorkerW+245
	DD	imagerel $unwind$StringVPrintfWorkerW
pdata	ENDS
xdata	SEGMENT
$unwind$StringVPrintfWorkerW DD 011801H
	DD	08218H
; Function compile flags: /Odtp
xdata	ENDS
_TEXT	SEGMENT
cchNewDestLength$ = 32
cchMax$ = 40
iRet$ = 48
hr$ = 52
pszDest$ = 80
cchDest$ = 88
pcchNewDestLength$ = 96
pszFormat$ = 104
argList$ = 112
StringVPrintfWorkerW PROC

; 9145 : {

	mov	QWORD PTR [rsp+32], r9
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 72					; 00000048H

; 9146 :     HRESULT hr = S_OK;

	mov	DWORD PTR hr$[rsp], 0

; 9147 :     int iRet;
; 9148 :     size_t cchMax;
; 9149 :     size_t cchNewDestLength = 0;

	mov	QWORD PTR cchNewDestLength$[rsp], 0

; 9150 : 
; 9151 :     // leave the last space for the null terminator
; 9152 :     cchMax = cchDest - 1;

	mov	rax, QWORD PTR cchDest$[rsp]
	sub	rax, 1
	mov	QWORD PTR cchMax$[rsp], rax

; 9153 : 
; 9154 : #if (STRSAFE_USE_SECURE_CRT == 1) && !defined(STRSAFE_LIB_IMPL)
; 9155 :     iRet = _vsnwprintf_s(pszDest, cchDest, cchMax, pszFormat, argList);
; 9156 : #else
; 9157 :     #pragma warning(push)
; 9158 :     #pragma warning(disable: __WARNING_BANNED_API_USAGE)// "STRSAFE not included"
; 9159 :     iRet = _vsnwprintf(pszDest, cchMax, pszFormat, argList);

	mov	r9, QWORD PTR argList$[rsp]
	mov	r8, QWORD PTR pszFormat$[rsp]
	mov	rdx, QWORD PTR cchMax$[rsp]
	mov	rcx, QWORD PTR pszDest$[rsp]
	call	_vsnwprintf
	mov	DWORD PTR iRet$[rsp], eax

; 9160 :     #pragma warning(pop)
; 9161 : #endif
; 9162 :     // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));
; 9163 : 
; 9164 :     if ((iRet < 0) || (((size_t)iRet) > cchMax))

	cmp	DWORD PTR iRet$[rsp], 0
	jl	SHORT $LN5@StringVPri
	movsxd	rax, DWORD PTR iRet$[rsp]
	cmp	rax, QWORD PTR cchMax$[rsp]
	jbe	SHORT $LN6@StringVPri
$LN5@StringVPri:

; 9165 :     {
; 9166 :         // need to null terminate the string
; 9167 :         pszDest += cchMax;

	mov	rcx, QWORD PTR pszDest$[rsp]
	mov	rax, QWORD PTR cchMax$[rsp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR pszDest$[rsp], rax

; 9168 :         *pszDest = L'\0';

	xor	ecx, ecx
	mov	rax, QWORD PTR pszDest$[rsp]
	mov	WORD PTR [rax], cx

; 9169 : 
; 9170 :         cchNewDestLength = cchMax;

	mov	rax, QWORD PTR cchMax$[rsp]
	mov	QWORD PTR cchNewDestLength$[rsp], rax

; 9171 : 
; 9172 :         // we have truncated pszDest
; 9173 :         hr = STRSAFE_E_INSUFFICIENT_BUFFER;

	mov	DWORD PTR hr$[rsp], -2147024774		; ffffffff8007007aH
	jmp	SHORT $LN4@StringVPri
$LN6@StringVPri:

; 9174 :     }
; 9175 :     else if (((size_t)iRet) == cchMax)

	movsxd	rax, DWORD PTR iRet$[rsp]
	cmp	rax, QWORD PTR cchMax$[rsp]
	jne	SHORT $LN3@StringVPri

; 9176 :     {
; 9177 :         // need to null terminate the string
; 9178 :         pszDest += cchMax;

	mov	rcx, QWORD PTR pszDest$[rsp]
	mov	rax, QWORD PTR cchMax$[rsp]
	lea	rax, QWORD PTR [rcx+rax*2]
	mov	QWORD PTR pszDest$[rsp], rax

; 9179 :         *pszDest = L'\0';

	xor	ecx, ecx
	mov	rax, QWORD PTR pszDest$[rsp]
	mov	WORD PTR [rax], cx

; 9180 : 
; 9181 :         cchNewDestLength = cchMax;

	mov	rax, QWORD PTR cchMax$[rsp]
	mov	QWORD PTR cchNewDestLength$[rsp], rax

; 9182 :     }
; 9183 :     else

	jmp	SHORT $LN2@StringVPri
$LN3@StringVPri:

; 9184 :     {
; 9185 :         cchNewDestLength = (size_t)iRet;

	movsxd	rax, DWORD PTR iRet$[rsp]
	mov	QWORD PTR cchNewDestLength$[rsp], rax
$LN2@StringVPri:
$LN4@StringVPri:

; 9186 :     }
; 9187 : 
; 9188 :     if (pcchNewDestLength)

	cmp	QWORD PTR pcchNewDestLength$[rsp], 0
	je	SHORT $LN1@StringVPri

; 9189 :     {
; 9190 :         *pcchNewDestLength = cchNewDestLength;

	mov	rcx, QWORD PTR pcchNewDestLength$[rsp]
	mov	rax, QWORD PTR cchNewDestLength$[rsp]
	mov	QWORD PTR [rcx], rax
$LN1@StringVPri:

; 9191 :     }
; 9192 : 
; 9193 :     return hr;

	mov	eax, DWORD PTR hr$[rsp]

; 9194 : }

	add	rsp, 72					; 00000048H
	ret	0
StringVPrintfWorkerW ENDP
_TEXT	ENDS
PUBLIC	PrintMultiSz
pdata	SEGMENT
$pdata$PrintAccDevList DD imagerel $LN8
	DD	imagerel $LN8+380
	DD	imagerel $unwind$PrintAccDevList
pdata	ENDS
xdata	SEGMENT
$unwind$PrintAccDevList DD 010901H
	DD	06209H
; Function compile flags: /Odtp
; File b:\programm\wntsys\testfilter\release\1_1\source\testclt\testclt.c
xdata	ENDS
_TEXT	SEGMENT
i$ = 32
tv67 = 40
pAdl$ = 64
PrintAccDevList PROC

; 641  : {

$LN8:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H

; 642  : 	UINT	i;
; 643  : 	wprintf(
; 644  : 		L"\nComplete data:       %s\n",
; 645  : 		pAdl->bIncomplete ? L"no": L"yes" );

	mov	rax, QWORD PTR pAdl$[rsp]
	movzx	eax, BYTE PTR [rax]
	test	eax, eax
	je	SHORT $LN6@PrintAccDe
	lea	rax, OFFSET FLAT:$SG84723
	mov	QWORD PTR tv67[rsp], rax
	jmp	SHORT $LN7@PrintAccDe
$LN6@PrintAccDe:
	lea	rax, OFFSET FLAT:$SG84724
	mov	QWORD PTR tv67[rsp], rax
$LN7@PrintAccDe:
	mov	rdx, QWORD PTR tv67[rsp]
	lea	rcx, OFFSET FLAT:$SG84725
	call	wprintf

; 646  : 	wprintf(
; 647  : 		L"\nBytes needed:        %d\n",
; 648  : 		pAdl->ReqBufSize);

	mov	rdx, QWORD PTR pAdl$[rsp]
	mov	rdx, QWORD PTR [rdx+8]
	lea	rcx, OFFSET FLAT:$SG84726
	call	wprintf

; 649  : 
; 650  : 	for (i = 0; i < pAdl->DevInfoCount; i++) {

	mov	DWORD PTR i$[rsp], 0
	jmp	SHORT $LN3@PrintAccDe
$LN2@PrintAccDe:
	mov	eax, DWORD PTR i$[rsp]
	add	eax, 1
	mov	DWORD PTR i$[rsp], eax
$LN3@PrintAccDe:
	mov	rax, QWORD PTR pAdl$[rsp]
	mov	eax, DWORD PTR [rax+4]
	cmp	DWORD PTR i$[rsp], eax
	jae	$LN1@PrintAccDe

; 651  : 		wprintf(
; 652  : 			L"\n"
; 653  : 			L"Device:         %s\n",
; 654  : 			pAdl->TargDevVect[i].SymLink );

	mov	ecx, DWORD PTR i$[rsp]
	imul	rcx, 1114				; 0000045aH
	mov	rax, QWORD PTR pAdl$[rsp]
	lea	rdx, QWORD PTR [rax+rcx+16]
	lea	rcx, OFFSET FLAT:$SG84730
	call	wprintf

; 655  : 		wprintf(
; 656  : 			L"Text:              %s\n",
; 657  : 			pAdl->TargDevVect[i].DeviceText );

	mov	ecx, DWORD PTR i$[rsp]
	imul	rcx, 1114				; 0000045aH
	mov	rax, QWORD PTR pAdl$[rsp]
	lea	rdx, QWORD PTR [rax+rcx+524]
	lea	rcx, OFFSET FLAT:$SG84731
	call	wprintf

; 658  : 		wprintf(
; 659  : 			L"Device ID:         %s\n",
; 660  : 			pAdl->TargDevVect[i].DeviceId );

	mov	ecx, DWORD PTR i$[rsp]
	imul	rcx, 1114				; 0000045aH
	mov	rax, QWORD PTR pAdl$[rsp]
	lea	rdx, QWORD PTR [rax+rcx+322]
	lea	rcx, OFFSET FLAT:$SG84732
	call	wprintf

; 661  : 		wprintf(
; 662  : 			L"Instance ID:       %s\n",
; 663  : 			pAdl->TargDevVect[i].InstanceId );

	mov	ecx, DWORD PTR i$[rsp]
	imul	rcx, 1114				; 0000045aH
	mov	rax, QWORD PTR pAdl$[rsp]
	lea	rdx, QWORD PTR [rax+rcx+928]
	lea	rcx, OFFSET FLAT:$SG84733
	call	wprintf

; 664  : 		wprintf(
; 665  : 			L"Hardware IDs:      ");

	lea	rcx, OFFSET FLAT:$SG84734
	call	wprintf

; 666  : 		PrintMultiSz(pAdl->TargDevVect[i].HardwareIDs);

	mov	ecx, DWORD PTR i$[rsp]
	imul	rcx, 1114				; 0000045aH
	mov	rax, QWORD PTR pAdl$[rsp]
	lea	rcx, QWORD PTR [rax+rcx+726]
	call	PrintMultiSz

; 667  : 		wprintf(L"\n");

	lea	rcx, OFFSET FLAT:$SG84735
	call	wprintf

; 668  : 		wprintf(
; 669  : 			L"Compatible IDs:    ");

	lea	rcx, OFFSET FLAT:$SG84736
	call	wprintf

; 670  : 		PrintMultiSz(pAdl->TargDevVect[i].CompatibleIDs);

	mov	ecx, DWORD PTR i$[rsp]
	imul	rcx, 1114				; 0000045aH
	mov	rax, QWORD PTR pAdl$[rsp]
	lea	rcx, QWORD PTR [rax+rcx+120]
	call	PrintMultiSz

; 671  : 		wprintf(L"\n");

	lea	rcx, OFFSET FLAT:$SG84737
	call	wprintf

; 672  : 	}

	jmp	$LN2@PrintAccDe
$LN1@PrintAccDe:

; 673  : 
; 674  : 	return FALSE;

	xor	eax, eax

; 675  : }

	add	rsp, 56					; 00000038H
	ret	0
PrintAccDevList ENDP
_TEXT	ENDS
pdata	SEGMENT
$pdata$PrintHelp DD imagerel $LN3
	DD	imagerel $LN3+177
	DD	imagerel $unwind$PrintHelp
pdata	ENDS
xdata	SEGMENT
$unwind$PrintHelp DD 010401H
	DD	04204H
; Function compile flags: /Odtp
xdata	ENDS
_TEXT	SEGMENT
PrintHelp PROC

; 681  : {

$LN3:
	sub	rsp, 40					; 00000028H

; 682  : 	wprintf(L"\n\nUsage:");

	lea	rcx, OFFSET FLAT:$SG84739
	call	wprintf

; 683  : 	wprintf(L"\n\n    List devices:");

	lea	rcx, OFFSET FLAT:$SG84740
	call	wprintf

; 684  : 	wprintf(L"\n\n        TestClt /l");

	lea	rcx, OFFSET FLAT:$SG84741
	call	wprintf

; 685  : 	wprintf(L"\n\n    Set flags for IRP major function code:");

	lea	rcx, OFFSET FLAT:$SG84742
	call	wprintf

; 686  : 	wprintf(L"\n\n        TestClt /c s major_function flags symbolic_link");

	lea	rcx, OFFSET FLAT:$SG84743
	call	wprintf

; 687  : 	wprintf(L"\n\n            major_function: IRP major function code in hex");

	lea	rcx, OFFSET FLAT:$SG84744
	call	wprintf

; 688  : 	wprintf(L"\n\n            flags         : flags value in hex");

	lea	rcx, OFFSET FLAT:$SG84745
	call	wprintf

; 689  : 	wprintf(L"\n\n            symbolic_link : sym link for the FA device");

	lea	rcx, OFFSET FLAT:$SG84746
	call	wprintf

; 690  : 	wprintf(L"\n\n    Get intercepted data:");

	lea	rcx, OFFSET FLAT:$SG84747
	call	wprintf

; 691  : 	wprintf(L"\n\n        TestClt /d archit osver symbolic_link");

	lea	rcx, OFFSET FLAT:$SG84748
	call	wprintf

; 692  : 	wprintf(L"\n\n            archit        : processor architecture (x86, x64)");

	lea	rcx, OFFSET FLAT:$SG84749
	call	wprintf

; 693  : 	wprintf(L"\n\n            osver         : windows version (wxp, vista, win7)");

	lea	rcx, OFFSET FLAT:$SG84750
	call	wprintf

; 694  : 	wprintf(L"\n\n            symbolic_link : sym link for the FA device");

	lea	rcx, OFFSET FLAT:$SG84751
	call	wprintf

; 695  : 	wprintf(L"\n");

	lea	rcx, OFFSET FLAT:$SG84752
	call	wprintf

; 696  : }

	add	rsp, 40					; 00000028H
	ret	0
PrintHelp ENDP
_TEXT	ENDS
pdata	SEGMENT
$pdata$PrintMultiSz DD imagerel $LN6
	DD	imagerel $LN6+87
	DD	imagerel $unwind$PrintMultiSz
pdata	ENDS
xdata	SEGMENT
$unwind$PrintMultiSz DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
_TEXT	SEGMENT
StrLen$ = 32
pwszMulti$ = 64
PrintMultiSz PROC

; 703  : {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	sub	rsp, 56					; 00000038H
$LN3@PrintMulti:

; 704  : 	SIZE_T StrLen;
; 705  : 
; 706  : 	for (;;) {
; 707  : 		wprintf(pwszMulti);

	mov	rcx, QWORD PTR pwszMulti$[rsp]
	call	wprintf

; 708  : 		StrLen = wcslen(pwszMulti);

	mov	rcx, QWORD PTR pwszMulti$[rsp]
	call	wcslen
	mov	QWORD PTR StrLen$[rsp], rax

; 709  : 		pwszMulti += StrLen + 1;

	mov	rcx, QWORD PTR pwszMulti$[rsp]
	mov	rax, QWORD PTR StrLen$[rsp]
	lea	rax, QWORD PTR [rcx+rax*2+2]
	mov	QWORD PTR pwszMulti$[rsp], rax

; 710  : 		if (*pwszMulti == L'\0') break;

	mov	rax, QWORD PTR pwszMulti$[rsp]
	movzx	eax, WORD PTR [rax]
	test	eax, eax
	jne	SHORT $LN1@PrintMulti
	jmp	SHORT $LN2@PrintMulti
$LN1@PrintMulti:

; 711  : 		wprintf(L", ");

	lea	rcx, OFFSET FLAT:$SG84761
	call	wprintf

; 712  : 	} 

	jmp	SHORT $LN3@PrintMulti
$LN2@PrintMulti:

; 713  : 
; 714  : }

	add	rsp, 56					; 00000038H
	ret	0
PrintMultiSz ENDP
_TEXT	ENDS
EXTRN	__imp_DeviceIoControl:PROC
pdata	SEGMENT
$pdata$SendIoCtl DD imagerel $LN4
	DD	imagerel $LN4+155
	DD	imagerel $unwind$SendIoCtl
pdata	ENDS
xdata	SEGMENT
$unwind$SendIoCtl DD 021801H
	DD	030149218H
; Function compile flags: /Odtp
xdata	ENDS
_TEXT	SEGMENT
dwBytesRet$ = 64
bResult$ = 68
hDevice$ = 96
code$ = 104
lpInBuffer$ = 112
inBufSize$ = 120
lpOutBuffer$ = 128
outBufSize$ = 136
SendIoCtl PROC

; 726  : {

$LN4:
	mov	DWORD PTR [rsp+32], r9d
	mov	QWORD PTR [rsp+24], r8
	mov	DWORD PTR [rsp+16], edx
	mov	QWORD PTR [rsp+8], rcx
	push	rbx
	sub	rsp, 80					; 00000050H

; 727  : 	BOOL	bResult;
; 728  : 	DWORD	dwBytesRet;
; 729  : 
; 730  : 	bResult = DeviceIoControl(
; 731  : 		hDevice,
; 732  : 		code,
; 733  : 		lpInBuffer,
; 734  : 		inBufSize,
; 735  : 		lpOutBuffer,
; 736  : 		outBufSize,
; 737  : 		&dwBytesRet,
; 738  : 		NULL);

	mov	QWORD PTR [rsp+56], 0
	lea	rax, QWORD PTR dwBytesRet$[rsp]
	mov	QWORD PTR [rsp+48], rax
	mov	eax, DWORD PTR outBufSize$[rsp]
	mov	DWORD PTR [rsp+40], eax
	mov	rax, QWORD PTR lpOutBuffer$[rsp]
	mov	QWORD PTR [rsp+32], rax
	mov	r9d, DWORD PTR inBufSize$[rsp]
	mov	r8, QWORD PTR lpInBuffer$[rsp]
	mov	edx, DWORD PTR code$[rsp]
	mov	rcx, QWORD PTR hDevice$[rsp]
	call	QWORD PTR __imp_DeviceIoControl
	mov	DWORD PTR bResult$[rsp], eax

; 739  : 
; 740  : 	if (!bResult) {

	cmp	DWORD PTR bResult$[rsp], 0
	jne	SHORT $LN1@SendIoCtl

; 741  : 		_tprintf( TEXT("Failed to send IOCTL. Code: 0x%8x, GetLastError() = 0x%8x, (%i)"),
; 742  : 			code,
; 743  : 			GetLastError(),
; 744  : 			GetLastError() );

	call	QWORD PTR __imp_GetLastError
	mov	ebx, eax
	call	QWORD PTR __imp_GetLastError
	mov	r9d, ebx
	mov	r8d, eax
	mov	edx, DWORD PTR code$[rsp]
	lea	rcx, OFFSET FLAT:$SG84779
	call	wprintf

; 745  : 		return bResult;

	mov	eax, DWORD PTR bResult$[rsp]
	jmp	SHORT $LN2@SendIoCtl
$LN1@SendIoCtl:

; 746  : 	}
; 747  : 
; 748  : 	return bResult;

	mov	eax, DWORD PTR bResult$[rsp]
$LN2@SendIoCtl:

; 749  : }

	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
SendIoCtl ENDP
_TEXT	ENDS
END
