; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	B:\Programm\WntSys\TestFilter\Release\1_1\Source\TestClt\TestClt.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

_BSS	SEGMENT
$SG78231 DB	01H DUP (?)
	ALIGN	4

$SG78249 DW	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
$SG78772 DB	'11:02:06', 00H
	ORG $+3
$SG78773 DB	'May  1 2013', 00H
$SG78774 DB	0aH, 00H, 'T', 00H, 'e', 00H, 's', 00H, 't', 00H, ' ', 00H
	DB	'c', 00H, 'l', 00H, 'i', 00H, 'e', 00H, 'n', 00H, 't', 00H, ','
	DB	00H, ' ', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'i', 00H
	DB	'l', 00H, 'e', 00H, 'd', 00H, ' ', 00H, '%', 00H, 'S', 00H, ' '
	DB	00H, '%', 00H, 'S', 00H, 0aH, 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG78785 DB	0aH, 00H, 'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'm', 00H, 'm'
	DB	00H, 'a', 00H, 'n', 00H, 'd', 00H, ':', 00H, ' ', 00H, '%', 00H
	DB	's', 00H, 00H, 00H
	ORG $+2
$SG78792 DB	0aH, 00H, 0aH, 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H
	DB	'a', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 'm', 00H, 'i', 00H, 's'
	DB	00H, 's', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 0aH, 00H, 00H, 00H
	ORG $+6
$SG78794 DB	0aH, 00H, 0aH, 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H
	DB	'a', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r'
	DB	00H, 'm', 00H, 'a', 00H, 't', 00H, ' ', 00H, 'n', 00H, 'o', 00H
	DB	't', 00H, ' ', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd'
	DB	00H, ':', 00H, ' ', 00H, '%', 00H, 's', 00H, 0aH, 00H, 00H, 00H
$SG78796 DB	0aH, 00H, 0aH, 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H
	DB	'a', 00H, 'n', 00H, 'd', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r'
	DB	00H, 'm', 00H, 'a', 00H, 't', 00H, ' ', 00H, 'n', 00H, 'o', 00H
	DB	't', 00H, ' ', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd'
	DB	00H, ':', 00H, ' ', 00H, '%', 00H, 's', 00H, 0aH, 00H, 00H, 00H
$SG78804 DB	0aH, 00H, 0aH, 00H, 'M', 00H, 'i', 00H, 's', 00H, 's', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'p', 00H, 'a', 00H, 'r'
	DB	00H, 'a', 00H, 'm', 00H, 'e', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	'(', 00H, 's', 00H, ')', 00H, 0aH, 00H, 00H, 00H
$SG78806 DB	0aH, 00H, 0aH, 00H, 'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H
	DB	'l', 00H, 'i', 00H, 'd', 00H, ' ', 00H, 's', 00H, 'u', 00H, 'b'
	DB	00H, 'f', 00H, 'u', 00H, 'n', 00H, 'c', 00H, 't', 00H, 'i', 00H
	DB	'o', 00H, 'n', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e'
	DB	00H, ':', 00H, ' ', 00H, '%', 00H, 's', 00H, 0aH, 00H, 00H, 00H
$SG78809 DB	0aH, 00H, 0aH, 00H, 'M', 00H, 'i', 00H, 's', 00H, 's', 00H
	DB	'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H, 'p', 00H, 'a', 00H, 'r'
	DB	00H, 'a', 00H, 'm', 00H, 'e', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	'(', 00H, 's', 00H, ')', 00H, 0aH, 00H, 00H, 00H
$SG78812 DB	0aH, 00H, 0aH, 00H, 'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H
	DB	'l', 00H, 'i', 00H, 'd', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'm'
	DB	00H, 'm', 00H, 'a', 00H, 'n', 00H, 'd', 00H, ':', 00H, ' ', 00H
	DB	'%', 00H, 's', 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG78818 DB	0aH, 00H, 0aH, 00H, 'T', 00H, 'o', 00H, ' ', 00H, 'b', 00H
	DB	'e', 00H, ' ', 00H, 'i', 00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e'
	DB	00H, 'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'd', 00H
	DB	'.', 00H, '.', 00H, '.', 00H, 0aH, 00H, 00H, 00H
$SG78829 DB	'0', 00H, 'x', 00H, '%', 00H, 'x', 00H, 00H, 00H
	ORG $+2
$SG78830 DB	0aH, 00H, 'P', 00H, 'a', 00H, 'r', 00H, 'a', 00H, 'm', 00H
	DB	'e', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'p', 00H, 'a'
	DB	00H, 'r', 00H, 's', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H
	DB	'e', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ':', 00H, ' '
	DB	00H, '%', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG78832 DB	'0', 00H, 'x', 00H, '%', 00H, 'x', 00H, 00H, 00H
	ORG $+2
$SG78833 DB	0aH, 00H, 'P', 00H, 'a', 00H, 'r', 00H, 'a', 00H, 'm', 00H
	DB	'e', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'p', 00H, 'a'
	DB	00H, 'r', 00H, 's', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H
	DB	'e', 00H, 'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ':', 00H, ' '
	DB	00H, '%', 00H, 's', 00H, 00H, 00H
	ORG $+2
$SG78834 DB	0aH, 00H, 'S', 00H, 'e', 00H, 't', 00H, 't', 00H, 'i', 00H
	DB	'n', 00H, 'g', 00H, ' ', 00H, 'f', 00H, 'l', 00H, 'a', 00H, 'g'
	DB	00H, 's', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'M', 00H, 'a', 00H, 'j', 00H, 'o', 00H, 'r', 00H, 'F', 00H, 'u'
	DB	00H, 'n', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H
	DB	' ', 00H, '=', 00H, ' ', 00H, '%', 00H, '#', 00H, '0', 00H, '1'
	DB	00H, '0', 00H, 'x', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H
	DB	'%', 00H, '#', 00H, '0', 00H, '1', 00H, '0', 00H, 'x', 00H, 00H
	DB	00H
$SG78857 DB	0aH, 00H, 'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T'
	DB	00H, 'L', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H
	DB	':', 00H, ' ', 00H, '%', 00H, 'c', 00H, 00H, 00H
$SG78871 DB	'%', 00H, 's', 00H, 0aH, 00H, 00H, 00H
$SG78883 DB	0aH, 00H, 0aH, 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H
	DB	'-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-', 00H, '-'
	DB	00H, '-', 00H, '-', 00H, 00H, 00H
$SG78884 DB	0aH, 00H, 0aH, 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'd', 00H, ' ', 00H, 'I', 00H, 'R', 00H, 'P', 00H, 00H
	DB	00H
	ORG $+2
$SG78885 DB	0aH, 00H, 0aH, 00H, 'D', 00H, 'a', 00H, 't', 00H, 'a', 00H
	DB	' ', 00H, 'L', 00H, 'e', 00H, 'n', 00H, 'g', 00H, 't', 00H, 'h'
	DB	00H, ':', 00H, ' ', 00H, '%', 00H, '#', 00H, 'x', 00H, 00H, 00H
	ORG $+2
$SG78886 DB	0aH, 00H, 0aH, 00H, 'I', 00H, 'R', 00H, 'P', 00H, ':', 00H
	DB	0aH, 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG78888 DB	0aH, 00H, 0aH, 00H, 'I', 00H, '/', 00H, 'O', 00H, ' ', 00H
	DB	'S', 00H, 't', 00H, 'a', 00H, 'c', 00H, 'k', 00H, ' ', 00H, 'l'
	DB	00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'o', 00H
	DB	'n', 00H, ':', 00H, 0aH, 00H, 0aH, 00H, 00H, 00H
$SG78902 DB	'%', 00H, 's', 00H, 0aH, 00H, 00H, 00H
$SG78915 DB	0aH, '0x%08x -', 00H
	ORG $+2
$SG78917 DB	' %02x', 00H
	ORG $+2
$SG78919 DB	' -- ', 00H
	ORG $+3
$SG78925 DB	'.', 00H
	ORG $+2
$SG78927 DB	'%c', 00H
	ORG $+1
$SG78944 DB	'x', 00H, '8', 00H, '6', 00H, 00H, 00H
$SG78947 DB	'x', 00H, '6', 00H, '4', 00H, 00H, 00H
$SG78949 DB	0aH, 00H, 'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'c'
	DB	00H, 'e', 00H, 's', 00H, 's', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H, 'i', 00H, 't', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e', 00H, ':', 00H
	DB	' ', 00H, '"', 00H, '%', 00H, 's', 00H, '"', 00H, 00H, 00H
$SG78951 DB	'w', 00H, 'x', 00H, 'p', 00H, 00H, 00H
$SG78954 DB	'w', 00H, 'l', 00H, 'h', 00H, 00H, 00H
$SG78957 DB	'w', 00H, 'i', 00H, 'n', 00H, '7', 00H, 00H, 00H
	ORG $+2
$SG78959 DB	0aH, 00H, 'I', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, 'W', 00H, 'i', 00H, 'n', 00H, 'd'
	DB	00H, 'o', 00H, 'w', 00H, 's', 00H, ' ', 00H, 'V', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ':', 00H, ' '
	DB	00H, '"', 00H, '%', 00H, 's', 00H, '"', 00H, 00H, 00H
	ORG $+2
$SG78966 DB	'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	' ', 00H, 's', 00H, 'u', 00H, 'c', 00H, 'c', 00H, 'e', 00H, 's'
	DB	00H, 'f', 00H, 'u', 00H, 'l', 00H, 'l', 00H, 'y', 00H, ' ', 00H
	DB	'o', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'e', 00H, 'd', 00H, 0aH
	DB	00H, 00H, 00H
	ORG $+2
$SG78983 DB	0aH, 00H, 'G', 00H, 'e', 00H, 't', 00H, 'P', 00H, 'r', 00H
	DB	'o', 00H, 'c', 00H, 'e', 00H, 's', 00H, 's', 00H, 'H', 00H, 'e'
	DB	00H, 'a', 00H, 'p', 00H, ' ', 00H, 'f', 00H, 'a', 00H, 'i', 00H
	DB	'l', 00H, 'e', 00H, 'd', 00H, ';', 00H, ' ', 00H, 'G', 00H, 'e'
	DB	00H, 't', 00H, 'L', 00H, 'a', 00H, 's', 00H, 't', 00H, 'E', 00H
	DB	'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, '(', 00H, ')', 00H, ' '
	DB	00H, '=', 00H, ' ', 00H, '%', 00H, '#', 00H, '0', 00H, '1', 00H
	DB	'0', 00H, 'x', 00H, ' ', 00H, '(', 00H, '%', 00H, 'd', 00H, ')'
	DB	00H, 00H, 00H
	ORG $+2
$SG78994 DB	0aH, 00H, 'H', 00H, 'e', 00H, 'a', 00H, 'p', 00H, 'A', 00H
	DB	'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, ' ', 00H, 'f', 00H, 'a'
	DB	00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, 00H, 00H
$SG79001 DB	'F', 00H, 'i', 00H, 'l', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	'M', 00H, 'a', 00H, 's', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'D'
	DB	00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG79016 DB	'\', 00H, '\', 00H, '.', 00H, '\', 00H, '%', 00H, 's', 00H
	DB	00H, 00H
	ORG $+2
$SG79019 DB	0aH, 00H, 'O', 00H, 'p', 00H, 'e', 00H, 'n', 00H, 'D', 00H
	DB	'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, ' ', 00H, '-'
	DB	00H, ' ', 00H, 'S', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H
	DB	'g', 00H, 'C', 00H, 'b', 00H, 'P', 00H, 'r', 00H, 'i', 00H, 'n'
	DB	00H, 't', 00H, 'f', 00H, 'W', 00H, '(', 00H, ')', 00H, ' ', 00H
	DB	'r', 00H, 'e', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'n', 00H, 'e'
	DB	00H, 'd', 00H, ' ', 00H, '%', 00H, '#', 00H, 'x', 00H, 00H, 00H
	ORG $+6
$SG79027 DB	'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 'o', 00H, 'b', 00H, 't'
	DB	00H, 'a', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 'f', 00H, 'i', 00H
	DB	'l', 00H, 'e', 00H, ' ', 00H, 'h', 00H, 'a', 00H, 'n', 00H, 'd'
	DB	00H, 'l', 00H, 'e', 00H, ' ', 00H, 't', 00H, 'o', 00H, ' ', 00H
	DB	'%', 00H, 'l', 00H, 's', 00H, '.', 00H, ' ', 00H, 'G', 00H, 'e'
	DB	00H, 't', 00H, 'L', 00H, 'a', 00H, 's', 00H, 't', 00H, 'E', 00H
	DB	'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, '(', 00H, ')', 00H, ' '
	DB	00H, '=', 00H, ' ', 00H, '%', 00H, 'd', 00H, ' ', 00H, '(', 00H
	DB	'0', 00H, 'x', 00H, '%', 00H, 'x', 00H, ')', 00H, 0aH, 00H, 00H
	DB	00H
	ORG $+2
$SG79032 DB	'n', 00H, 'o', 00H, 00H, 00H
	ORG $+2
$SG79033 DB	'y', 00H, 'e', 00H, 's', 00H, 00H, 00H
$SG79034 DB	0aH, 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'l', 00H
	DB	'e', 00H, 't', 00H, 'e', 00H, ' ', 00H, 'd', 00H, 'a', 00H, 't'
	DB	00H, 'a', 00H, ':', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, '%', 00H, 's', 00H, 0aH, 00H, 00H
	DB	00H
$SG79035 DB	0aH, 00H, 'B', 00H, 'y', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	' ', 00H, 'n', 00H, 'e', 00H, 'e', 00H, 'd', 00H, 'e', 00H, 'd'
	DB	00H, ':', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, '%', 00H, 'd', 00H, 0aH, 00H, 00H
	DB	00H
$SG79039 DB	0aH, 00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H
	DB	'e', 00H, ':', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, '%', 00H, 's', 00H
	DB	0aH, 00H, 00H, 00H
	ORG $+2
$SG79040 DB	'T', 00H, 'e', 00H, 'x', 00H, 't', 00H, ':', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	'%', 00H, 's', 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG79041 DB	'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	' ', 00H, 'I', 00H, 'D', 00H, ':', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	'%', 00H, 's', 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG79042 DB	'I', 00H, 'n', 00H, 's', 00H, 't', 00H, 'a', 00H, 'n', 00H
	DB	'c', 00H, 'e', 00H, ' ', 00H, 'I', 00H, 'D', 00H, ':', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	'%', 00H, 's', 00H, 0aH, 00H, 00H, 00H
	ORG $+2
$SG79043 DB	'H', 00H, 'a', 00H, 'r', 00H, 'd', 00H, 'w', 00H, 'a', 00H
	DB	'r', 00H, 'e', 00H, ' ', 00H, 'I', 00H, 'D', 00H, 's', 00H, ':'
	DB	00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	00H, 00H
$SG79044 DB	0aH, 00H, 00H, 00H
$SG79045 DB	'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't', 00H
	DB	'i', 00H, 'b', 00H, 'l', 00H, 'e', 00H, ' ', 00H, 'I', 00H, 'D'
	DB	00H, 's', 00H, ':', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	00H, 00H
$SG79046 DB	0aH, 00H, 00H, 00H
$SG79048 DB	0aH, 00H, 0aH, 00H, 'U', 00H, 's', 00H, 'a', 00H, 'g', 00H
	DB	'e', 00H, ':', 00H, 00H, 00H
	ORG $+2
$SG79049 DB	0aH, 00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	'L', 00H, 'i', 00H, 's', 00H, 't', 00H, ' ', 00H, 'd', 00H, 'e'
	DB	00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, ':', 00H
	DB	00H, 00H
$SG79050 DB	0aH, 00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'T', 00H, 'e', 00H, 's'
	DB	00H, 't', 00H, 'C', 00H, 'l', 00H, 't', 00H, ' ', 00H, '/', 00H
	DB	'l', 00H, 00H, 00H
	ORG $+2
$SG79051 DB	0aH, 00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	'S', 00H, 'e', 00H, 't', 00H, ' ', 00H, 'f', 00H, 'l', 00H, 'a'
	DB	00H, 'g', 00H, 's', 00H, ' ', 00H, 'f', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, 'I', 00H, 'R', 00H, 'P', 00H, ' ', 00H, 'm', 00H, 'a'
	DB	00H, 'j', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'f', 00H, 'u', 00H
	DB	'n', 00H, 'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' '
	DB	00H, 'c', 00H, 'o', 00H, 'd', 00H, 'e', 00H, ':', 00H, 00H, 00H
	ORG $+6
$SG79052 DB	0aH, 00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'T', 00H, 'e', 00H, 's'
	DB	00H, 't', 00H, 'C', 00H, 'l', 00H, 't', 00H, ' ', 00H, '/', 00H
	DB	'c', 00H, ' ', 00H, 's', 00H, ' ', 00H, 'm', 00H, 'a', 00H, 'j'
	DB	00H, 'o', 00H, 'r', 00H, '_', 00H, 'f', 00H, 'u', 00H, 'n', 00H
	DB	'c', 00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 'f'
	DB	00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H, ' ', 00H, 's', 00H
	DB	'y', 00H, 'm', 00H, 'b', 00H, 'o', 00H, 'l', 00H, 'i', 00H, 'c'
	DB	00H, '_', 00H, 'l', 00H, 'i', 00H, 'n', 00H, 'k', 00H, 00H, 00H
$SG79061 DB	0aH, 00H, 00H, 00H
$SG79053 DB	0aH, 00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, 'm', 00H, 'a', 00H, 'j', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'f', 00H, 'u', 00H, 'n', 00H, 'c', 00H, 't', 00H, 'i'
	DB	00H, 'o', 00H, 'n', 00H, ':', 00H, ' ', 00H, 'I', 00H, 'R', 00H
	DB	'P', 00H, ' ', 00H, 'm', 00H, 'a', 00H, 'j', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, 'f', 00H, 'u', 00H, 'n', 00H, 'c', 00H, 't', 00H
	DB	'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 'c', 00H, 'o', 00H, 'd'
	DB	00H, 'e', 00H, ' ', 00H, 'i', 00H, 'n', 00H, ' ', 00H, 'h', 00H
	DB	'e', 00H, 'x', 00H, 00H, 00H
	ORG $+6
$SG79054 DB	0aH, 00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, 'f', 00H, 'l', 00H, 'a', 00H, 'g', 00H, 's', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ':', 00H, ' ', 00H, 'f', 00H, 'l', 00H
	DB	'a', 00H, 'g', 00H, 's', 00H, ' ', 00H, 'v', 00H, 'a', 00H, 'l'
	DB	00H, 'u', 00H, 'e', 00H, ' ', 00H, 'i', 00H, 'n', 00H, ' ', 00H
	DB	'h', 00H, 'e', 00H, 'x', 00H, 00H, 00H
	ORG $+6
$SG79055 DB	0aH, 00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, 's', 00H, 'y', 00H, 'm', 00H, 'b', 00H, 'o', 00H
	DB	'l', 00H, 'i', 00H, 'c', 00H, '_', 00H, 'l', 00H, 'i', 00H, 'n'
	DB	00H, 'k', 00H, ' ', 00H, ':', 00H, ' ', 00H, 's', 00H, 'y', 00H
	DB	'm', 00H, ' ', 00H, 'l', 00H, 'i', 00H, 'n', 00H, 'k', 00H, ' '
	DB	00H, 'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 't', 00H, 'h', 00H
	DB	'e', 00H, ' ', 00H, 'F', 00H, 'A', 00H, ' ', 00H, 'd', 00H, 'e'
	DB	00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG79056 DB	0aH, 00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	'G', 00H, 'e', 00H, 't', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, 'c', 00H, 'e', 00H, 'p', 00H, 't', 00H
	DB	'e', 00H, 'd', 00H, ' ', 00H, 'd', 00H, 'a', 00H, 't', 00H, 'a'
	DB	00H, ':', 00H, 00H, 00H
	ORG $+4
$SG79057 DB	0aH, 00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, 'T', 00H, 'e', 00H, 's'
	DB	00H, 't', 00H, 'C', 00H, 'l', 00H, 't', 00H, ' ', 00H, '/', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H, 'i'
	DB	00H, 't', 00H, ' ', 00H, 'o', 00H, 's', 00H, 'v', 00H, 'e', 00H
	DB	'r', 00H, ' ', 00H, 's', 00H, 'y', 00H, 'm', 00H, 'b', 00H, 'o'
	DB	00H, 'l', 00H, 'i', 00H, 'c', 00H, '_', 00H, 'l', 00H, 'i', 00H
	DB	'n', 00H, 'k', 00H, 00H, 00H
$SG79058 DB	0aH, 00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H, 'i', 00H
	DB	't', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ':', 00H, ' ', 00H, 'p', 00H, 'r', 00H
	DB	'o', 00H, 'c', 00H, 'e', 00H, 's', 00H, 's', 00H, 'o', 00H, 'r'
	DB	00H, ' ', 00H, 'a', 00H, 'r', 00H, 'c', 00H, 'h', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'u', 00H, 'r', 00H, 'e'
	DB	00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H, '6', 00H, ',', 00H
	DB	' ', 00H, 'x', 00H, '6', 00H, '4', 00H, ')', 00H, 00H, 00H
$SG79059 DB	0aH, 00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, 'o', 00H, 's', 00H, 'v', 00H, 'e', 00H, 'r', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, ' ', 00H, ':', 00H, ' ', 00H, 'w', 00H, 'i', 00H
	DB	'n', 00H, 'd', 00H, 'o', 00H, 'w', 00H, 's', 00H, ' ', 00H, 'v'
	DB	00H, 'e', 00H, 'r', 00H, 's', 00H, 'i', 00H, 'o', 00H, 'n', 00H
	DB	' ', 00H, '(', 00H, 'w', 00H, 'x', 00H, 'p', 00H, ',', 00H, ' '
	DB	00H, 'v', 00H, 'i', 00H, 's', 00H, 't', 00H, 'a', 00H, ',', 00H
	DB	' ', 00H, 'w', 00H, 'i', 00H, 'n', 00H, '7', 00H, ')', 00H, 00H
	DB	00H
	ORG $+6
$SG79060 DB	0aH, 00H, 0aH, 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H
	DB	' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' ', 00H, ' '
	DB	00H, ' ', 00H, 's', 00H, 'y', 00H, 'm', 00H, 'b', 00H, 'o', 00H
	DB	'l', 00H, 'i', 00H, 'c', 00H, '_', 00H, 'l', 00H, 'i', 00H, 'n'
	DB	00H, 'k', 00H, ' ', 00H, ':', 00H, ' ', 00H, 's', 00H, 'y', 00H
	DB	'm', 00H, ' ', 00H, 'l', 00H, 'i', 00H, 'n', 00H, 'k', 00H, ' '
	DB	00H, 'f', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 't', 00H, 'h', 00H
	DB	'e', 00H, ' ', 00H, 'F', 00H, 'A', 00H, ' ', 00H, 'd', 00H, 'e'
	DB	00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H, 00H, 00H
	ORG $+2
$SG79070 DB	',', 00H, ' ', 00H, 00H, 00H
	ORG $+6
$SG79088 DB	'F', 00H, 'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 't', 00H, 'o', 00H, ' ', 00H, 's', 00H, 'e', 00H, 'n'
	DB	00H, 'd', 00H, ' ', 00H, 'I', 00H, 'O', 00H, 'C', 00H, 'T', 00H
	DB	'L', 00H, '.', 00H, ' ', 00H, 'C', 00H, 'o', 00H, 'd', 00H, 'e'
	DB	00H, ':', 00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H, '8', 00H
	DB	'x', 00H, ',', 00H, ' ', 00H, 'G', 00H, 'e', 00H, 't', 00H, 'L'
	DB	00H, 'a', 00H, 's', 00H, 't', 00H, 'E', 00H, 'r', 00H, 'r', 00H
	DB	'o', 00H, 'r', 00H, '(', 00H, ')', 00H, ' ', 00H, '=', 00H, ' '
	DB	00H, '0', 00H, 'x', 00H, '%', 00H, '8', 00H, 'x', 00H, ',', 00H
	DB	' ', 00H, '(', 00H, '%', 00H, 'i', 00H, ')', 00H, 00H, 00H
_DATA	ENDS
PUBLIC	_GetData
PUBLIC	_DeviceControl
PUBLIC	_ListDevices
PUBLIC	_PrintHelp
PUBLIC	_CheckParams
PUBLIC	_wmain
EXTRN	_wprintf:PROC
; Function compile flags: /Odtp
; File b:\programm\wntsys\testfilter\release\1_1\source\testclt\testclt.c
_TEXT	SEGMENT
tv75 = -12						; size = 4
_RetCode$ = -8						; size = 4
_function$ = -4						; size = 2
_argC$ = 8						; size = 4
_lpwszArgV$ = 12					; size = 4
_lpwszEnvV$ = 16					; size = 4
_wmain	PROC

; 134  : int wmain( int argC, wchar_t *lpwszArgV[], wchar_t *lpwszEnvV[]) {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 135  : 
; 136  : 
; 137  : 	wchar_t	function;
; 138  : 	int		RetCode;
; 139  : 
; 140  : 	wprintf(L"\nTest client, compiled %S %S\n\n",__DATE__, __TIME__);

	push	OFFSET $SG78772
	push	OFFSET $SG78773
	push	OFFSET $SG78774
	call	_wprintf
	add	esp, 12					; 0000000cH

; 141  : 
; 142  : 	if (!CheckParams(argC, lpwszArgV)) {

	mov	eax, DWORD PTR _lpwszArgV$[ebp]
	push	eax
	mov	ecx, DWORD PTR _argC$[ebp]
	push	ecx
	call	_CheckParams
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN8@wmain

; 143  : 		PrintHelp();

	call	_PrintHelp

; 144  : 		return CLT_ERROR;

	mov	eax, 100				; 00000064H
	jmp	$LN9@wmain
$LN8@wmain:

; 145  : 	}
; 146  : 	function = *(lpwszArgV[1] + 1);

	mov	eax, DWORD PTR _lpwszArgV$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	dx, WORD PTR [ecx+2]
	mov	WORD PTR _function$[ebp], dx

; 147  : 	switch (function) {

	movzx	eax, WORD PTR _function$[ebp]
	mov	DWORD PTR tv75[ebp], eax
	mov	ecx, DWORD PTR tv75[ebp]
	sub	ecx, 99					; 00000063H
	mov	DWORD PTR tv75[ebp], ecx
	cmp	DWORD PTR tv75[ebp], 9
	ja	SHORT $LN1@wmain
	mov	edx, DWORD PTR tv75[ebp]
	movzx	eax, BYTE PTR $LN11@wmain[edx]
	jmp	DWORD PTR $LN12@wmain[eax*4]
$LN5@wmain:

; 148  : 		case CLTFUN_LIST:
; 149  : 			RetCode = ListDevices();

	call	_ListDevices
	mov	DWORD PTR _RetCode$[ebp], eax

; 150  : 			break;

	jmp	SHORT $LN6@wmain
$LN4@wmain:

; 151  : 		case CLTFUN_CONTROL:
; 152  : 			RetCode = DeviceControl(argC, lpwszArgV);

	mov	ecx, DWORD PTR _lpwszArgV$[ebp]
	push	ecx
	mov	edx, DWORD PTR _argC$[ebp]
	push	edx
	call	_DeviceControl
	add	esp, 8
	mov	DWORD PTR _RetCode$[ebp], eax

; 153  : 			break;

	jmp	SHORT $LN6@wmain
$LN3@wmain:

; 154  : 		case CLTFUN_GETDATA:
; 155  : 			RetCode = GetData(argC, lpwszArgV);

	mov	eax, DWORD PTR _lpwszArgV$[ebp]
	push	eax
	mov	ecx, DWORD PTR _argC$[ebp]
	push	ecx
	call	_GetData
	add	esp, 8
	mov	DWORD PTR _RetCode$[ebp], eax

; 156  : 			break;

	jmp	SHORT $LN6@wmain
$LN2@wmain:

; 157  : 		case CLTFUN_HELP:
; 158  : 			PrintHelp();

	call	_PrintHelp

; 159  : 			RetCode = 0;

	mov	DWORD PTR _RetCode$[ebp], 0

; 160  : 			break;

	jmp	SHORT $LN6@wmain
$LN1@wmain:

; 161  : 		default:
; 162  : 			wprintf(L"\nInvalid command: %s", lpwszArgV[1]);

	mov	edx, DWORD PTR _lpwszArgV$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	OFFSET $SG78785
	call	_wprintf
	add	esp, 8

; 163  : 			RetCode = CLT_ERROR;

	mov	DWORD PTR _RetCode$[ebp], 100		; 00000064H
$LN6@wmain:

; 164  : 	}
; 165  : 	return RetCode;

	mov	eax, DWORD PTR _RetCode$[ebp]
$LN9@wmain:

; 166  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@wmain:
	DD	$LN4@wmain
	DD	$LN3@wmain
	DD	$LN2@wmain
	DD	$LN5@wmain
	DD	$LN1@wmain
$LN11@wmain:
	DB	0
	DB	1
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	3
_wmain	ENDP
_TEXT	ENDS
EXTRN	_wcslen:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
tv83 = -4						; size = 4
_argC$ = 8						; size = 4
_lpwszArgV$ = 12					; size = 4
_CheckParams PROC

; 188  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 189  : 	if (argC < 2) {

	cmp	DWORD PTR _argC$[ebp], 2
	jge	SHORT $LN13@CheckParam

; 190  : 		wprintf(L"\n\nCommand missing\n");

	push	OFFSET $SG78792
	call	_wprintf
	add	esp, 4

; 191  : 		return FALSE;

	xor	al, al
	jmp	$LN14@CheckParam
$LN13@CheckParam:

; 192  : 	}
; 193  : 	if (wcslen(lpwszArgV[1]) != 2) {

	mov	eax, DWORD PTR _lpwszArgV$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	call	_wcslen
	add	esp, 4
	cmp	eax, 2
	je	SHORT $LN12@CheckParam

; 194  : 		wprintf(L"\n\nCommand format not valid: %s\n", lpwszArgV[1]);

	mov	edx, DWORD PTR _lpwszArgV$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	OFFSET $SG78794
	call	_wprintf
	add	esp, 8

; 195  : 		return FALSE;

	xor	al, al
	jmp	$LN14@CheckParam
$LN12@CheckParam:

; 196  : 	}
; 197  : 	if (*lpwszArgV[1] != L'/') {

	mov	ecx, DWORD PTR _lpwszArgV$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	movzx	eax, WORD PTR [edx]
	cmp	eax, 47					; 0000002fH
	je	SHORT $LN11@CheckParam

; 198  : 		wprintf(L"\n\nCommand format not valid: %s\n", lpwszArgV[1]);

	mov	ecx, DWORD PTR _lpwszArgV$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	OFFSET $SG78796
	call	_wprintf
	add	esp, 8

; 199  : 		return FALSE;

	xor	al, al
	jmp	$LN14@CheckParam
$LN11@CheckParam:

; 200  : 	}
; 201  : 	switch (*(lpwszArgV[1] + 1)) {

	mov	eax, DWORD PTR _lpwszArgV$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	movzx	edx, WORD PTR [ecx+2]
	mov	DWORD PTR tv83[ebp], edx
	mov	eax, DWORD PTR tv83[ebp]
	sub	eax, 99					; 00000063H
	mov	DWORD PTR tv83[ebp], eax
	cmp	DWORD PTR tv83[ebp], 9
	ja	$LN1@CheckParam
	mov	ecx, DWORD PTR tv83[ebp]
	movzx	edx, BYTE PTR $LN16@CheckParam[ecx]
	jmp	DWORD PTR $LN17@CheckParam[edx*4]
$LN8@CheckParam:

; 202  : 		case CLTFUN_LIST:
; 203  : 			return TRUE;

	mov	al, 1
	jmp	$LN14@CheckParam

; 204  : 			break;

	jmp	$LN14@CheckParam
$LN7@CheckParam:

; 205  : 		case CLTFUN_CONTROL:
; 206  : 			if (argC < 5) {

	cmp	DWORD PTR _argC$[ebp], 5
	jge	SHORT $LN6@CheckParam

; 207  : 				wprintf(L"\n\nMissing parameter(s)\n");

	push	OFFSET $SG78804
	call	_wprintf
	add	esp, 4

; 208  : 				return FALSE;

	xor	al, al
	jmp	SHORT $LN14@CheckParam
$LN6@CheckParam:

; 209  : 			}
; 210  : 			if ((*lpwszArgV[2] != CONTROL_SUBFUNC_GET) &&
; 211  : 				(*lpwszArgV[2] != CONTROL_SUBFUNC_SET)) {

	mov	eax, DWORD PTR _lpwszArgV$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 103				; 00000067H
	je	SHORT $LN5@CheckParam
	mov	eax, DWORD PTR _lpwszArgV$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	movzx	edx, WORD PTR [ecx]
	cmp	edx, 115				; 00000073H
	je	SHORT $LN5@CheckParam

; 212  : 				wprintf(L"\n\nInvalid subfunction code: %s\n",
; 213  : 					lpwszArgV[2]);

	mov	eax, DWORD PTR _lpwszArgV$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	OFFSET $SG78806
	call	_wprintf
	add	esp, 8

; 214  : 				return FALSE;

	xor	al, al
	jmp	SHORT $LN14@CheckParam
$LN5@CheckParam:

; 215  : 			}
; 216  : 			return TRUE;

	mov	al, 1
	jmp	SHORT $LN14@CheckParam

; 217  : 			break;

	jmp	SHORT $LN14@CheckParam
$LN4@CheckParam:

; 218  : 		case CLTFUN_GETDATA:
; 219  : 			if (argC < 4) {

	cmp	DWORD PTR _argC$[ebp], 4
	jge	SHORT $LN3@CheckParam

; 220  : 				wprintf(L"\n\nMissing parameter(s)\n");

	push	OFFSET $SG78809
	call	_wprintf
	add	esp, 4

; 221  : 				return FALSE;

	xor	al, al
	jmp	SHORT $LN14@CheckParam
$LN3@CheckParam:

; 222  : 			}
; 223  : 			return TRUE;

	mov	al, 1
	jmp	SHORT $LN14@CheckParam

; 224  : 			break;

	jmp	SHORT $LN14@CheckParam
$LN2@CheckParam:

; 225  : 		case CLTFUN_HELP:
; 226  : 			return TRUE;

	mov	al, 1
	jmp	SHORT $LN14@CheckParam

; 227  : 			break;

	jmp	SHORT $LN14@CheckParam
$LN1@CheckParam:

; 228  : 		default:
; 229  : 			wprintf(L"\n\nInvalid command: %s\n", lpwszArgV[1]);

	mov	edx, DWORD PTR _lpwszArgV$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	push	OFFSET $SG78812
	call	_wprintf
	add	esp, 8

; 230  : 			return FALSE;

	xor	al, al
$LN14@CheckParam:

; 231  : 	}
; 232  : }

	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN17@CheckParam:
	DD	$LN7@CheckParam
	DD	$LN4@CheckParam
	DD	$LN2@CheckParam
	DD	$LN8@CheckParam
	DD	$LN1@CheckParam
$LN16@CheckParam:
	DB	0
	DB	1
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	3
_CheckParams ENDP
_TEXT	ENDS
PUBLIC	_DCGetMJFFlags
; Function compile flags: /Odtp
_TEXT	SEGMENT
_argC$ = 8						; size = 4
_lpwszArgV$ = 12					; size = 4
_DCGetMJFFlags PROC

; 249  : {

	push	ebp
	mov	ebp, esp

; 250  : 	wprintf(L"\n\nTo be implemented...\n");

	push	OFFSET $SG78818
	call	_wprintf
	add	esp, 4

; 251  : 	return CLT_ERROR;

	mov	eax, 100				; 00000064H

; 252  : }

	pop	ebp
	ret	0
_DCGetMJFFlags ENDP
_TEXT	ENDS
PUBLIC	_SendIoCtl
PUBLIC	_OpenDevice
PUBLIC	_DCSetMJFFlags
EXTRN	_swscanf_s:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_MJFCtl$ = -20						; size = 8
_hFA$ = -12						; size = 4
_iFlags$ = -8						; size = 4
_iMajFun$ = -4						; size = 4
_argC$ = 8						; size = 4
_lpwszArgV$ = 12					; size = 4
_DCSetMJFFlags PROC

; 269  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 270  : 	// lpwszArgV[3] = MajorFunction
; 271  : 	// lpwszArgV[4] = flags
; 272  : 	// lpwszArgV[5] = device name
; 273  : 
; 274  : 	HANDLE		hFA;
; 275  : 	int			iMajFun;
; 276  : 	int			iFlags;
; 277  : 	MJF_CONTROL MJFCtl;
; 278  : 
; 279  : 	if (swscanf_s(lpwszArgV[3], L"0x%x", &iMajFun) != 1) {

	lea	eax, DWORD PTR _iMajFun$[ebp]
	push	eax
	push	OFFSET $SG78829
	mov	ecx, DWORD PTR _lpwszArgV$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_swscanf_s
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	je	SHORT $LN5@DCSetMJFFl

; 280  : 		wprintf(L"\nParameter parsing error: %s", lpwszArgV[3]);

	mov	eax, DWORD PTR _lpwszArgV$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	push	OFFSET $SG78830
	call	_wprintf
	add	esp, 8

; 281  : 		return CLT_ERROR;

	mov	eax, 100				; 00000064H
	jmp	$LN6@DCSetMJFFl
$LN5@DCSetMJFFl:

; 282  : 	}
; 283  : 	if (swscanf_s(lpwszArgV[4], L"0x%x", &iFlags) != 1) {

	lea	edx, DWORD PTR _iFlags$[ebp]
	push	edx
	push	OFFSET $SG78832
	mov	eax, DWORD PTR _lpwszArgV$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_swscanf_s
	add	esp, 12					; 0000000cH
	cmp	eax, 1
	je	SHORT $LN4@DCSetMJFFl

; 284  : 		wprintf(L"\nParameter parsing error: %s", lpwszArgV[4]);

	mov	edx, DWORD PTR _lpwszArgV$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	push	OFFSET $SG78833
	call	_wprintf
	add	esp, 8

; 285  : 		return CLT_ERROR;

	mov	eax, 100				; 00000064H
	jmp	SHORT $LN6@DCSetMJFFl
$LN4@DCSetMJFFl:

; 286  : 	}
; 287  : 	wprintf(L"\nSetting flags for MajorFunction = %#010x to %#010x",
; 288  : 		iMajFun,
; 289  : 		iFlags);

	mov	ecx, DWORD PTR _iFlags$[ebp]
	push	ecx
	mov	edx, DWORD PTR _iMajFun$[ebp]
	push	edx
	push	OFFSET $SG78834
	call	_wprintf
	add	esp, 12					; 0000000cH

; 290  : 	MJFCtl.MajorFunction = (UCHAR) iMajFun;

	mov	al, BYTE PTR _iMajFun$[ebp]
	mov	BYTE PTR _MJFCtl$[ebp], al

; 291  : 	MJFCtl.dwFlags = (DWORD) iFlags;

	mov	ecx, DWORD PTR _iFlags$[ebp]
	mov	DWORD PTR _MJFCtl$[ebp+4], ecx

; 292  : 	hFA = OpenDevice(lpwszArgV[5]);

	mov	edx, DWORD PTR _lpwszArgV$[ebp]
	mov	eax, DWORD PTR [edx+20]
	push	eax
	call	_OpenDevice
	add	esp, 4
	mov	DWORD PTR _hFA$[ebp], eax

; 293  : 	if (hFA == INVALID_HANDLE_VALUE) return CLT_ERROR;

	cmp	DWORD PTR _hFA$[ebp], -1
	jne	SHORT $LN3@DCSetMJFFl
	mov	eax, 100				; 00000064H
	jmp	SHORT $LN6@DCSetMJFFl
$LN3@DCSetMJFFl:

; 294  : 	if (!SendIoCtl(hFA, IOCTL_FILTER_SET_MJF_FLAGS, &MJFCtl, 
; 295  : 		sizeof MJFCtl, NULL, 0)) {

	push	0
	push	0
	push	8
	lea	ecx, DWORD PTR _MJFCtl$[ebp]
	push	ecx
	push	2269188					; 0022a004H
	mov	edx, DWORD PTR _hFA$[ebp]
	push	edx
	call	_SendIoCtl
	add	esp, 24					; 00000018H
	test	eax, eax
	jne	SHORT $LN2@DCSetMJFFl

; 296  : 		return CLT_ERROR;

	mov	eax, 100				; 00000064H
	jmp	SHORT $LN6@DCSetMJFFl

; 297  : 	} else {

	jmp	SHORT $LN6@DCSetMJFFl
$LN2@DCSetMJFFl:

; 298  : 		return 0;

	xor	eax, eax
$LN6@DCSetMJFFl:

; 299  : 	}
; 300  : 
; 301  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_DCSetMJFFlags ENDP
; Function compile flags: /Odtp
tv67 = -12						; size = 4
_ret$ = -8						; size = 4
_IoCtl$ = -4						; size = 2
_argC$ = 8						; size = 4
_lpwszArgV$ = 12					; size = 4
_DeviceControl PROC

; 318  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 319  : 	int ret;
; 320  : 	WCHAR	IoCtl;
; 321  : 	IoCtl = *lpwszArgV[2];

	mov	eax, DWORD PTR _lpwszArgV$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	dx, WORD PTR [ecx]
	mov	WORD PTR _IoCtl$[ebp], dx

; 322  : 
; 323  : 	switch (IoCtl) {

	movzx	eax, WORD PTR _IoCtl$[ebp]
	mov	DWORD PTR tv67[ebp], eax
	cmp	DWORD PTR tv67[ebp], 103		; 00000067H
	je	SHORT $LN3@DeviceCont
	cmp	DWORD PTR tv67[ebp], 115		; 00000073H
	je	SHORT $LN2@DeviceCont
	jmp	SHORT $LN1@DeviceCont
$LN3@DeviceCont:

; 324  : 		case CONTROL_SUBFUNC_GET:
; 325  : 			ret = DCGetMJFFlags(argC, lpwszArgV);

	mov	ecx, DWORD PTR _lpwszArgV$[ebp]
	push	ecx
	mov	edx, DWORD PTR _argC$[ebp]
	push	edx
	call	_DCGetMJFFlags
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 326  : 			break;

	jmp	SHORT $LN4@DeviceCont
$LN2@DeviceCont:

; 327  : 		case CONTROL_SUBFUNC_SET:
; 328  : 			ret = DCSetMJFFlags(argC, lpwszArgV);

	mov	eax, DWORD PTR _lpwszArgV$[ebp]
	push	eax
	mov	ecx, DWORD PTR _argC$[ebp]
	push	ecx
	call	_DCSetMJFFlags
	add	esp, 8
	mov	DWORD PTR _ret$[ebp], eax

; 329  : 			break;

	jmp	SHORT $LN4@DeviceCont
$LN1@DeviceCont:

; 330  : 		default:
; 331  : 			wprintf(L"\nInvalid IOCTL code: %c", IoCtl);

	movzx	edx, WORD PTR _IoCtl$[ebp]
	push	edx
	push	OFFSET $SG78857
	call	_wprintf
	add	esp, 8

; 332  : 			ret = CLT_ERROR;

	mov	DWORD PTR _ret$[ebp], 100		; 00000064H
$LN4@DeviceCont:

; 333  : 	}
; 334  : 	return ret;

	mov	eax, DWORD PTR _ret$[ebp]

; 335  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_DeviceControl ENDP
_TEXT	ENDS
PUBLIC	_DumpIoStackLocData
EXTRN	_FreeFmtStack:PROC
EXTRN	_FormatIoStack:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_pFStack$ = -8						; size = 4
_pScan$ = -4						; size = 4
_pStackData$ = 8					; size = 4
_Arch$ = 12						; size = 4
_OsVer$ = 16						; size = 4
_DumpIoStackLocData PROC

; 354  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 355  : 	PWCHAR		pFStack, pScan;
; 356  : 	if (FormatIoStack(pStackData, &pFStack, Arch, OsVer)) {

	mov	eax, DWORD PTR _OsVer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Arch$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pFStack$[ebp]
	push	edx
	mov	eax, DWORD PTR _pStackData$[ebp]
	push	eax
	call	_FormatIoStack
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN5@DumpIoStac

; 357  : 		for (pScan = pFStack;*pScan != L'\0';pScan += wcslen(pScan) + 1) {

	mov	ecx, DWORD PTR _pFStack$[ebp]
	mov	DWORD PTR _pScan$[ebp], ecx
	jmp	SHORT $LN3@DumpIoStac
$LN2@DumpIoStac:
	mov	edx, DWORD PTR _pScan$[ebp]
	push	edx
	call	_wcslen
	add	esp, 4
	mov	ecx, DWORD PTR _pScan$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2+2]
	mov	DWORD PTR _pScan$[ebp], edx
$LN3@DumpIoStac:
	mov	eax, DWORD PTR _pScan$[ebp]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1@DumpIoStac

; 358  : 			wprintf(L"%s\n", pScan);

	mov	edx, DWORD PTR _pScan$[ebp]
	push	edx
	push	OFFSET $SG78871
	call	_wprintf
	add	esp, 8

; 359  : 		}

	jmp	SHORT $LN2@DumpIoStac
$LN1@DumpIoStac:

; 360  : 		FreeFmtStack(pFStack);

	mov	eax, DWORD PTR _pFStack$[ebp]
	push	eax
	call	_FreeFmtStack
	add	esp, 4
$LN5@DumpIoStac:

; 361  : 	}
; 362  : 	return;
; 363  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_DumpIoStackLocData ENDP
_TEXT	ENDS
PUBLIC	_DumpMemory
PUBLIC	_DumpIrpData
PUBLIC	_DumpIrp
EXTRN	_IoStackSize:PROC
EXTRN	_IrpSize:PROC
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_IrpHea$ = -12						; size = 8
_offset$ = -4						; size = 4
_pIrpData$ = 8						; size = 4
_len$ = 12						; size = 4
_Arch$ = 16						; size = 4
_OsVer$ = 20						; size = 4
_DumpIrp PROC

; 373  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 374  : 	IRP_HEADER	IrpHea;
; 375  : 	SIZE_T		offset;
; 376  : 
; 377  : 	memcpy(&IrpHea, pIrpData, sizeof IrpHea);

	push	8
	mov	eax, DWORD PTR _pIrpData$[ebp]
	push	eax
	lea	ecx, DWORD PTR _IrpHea$[ebp]
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 378  : 	wprintf(L"\n\n---------------------------------------");

	push	OFFSET $SG78883
	call	_wprintf
	add	esp, 4

; 379  : 	wprintf(L"\n\nTraced IRP");

	push	OFFSET $SG78884
	call	_wprintf
	add	esp, 4

; 380  : 	wprintf(L"\n\nData Length: %#x", IrpHea.cbDataLen);

	mov	edx, DWORD PTR _IrpHea$[ebp+4]
	push	edx
	push	OFFSET $SG78885
	call	_wprintf
	add	esp, 8

; 381  : 	wprintf(L"\n\nIRP:\n\n");

	push	OFFSET $SG78886
	call	_wprintf
	add	esp, 4

; 382  : 	offset = sizeof(IRP_HEADER);

	mov	DWORD PTR _offset$[ebp], 8

; 383  : 	DumpIrpData(pIrpData + offset, Arch, OsVer);

	mov	eax, DWORD PTR _OsVer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Arch$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pIrpData$[ebp]
	add	edx, DWORD PTR _offset$[ebp]
	push	edx
	call	_DumpIrpData
	add	esp, 12					; 0000000cH

; 384  : 	offset += IrpSize(Arch, OsVer);

	mov	eax, DWORD PTR _OsVer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Arch$[ebp]
	push	ecx
	call	_IrpSize
	add	esp, 8
	add	eax, DWORD PTR _offset$[ebp]
	mov	DWORD PTR _offset$[ebp], eax

; 385  : 	wprintf(L"\n\nI/O Stack location:\n\n");

	push	OFFSET $SG78888
	call	_wprintf
	add	esp, 4

; 386  : 	DumpIoStackLocData(pIrpData + offset, Arch, OsVer);

	mov	edx, DWORD PTR _OsVer$[ebp]
	push	edx
	mov	eax, DWORD PTR _Arch$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pIrpData$[ebp]
	add	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	call	_DumpIoStackLocData
	add	esp, 12					; 0000000cH

; 387  : 	offset += IoStackSize(Arch, OsVer);

	mov	edx, DWORD PTR _OsVer$[ebp]
	push	edx
	mov	eax, DWORD PTR _Arch$[ebp]
	push	eax
	call	_IoStackSize
	add	esp, 8
	add	eax, DWORD PTR _offset$[ebp]
	mov	DWORD PTR _offset$[ebp], eax

; 388  : 	DumpMemory(pIrpData + offset, len - offset);

	mov	ecx, DWORD PTR _len$[ebp]
	sub	ecx, DWORD PTR _offset$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pIrpData$[ebp]
	add	edx, DWORD PTR _offset$[ebp]
	push	edx
	call	_DumpMemory
	add	esp, 8

; 389  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_DumpIrp ENDP
_TEXT	ENDS
EXTRN	_FreeFmtIrp:PROC
EXTRN	_FormatIrp:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_pFIrp$ = -8						; size = 4
_pScan$ = -4						; size = 4
_pIrpData$ = 8						; size = 4
_Arch$ = 12						; size = 4
_OsVer$ = 16						; size = 4
_DumpIrpData PROC

; 407  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 408  : 	PWCHAR		pFIrp, pScan;
; 409  : 	if (FormatIrp(pIrpData, &pFIrp, Arch, OsVer)) {

	mov	eax, DWORD PTR _OsVer$[ebp]
	push	eax
	mov	ecx, DWORD PTR _Arch$[ebp]
	push	ecx
	lea	edx, DWORD PTR _pFIrp$[ebp]
	push	edx
	mov	eax, DWORD PTR _pIrpData$[ebp]
	push	eax
	call	_FormatIrp
	add	esp, 16					; 00000010H
	test	eax, eax
	je	SHORT $LN5@DumpIrpDat

; 410  : 		for (pScan = pFIrp;*pScan != L'\0';pScan += wcslen(pScan) + 1) {

	mov	ecx, DWORD PTR _pFIrp$[ebp]
	mov	DWORD PTR _pScan$[ebp], ecx
	jmp	SHORT $LN3@DumpIrpDat
$LN2@DumpIrpDat:
	mov	edx, DWORD PTR _pScan$[ebp]
	push	edx
	call	_wcslen
	add	esp, 4
	mov	ecx, DWORD PTR _pScan$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2+2]
	mov	DWORD PTR _pScan$[ebp], edx
$LN3@DumpIrpDat:
	mov	eax, DWORD PTR _pScan$[ebp]
	movzx	ecx, WORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN1@DumpIrpDat

; 411  : 			wprintf(L"%s\n", pScan);

	mov	edx, DWORD PTR _pScan$[ebp]
	push	edx
	push	OFFSET $SG78902
	call	_wprintf
	add	esp, 8

; 412  : 		}

	jmp	SHORT $LN2@DumpIrpDat
$LN1@DumpIrpDat:

; 413  : 		FreeFmtIrp(pFIrp);

	mov	eax, DWORD PTR _pFIrp$[ebp]
	push	eax
	call	_FreeFmtIrp
	add	esp, 4
$LN5@DumpIrpDat:

; 414  : 	}
; 415  : 	return;
; 416  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_DumpIrpData ENDP
_TEXT	ENDS
EXTRN	_printf:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_ch$78923 = -13						; size = 1
_j$ = -12						; size = 4
_i$ = -8						; size = 4
_value$ = -4						; size = 4
_pMem$ = 8						; size = 4
_cbLen$ = 12						; size = 4
_DumpMemory PROC

; 423  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 424  : 	UINT i, j, value;
; 425  : 	for (i = 0; i < cbLen; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN10@DumpMemory
$LN9@DumpMemory:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN10@DumpMemory:
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR _cbLen$[ebp]
	jae	$LN11@DumpMemory

; 426  : 		if (i % BYTES_PER_LINE == 0) printf ("\n0x%08x -", i);

	mov	eax, DWORD PTR _i$[ebp]
	xor	edx, edx
	mov	ecx, 16					; 00000010H
	div	ecx
	test	edx, edx
	jne	SHORT $LN7@DumpMemory
	mov	edx, DWORD PTR _i$[ebp]
	push	edx
	push	OFFSET $SG78915
	call	_printf
	add	esp, 8
$LN7@DumpMemory:

; 427  : 		value = (UCHAR) *(pMem + i);

	mov	eax, DWORD PTR _pMem$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	movzx	ecx, BYTE PTR [eax]
	mov	DWORD PTR _value$[ebp], ecx

; 428  : 		printf(" %02x", value);

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	push	OFFSET $SG78917
	call	_printf
	add	esp, 8

; 429  : 		if (((i + 1) % BYTES_PER_LINE == 0) && (i > 0)) {

	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	xor	edx, edx
	mov	ecx, 16					; 00000010H
	div	ecx
	test	edx, edx
	jne	SHORT $LN6@DumpMemory
	cmp	DWORD PTR _i$[ebp], 0
	jbe	SHORT $LN6@DumpMemory

; 430  : 			printf(" -- ");

	push	OFFSET $SG78919
	call	_printf
	add	esp, 4

; 431  : 			for (j = 0; j < BYTES_PER_LINE; j++) {

	mov	DWORD PTR _j$[ebp], 0
	jmp	SHORT $LN5@DumpMemory
$LN4@DumpMemory:
	mov	edx, DWORD PTR _j$[ebp]
	add	edx, 1
	mov	DWORD PTR _j$[ebp], edx
$LN5@DumpMemory:
	cmp	DWORD PTR _j$[ebp], 16			; 00000010H
	jae	SHORT $LN6@DumpMemory

; 432  : 				CHAR ch = *(pMem + i - BYTES_PER_LINE + 1 + j);

	mov	eax, DWORD PTR _pMem$[ebp]
	add	eax, DWORD PTR _i$[ebp]
	mov	ecx, DWORD PTR _j$[ebp]
	mov	dl, BYTE PTR [eax+ecx-15]
	mov	BYTE PTR _ch$78923[ebp], dl

; 433  : 				if (ch < 0x20) {

	movsx	eax, BYTE PTR _ch$78923[ebp]
	cmp	eax, 32					; 00000020H
	jge	SHORT $LN2@DumpMemory

; 434  : 					printf(".");

	push	OFFSET $SG78925
	call	_printf
	add	esp, 4

; 435  : 				} else {

	jmp	SHORT $LN1@DumpMemory
$LN2@DumpMemory:

; 436  : 					printf("%c", ch);

	movsx	ecx, BYTE PTR _ch$78923[ebp]
	push	ecx
	push	OFFSET $SG78927
	call	_printf
	add	esp, 8
$LN1@DumpMemory:

; 437  : 				}
; 438  : 			}

	jmp	SHORT $LN4@DumpMemory
$LN6@DumpMemory:

; 439  : 		}
; 440  : 	}

	jmp	$LN9@DumpMemory
$LN11@DumpMemory:

; 441  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_DumpMemory ENDP
_TEXT	ENDS
PUBLIC	_HeapAllocWrap
PUBLIC	_GetProcessHeapWrap
EXTRN	__imp__HeapFree@12:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__ReadFile@20:PROC
EXTRN	_wcscmp:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_dwBytesRead$ = -28					; size = 4
_Arch$ = -24						; size = 4
_hHeap$ = -20						; size = 4
_Ret$ = -16						; size = 4
_OsVer$ = -12						; size = 4
_pData$ = -8						; size = 4
_hDevice$ = -4						; size = 4
_argC$ = 8						; size = 4
_lpwszArgV$ = 12					; size = 4
_GetData PROC

; 460  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 461  : 	// lpwszArgV[2] = archit
; 462  : 	// lpwszArgV[3] = OS ver
; 463  : 	// lpwszArgV[4] = dev name
; 464  : 
; 465  : 	ARCHIT	Arch;
; 466  :     HANDLE  hDevice = INVALID_HANDLE_VALUE;

	mov	DWORD PTR _hDevice$[ebp], -1

; 467  : 	HANDLE	hHeap;
; 468  : 	DWORD	dwBytesRead;
; 469  : 	OSVER	OsVer;
; 470  : 	PCHAR	pData = NULL;

	mov	DWORD PTR _pData$[ebp], 0

; 471  : 	int		Ret = CLT_ERROR;

	mov	DWORD PTR _Ret$[ebp], 100		; 00000064H

; 472  : 
; 473  : 	if (!wcscmp(lpwszArgV[2], ARCH_STR_X86)) {

	push	OFFSET $SG78944
	mov	eax, DWORD PTR _lpwszArgV$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_wcscmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN18@GetData

; 474  : 		Arch = ARCH_X86;

	mov	DWORD PTR _Arch$[ebp], 0
	jmp	SHORT $LN17@GetData
$LN18@GetData:

; 475  : 	} else if (!wcscmp(lpwszArgV[2], ARCH_STR_X64)) {

	push	OFFSET $SG78947
	mov	edx, DWORD PTR _lpwszArgV$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	call	_wcscmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN16@GetData

; 476  : 		Arch = ARCH_X64;

	mov	DWORD PTR _Arch$[ebp], 1

; 477  : 	} else {

	jmp	SHORT $LN17@GetData
$LN16@GetData:

; 478  : 		wprintf(L"\nInvalid processor architecture: \"%s\"",
; 479  : 			lpwszArgV[2]);

	mov	ecx, DWORD PTR _lpwszArgV$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	push	edx
	push	OFFSET $SG78949
	call	_wprintf
	add	esp, 8

; 480  : 		return CLT_ERROR;

	mov	eax, 100				; 00000064H
	jmp	$LN19@GetData
$LN17@GetData:

; 481  : 	}
; 482  : 
; 483  : 	if (!wcscmp(lpwszArgV[3], OSVER_STR_WXP)) {

	push	OFFSET $SG78951
	mov	eax, DWORD PTR _lpwszArgV$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_wcscmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN14@GetData

; 484  : 		OsVer = OSVER_XP;

	mov	DWORD PTR _OsVer$[ebp], 0
	jmp	SHORT $LN13@GetData
$LN14@GetData:

; 485  : 	} else if (!wcscmp(lpwszArgV[3], OSVER_STR_WLH)) {

	push	OFFSET $SG78954
	mov	edx, DWORD PTR _lpwszArgV$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	_wcscmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN12@GetData

; 486  : 		OsVer = OSVER_VISTA;

	mov	DWORD PTR _OsVer$[ebp], 1
	jmp	SHORT $LN13@GetData
$LN12@GetData:

; 487  : 	} else if (!wcscmp(lpwszArgV[3], OSVER_STR_WIN7)) {

	push	OFFSET $SG78957
	mov	ecx, DWORD PTR _lpwszArgV$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	call	_wcscmp
	add	esp, 8
	test	eax, eax
	jne	SHORT $LN10@GetData

; 488  : 		OsVer = OSVER_WIN7;

	mov	DWORD PTR _OsVer$[ebp], 2

; 489  : 	} else {

	jmp	SHORT $LN13@GetData
$LN10@GetData:

; 490  : 		wprintf(L"\nInvalid Windows Version: \"%s\"",
; 491  : 			lpwszArgV[3]);

	mov	eax, DWORD PTR _lpwszArgV$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	push	OFFSET $SG78959
	call	_wprintf
	add	esp, 8

; 492  : 		return CLT_ERROR;

	mov	eax, 100				; 00000064H
	jmp	$LN19@GetData
$LN13@GetData:

; 493  : 	}
; 494  : 
; 495  : 
; 496  : 	if (!GetProcessHeapWrap(&hHeap)) {

	lea	edx, DWORD PTR _hHeap$[ebp]
	push	edx
	call	_GetProcessHeapWrap
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN8@GetData

; 497  : 		return CLT_ERROR;

	mov	eax, 100				; 00000064H
	jmp	$LN19@GetData
$LN8@GetData:

; 498  : 	}
; 499  : 	if (!HeapAllocWrap(hHeap, DATA_BUFFER_SIZE, &pData)) {

	lea	eax, DWORD PTR _pData$[ebp]
	push	eax
	push	65536					; 00010000H
	mov	ecx, DWORD PTR _hHeap$[ebp]
	push	ecx
	call	_HeapAllocWrap
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN7@GetData

; 500  : 		return CLT_ERROR;

	mov	eax, 100				; 00000064H
	jmp	$LN19@GetData
$LN7@GetData:

; 501  : 	}
; 502  : 	hDevice = OpenDevice(lpwszArgV[4]);

	mov	edx, DWORD PTR _lpwszArgV$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	_OpenDevice
	add	esp, 4
	mov	DWORD PTR _hDevice$[ebp], eax

; 503  : 	if (hDevice == INVALID_HANDLE_VALUE) goto CLEANUP;

	cmp	DWORD PTR _hDevice$[ebp], -1
	jne	SHORT $LN6@GetData
	jmp	SHORT $CLEANUP$78965
$LN6@GetData:

; 504  : 	_tprintf(TEXT("Device succesfully opened\n"));

	push	OFFSET $SG78966
	call	_wprintf
	add	esp, 4
$LN5@GetData:

; 505  : 	for (;;) {
; 506  : 		if (ReadFile(hDevice, pData, DATA_BUFFER_SIZE, &dwBytesRead, 
; 507  : 			NULL)) {

	push	0
	lea	ecx, DWORD PTR _dwBytesRead$[ebp]
	push	ecx
	push	65536					; 00010000H
	mov	edx, DWORD PTR _pData$[ebp]
	push	edx
	mov	eax, DWORD PTR _hDevice$[ebp]
	push	eax
	call	DWORD PTR __imp__ReadFile@20
	test	eax, eax
	je	SHORT $LN3@GetData

; 508  : 			DumpIrp(pData, dwBytesRead, Arch, OsVer);

	mov	ecx, DWORD PTR _OsVer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _Arch$[ebp]
	push	edx
	mov	eax, DWORD PTR _dwBytesRead$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pData$[ebp]
	push	ecx
	call	_DumpIrp
	add	esp, 16					; 00000010H
$LN3@GetData:

; 509  : 		}
; 510  : 	}

	jmp	SHORT $LN5@GetData

; 511  : 	Ret = 0;

	mov	DWORD PTR _Ret$[ebp], 0
$CLEANUP$78965:

; 512  : CLEANUP:
; 513  : 	
; 514  : 	if (hDevice != INVALID_HANDLE_VALUE) CloseHandle(hDevice);

	cmp	DWORD PTR _hDevice$[ebp], -1
	je	SHORT $LN2@GetData
	mov	edx, DWORD PTR _hDevice$[ebp]
	push	edx
	call	DWORD PTR __imp__CloseHandle@4
$LN2@GetData:

; 515  : 	if (pData != NULL) HeapFree(hHeap, 0, pData);

	cmp	DWORD PTR _pData$[ebp], 0
	je	SHORT $LN1@GetData
	mov	eax, DWORD PTR _pData$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _hHeap$[ebp]
	push	ecx
	call	DWORD PTR __imp__HeapFree@12
$LN1@GetData:

; 516  : 	return Ret;

	mov	eax, DWORD PTR _Ret$[ebp]
$LN19@GetData:

; 517  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_GetData ENDP
_TEXT	ENDS
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__GetProcessHeap@0:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_dwLastErr$ = -4					; size = 4
_phHeap$ = 8						; size = 4
_GetProcessHeapWrap PROC

; 533  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 534  : 	DWORD dwLastErr;
; 535  : 	*phHeap = GetProcessHeap();

	call	DWORD PTR __imp__GetProcessHeap@0
	mov	ecx, DWORD PTR _phHeap$[ebp]
	mov	DWORD PTR [ecx], eax

; 536  : 	if (*phHeap == NULL) {

	mov	edx, DWORD PTR _phHeap$[ebp]
	cmp	DWORD PTR [edx], 0
	jne	SHORT $LN2@GetProcess

; 537  : 		dwLastErr = GetLastError();

	call	DWORD PTR __imp__GetLastError@0
	mov	DWORD PTR _dwLastErr$[ebp], eax

; 538  : 		wprintf(
; 539  : 			L"\nGetProcessHeap failed; GetLastError() = %#010x (%d)",
; 540  : 			dwLastErr,
; 541  : 			dwLastErr);

	mov	eax, DWORD PTR _dwLastErr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _dwLastErr$[ebp]
	push	ecx
	push	OFFSET $SG78983
	call	_wprintf
	add	esp, 12					; 0000000cH

; 542  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN3@GetProcess

; 543  : 	} else {

	jmp	SHORT $LN3@GetProcess
$LN2@GetProcess:

; 544  : 		return TRUE;

	mov	eax, 1
$LN3@GetProcess:

; 545  : 	}
; 546  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_GetProcessHeapWrap ENDP
_TEXT	ENDS
EXTRN	__imp__HeapAlloc@12:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_hHeap$ = 8						; size = 4
_cbSize$ = 12						; size = 4
_ppBuf$ = 16						; size = 4
_HeapAllocWrap PROC

; 564  : {

	push	ebp
	mov	ebp, esp

; 565  : 	*ppBuf = HeapAlloc(hHeap, 0, cbSize);

	mov	eax, DWORD PTR _cbSize$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _hHeap$[ebp]
	push	ecx
	call	DWORD PTR __imp__HeapAlloc@12
	mov	edx, DWORD PTR _ppBuf$[ebp]
	mov	DWORD PTR [edx], eax

; 566  : 	if (*ppBuf == NULL) {

	mov	eax, DWORD PTR _ppBuf$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN2@HeapAllocW

; 567  : 		wprintf(L"\nHeapAlloc failed");

	push	OFFSET $SG78994
	call	_wprintf
	add	esp, 4

; 568  : 		return FALSE;

	xor	eax, eax
	jmp	SHORT $LN3@HeapAllocW

; 569  : 	} else {

	jmp	SHORT $LN3@HeapAllocW
$LN2@HeapAllocW:

; 570  : 		return TRUE;

	mov	eax, 1
$LN3@HeapAllocW:

; 571  : 	}
; 572  : }

	pop	ebp
	ret	0
_HeapAllocWrap ENDP
_TEXT	ENDS
PUBLIC	_PrintAccDevList
; Function compile flags: /Odtp
_TEXT	SEGMENT
_dwBytesRead$ = -16					; size = 4
_hHeap$ = -12						; size = 4
_hMasterDev$ = -8					; size = 4
_pAdl$ = -4						; size = 4
_ListDevices PROC

; 578  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 579  : 	DWORD					dwBytesRead;
; 580  : 	HANDLE					hHeap;
; 581  : 	HANDLE					hMasterDev;
; 582  : 	PACCESS_DEVICES_LIST	pAdl;
; 583  : 
; 584  : 	hMasterDev = OpenDevice(MASTER_DEVICE_NAME);

	push	OFFSET $SG79001
	call	_OpenDevice
	add	esp, 4
	mov	DWORD PTR _hMasterDev$[ebp], eax

; 585  : 	if (hMasterDev == INVALID_HANDLE_VALUE) return FALSE;

	cmp	DWORD PTR _hMasterDev$[ebp], -1
	jne	SHORT $LN4@ListDevice
	xor	eax, eax
	jmp	SHORT $LN5@ListDevice
$LN4@ListDevice:

; 586  : 	if (!GetProcessHeapWrap(&hHeap)) return FALSE;

	lea	eax, DWORD PTR _hHeap$[ebp]
	push	eax
	call	_GetProcessHeapWrap
	add	esp, 4
	test	eax, eax
	jne	SHORT $LN3@ListDevice
	xor	eax, eax
	jmp	SHORT $LN5@ListDevice
$LN3@ListDevice:

; 587  : 	if (!HeapAllocWrap(
; 588  : 		hHeap,
; 589  : 		4096, 
; 590  : 		&pAdl)) return FALSE;

	lea	ecx, DWORD PTR _pAdl$[ebp]
	push	ecx
	push	4096					; 00001000H
	mov	edx, DWORD PTR _hHeap$[ebp]
	push	edx
	call	_HeapAllocWrap
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN2@ListDevice
	xor	eax, eax
	jmp	SHORT $LN5@ListDevice
$LN2@ListDevice:

; 591  : 	if (ReadFile(hMasterDev, pAdl, 4096, &dwBytesRead, NULL)) {

	push	0
	lea	eax, DWORD PTR _dwBytesRead$[ebp]
	push	eax
	push	4096					; 00001000H
	mov	ecx, DWORD PTR _pAdl$[ebp]
	push	ecx
	mov	edx, DWORD PTR _hMasterDev$[ebp]
	push	edx
	call	DWORD PTR __imp__ReadFile@20
	test	eax, eax
	je	SHORT $LN1@ListDevice

; 592  : 		PrintAccDevList((PACCESS_DEVICES_LIST) pAdl);

	mov	eax, DWORD PTR _pAdl$[ebp]
	push	eax
	call	_PrintAccDevList
	add	esp, 4
$LN1@ListDevice:

; 593  : 	}
; 594  : 	return TRUE;

	mov	eax, 1
$LN5@ListDevice:

; 595  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_ListDevices ENDP
_TEXT	ENDS
PUBLIC	_StringCbPrintfW
PUBLIC	__$ArrayPad$
EXTRN	__imp__CreateFileW@28:PROC
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_wszDevPath$ = -1024					; size = 1002
__$ArrayPad$ = -12					; size = 4
_res$ = -8						; size = 4
_hDevice$ = -4						; size = 4
_lpwszDevName$ = 8					; size = 4
_OpenDevice PROC

; 601  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 1024				; 00000400H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 602  : 	HANDLE		hDevice;
; 603  : 	WCHAR		wszDevPath[501];
; 604  : 
; 605  : 	HRESULT res = StringCbPrintfW(
; 606  : 		wszDevPath,
; 607  : 		sizeof wszDevPath,
; 608  : 		L"\\\\.\\%s",
; 609  : 		lpwszDevName);

	mov	eax, DWORD PTR _lpwszDevName$[ebp]
	push	eax
	push	OFFSET $SG79016
	push	1002					; 000003eaH
	lea	ecx, DWORD PTR _wszDevPath$[ebp]
	push	ecx
	call	_StringCbPrintfW
	add	esp, 16					; 00000010H
	mov	DWORD PTR _res$[ebp], eax

; 610  : 	if (!SUCCEEDED(res)) {

	cmp	DWORD PTR _res$[ebp], 0
	jge	SHORT $LN2@OpenDevice

; 611  : 		wprintf(L"\nOpenDevice - StringCbPrintfW() returned %#x", res);

	mov	edx, DWORD PTR _res$[ebp]
	push	edx
	push	OFFSET $SG79019
	call	_wprintf
	add	esp, 8

; 612  : 		return INVALID_HANDLE_VALUE;

	or	eax, -1
	jmp	SHORT $LN3@OpenDevice
$LN2@OpenDevice:

; 613  : 	}
; 614  : 
; 615  :     hDevice =
; 616  :         CreateFile( wszDevPath,
; 617  : 					GENERIC_READ | GENERIC_WRITE,
; 618  : 					FILE_SHARE_READ | FILE_SHARE_WRITE,
; 619  : 					NULL,	// no security
; 620  : 					OPEN_EXISTING,
; 621  : 					FILE_ATTRIBUTE_NORMAL,
; 622  : 					NULL );		// no template

	push	0
	push	128					; 00000080H
	push	3
	push	0
	push	3
	push	-1073741824				; c0000000H
	lea	eax, DWORD PTR _wszDevPath$[ebp]
	push	eax
	call	DWORD PTR __imp__CreateFileW@28
	mov	DWORD PTR _hDevice$[ebp], eax

; 623  : 
; 624  : 	if ( hDevice == INVALID_HANDLE_VALUE ) {

	cmp	DWORD PTR _hDevice$[ebp], -1
	jne	SHORT $LN1@OpenDevice

; 625  : 		wprintf( L"Failed to obtain file handle to %ls. "
; 626  : 			L"GetLastError() = %d (0x%x)\n",
; 627  : 			lpwszDevName,
; 628  : 			GetLastError(),
; 629  : 			GetLastError());

	call	DWORD PTR __imp__GetLastError@0
	push	eax
	call	DWORD PTR __imp__GetLastError@0
	push	eax
	mov	ecx, DWORD PTR _lpwszDevName$[ebp]
	push	ecx
	push	OFFSET $SG79027
	call	_wprintf
	add	esp, 16					; 00000010H

; 630  :         return hDevice;

	mov	eax, DWORD PTR _hDevice$[ebp]
	jmp	SHORT $LN3@OpenDevice
$LN1@OpenDevice:

; 631  : 	}
; 632  :     return hDevice;

	mov	eax, DWORD PTR _hDevice$[ebp]
$LN3@OpenDevice:

; 633  : 
; 634  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_OpenDevice ENDP
; Function compile flags: /Odtp
; File c:\apps\pw7hp\devpgm\mssdk\include\strsafe.h
_TEXT	ENDS
;	COMDAT _StringCbPrintfW
_TEXT	SEGMENT
_argList$77421 = -12					; size = 4
_cchDest$ = -8						; size = 4
_hr$ = -4						; size = 4
_pszDest$ = 8						; size = 4
_cbDest$ = 12						; size = 4
_pszFormat$ = 16					; size = 4
_StringCbPrintfW PROC					; COMDAT

; 4797 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 4798 :     HRESULT hr;
; 4799 :     size_t cchDest = cbDest / sizeof(wchar_t);

	mov	eax, DWORD PTR _cbDest$[ebp]
	shr	eax, 1
	mov	DWORD PTR _cchDest$[ebp], eax

; 4800 : 
; 4801 :     hr = StringValidateDestW(pszDest, cchDest, STRSAFE_MAX_CCH);

	push	2147483647				; 7fffffffH
	mov	ecx, DWORD PTR _cchDest$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszDest$[ebp]
	push	edx
	call	_StringValidateDestW@12
	mov	DWORD PTR _hr$[ebp], eax

; 4802 :     
; 4803 :     if (SUCCEEDED(hr))

	cmp	DWORD PTR _hr$[ebp], 0
	jl	SHORT $LN1@StringCbPr

; 4804 :     {
; 4805 :         va_list argList;
; 4806 : 
; 4807 :         va_start(argList, pszFormat);

	lea	eax, DWORD PTR _pszFormat$[ebp+4]
	mov	DWORD PTR _argList$77421[ebp], eax

; 4808 : 
; 4809 :         hr = StringVPrintfWorkerW(pszDest,
; 4810 :                                   cchDest,
; 4811 :                                   NULL,
; 4812 :                                   pszFormat,
; 4813 :                                   argList);

	mov	ecx, DWORD PTR _argList$77421[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszFormat$[ebp]
	push	edx
	push	0
	mov	eax, DWORD PTR _cchDest$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszDest$[ebp]
	push	ecx
	call	_StringVPrintfWorkerW@20
	mov	DWORD PTR _hr$[ebp], eax

; 4814 : 
; 4815 :         va_end(argList);

	mov	DWORD PTR _argList$77421[ebp], 0
$LN1@StringCbPr:

; 4816 :     }
; 4817 : 
; 4818 :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 4819 : }

	mov	esp, ebp
	pop	ebp
	ret	0
_StringCbPrintfW ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
_TEXT	SEGMENT
_hr$ = -4						; size = 4
_pszDest$ = 8						; size = 4
_cchDest$ = 12						; size = 4
_cchMax$ = 16						; size = 4
_StringValidateDestW@12 PROC

; 8769 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 8770 :     HRESULT hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 8771 : 
; 8772 :     if ((cchDest == 0) || (cchDest > cchMax))

	cmp	DWORD PTR _cchDest$[ebp], 0
	je	SHORT $LN1@StringVali
	mov	eax, DWORD PTR _cchDest$[ebp]
	cmp	eax, DWORD PTR _cchMax$[ebp]
	jbe	SHORT $LN2@StringVali
$LN1@StringVali:

; 8773 :     {
; 8774 :         hr = STRSAFE_E_INVALID_PARAMETER;

	mov	DWORD PTR _hr$[ebp], -2147024809	; 80070057H
$LN2@StringVali:

; 8775 :     }
; 8776 : 
; 8777 :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 8778 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_StringValidateDestW@12 ENDP
_TEXT	ENDS
EXTRN	__vsnwprintf:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_hr$ = -16						; size = 4
_iRet$ = -12						; size = 4
_cchMax$ = -8						; size = 4
_cchNewDestLength$ = -4					; size = 4
_pszDest$ = 8						; size = 4
_cchDest$ = 12						; size = 4
_pcchNewDestLength$ = 16				; size = 4
_pszFormat$ = 20					; size = 4
_argList$ = 24						; size = 4
_StringVPrintfWorkerW@20 PROC

; 9145 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 9146 :     HRESULT hr = S_OK;

	mov	DWORD PTR _hr$[ebp], 0

; 9147 :     int iRet;
; 9148 :     size_t cchMax;
; 9149 :     size_t cchNewDestLength = 0;

	mov	DWORD PTR _cchNewDestLength$[ebp], 0

; 9150 : 
; 9151 :     // leave the last space for the null terminator
; 9152 :     cchMax = cchDest - 1;

	mov	eax, DWORD PTR _cchDest$[ebp]
	sub	eax, 1
	mov	DWORD PTR _cchMax$[ebp], eax

; 9153 : 
; 9154 : #if (STRSAFE_USE_SECURE_CRT == 1) && !defined(STRSAFE_LIB_IMPL)
; 9155 :     iRet = _vsnwprintf_s(pszDest, cchDest, cchMax, pszFormat, argList);
; 9156 : #else
; 9157 :     #pragma warning(push)
; 9158 :     #pragma warning(disable: __WARNING_BANNED_API_USAGE)// "STRSAFE not included"
; 9159 :     iRet = _vsnwprintf(pszDest, cchMax, pszFormat, argList);

	mov	ecx, DWORD PTR _argList$[ebp]
	push	ecx
	mov	edx, DWORD PTR _pszFormat$[ebp]
	push	edx
	mov	eax, DWORD PTR _cchMax$[ebp]
	push	eax
	mov	ecx, DWORD PTR _pszDest$[ebp]
	push	ecx
	call	__vsnwprintf
	add	esp, 16					; 00000010H
	mov	DWORD PTR _iRet$[ebp], eax

; 9160 :     #pragma warning(pop)
; 9161 : #endif
; 9162 :     // ASSERT((iRet < 0) || (((size_t)iRet) <= cchMax));
; 9163 : 
; 9164 :     if ((iRet < 0) || (((size_t)iRet) > cchMax))

	cmp	DWORD PTR _iRet$[ebp], 0
	jl	SHORT $LN5@StringVPri
	mov	edx, DWORD PTR _iRet$[ebp]
	cmp	edx, DWORD PTR _cchMax$[ebp]
	jbe	SHORT $LN6@StringVPri
$LN5@StringVPri:

; 9165 :     {
; 9166 :         // need to null terminate the string
; 9167 :         pszDest += cchMax;

	mov	eax, DWORD PTR _cchMax$[ebp]
	mov	ecx, DWORD PTR _pszDest$[ebp]
	lea	edx, DWORD PTR [ecx+eax*2]
	mov	DWORD PTR _pszDest$[ebp], edx

; 9168 :         *pszDest = L'\0';

	xor	eax, eax
	mov	ecx, DWORD PTR _pszDest$[ebp]
	mov	WORD PTR [ecx], ax

; 9169 : 
; 9170 :         cchNewDestLength = cchMax;

	mov	edx, DWORD PTR _cchMax$[ebp]
	mov	DWORD PTR _cchNewDestLength$[ebp], edx

; 9171 : 
; 9172 :         // we have truncated pszDest
; 9173 :         hr = STRSAFE_E_INSUFFICIENT_BUFFER;

	mov	DWORD PTR _hr$[ebp], -2147024774	; 8007007aH
	jmp	SHORT $LN4@StringVPri
$LN6@StringVPri:

; 9174 :     }
; 9175 :     else if (((size_t)iRet) == cchMax)

	mov	eax, DWORD PTR _iRet$[ebp]
	cmp	eax, DWORD PTR _cchMax$[ebp]
	jne	SHORT $LN3@StringVPri

; 9176 :     {
; 9177 :         // need to null terminate the string
; 9178 :         pszDest += cchMax;

	mov	ecx, DWORD PTR _cchMax$[ebp]
	mov	edx, DWORD PTR _pszDest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*2]
	mov	DWORD PTR _pszDest$[ebp], eax

; 9179 :         *pszDest = L'\0';

	xor	ecx, ecx
	mov	edx, DWORD PTR _pszDest$[ebp]
	mov	WORD PTR [edx], cx

; 9180 : 
; 9181 :         cchNewDestLength = cchMax;

	mov	eax, DWORD PTR _cchMax$[ebp]
	mov	DWORD PTR _cchNewDestLength$[ebp], eax

; 9182 :     }
; 9183 :     else

	jmp	SHORT $LN4@StringVPri
$LN3@StringVPri:

; 9184 :     {
; 9185 :         cchNewDestLength = (size_t)iRet;

	mov	ecx, DWORD PTR _iRet$[ebp]
	mov	DWORD PTR _cchNewDestLength$[ebp], ecx
$LN4@StringVPri:

; 9186 :     }
; 9187 : 
; 9188 :     if (pcchNewDestLength)

	cmp	DWORD PTR _pcchNewDestLength$[ebp], 0
	je	SHORT $LN1@StringVPri

; 9189 :     {
; 9190 :         *pcchNewDestLength = cchNewDestLength;

	mov	edx, DWORD PTR _pcchNewDestLength$[ebp]
	mov	eax, DWORD PTR _cchNewDestLength$[ebp]
	mov	DWORD PTR [edx], eax
$LN1@StringVPri:

; 9191 :     }
; 9192 : 
; 9193 :     return hr;

	mov	eax, DWORD PTR _hr$[ebp]

; 9194 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_StringVPrintfWorkerW@20 ENDP
_TEXT	ENDS
PUBLIC	_PrintMultiSz
; Function compile flags: /Odtp
; File b:\programm\wntsys\testfilter\release\1_1\source\testclt\testclt.c
_TEXT	SEGMENT
tv67 = -8						; size = 4
_i$ = -4						; size = 4
_pAdl$ = 8						; size = 4
_PrintAccDevList PROC

; 641  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 642  : 	UINT	i;
; 643  : 	wprintf(
; 644  : 		L"\nComplete data:       %s\n",
; 645  : 		pAdl->bIncomplete ? L"no": L"yes" );

	mov	eax, DWORD PTR _pAdl$[ebp]
	movzx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN6@PrintAccDe
	mov	DWORD PTR tv67[ebp], OFFSET $SG79032
	jmp	SHORT $LN7@PrintAccDe
$LN6@PrintAccDe:
	mov	DWORD PTR tv67[ebp], OFFSET $SG79033
$LN7@PrintAccDe:
	mov	edx, DWORD PTR tv67[ebp]
	push	edx
	push	OFFSET $SG79034
	call	_wprintf
	add	esp, 8

; 646  : 	wprintf(
; 647  : 		L"\nBytes needed:        %d\n",
; 648  : 		pAdl->ReqBufSize);

	mov	eax, DWORD PTR _pAdl$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	push	OFFSET $SG79035
	call	_wprintf
	add	esp, 8

; 649  : 
; 650  : 	for (i = 0; i < pAdl->DevInfoCount; i++) {

	mov	DWORD PTR _i$[ebp], 0
	jmp	SHORT $LN3@PrintAccDe
$LN2@PrintAccDe:
	mov	edx, DWORD PTR _i$[ebp]
	add	edx, 1
	mov	DWORD PTR _i$[ebp], edx
$LN3@PrintAccDe:
	mov	eax, DWORD PTR _pAdl$[ebp]
	mov	ecx, DWORD PTR _i$[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	$LN1@PrintAccDe

; 651  : 		wprintf(
; 652  : 			L"\n"
; 653  : 			L"Device:         %s\n",
; 654  : 			pAdl->TargDevVect[i].SymLink );

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 1114				; 0000045aH
	mov	eax, DWORD PTR _pAdl$[ebp]
	lea	ecx, DWORD PTR [eax+edx+12]
	push	ecx
	push	OFFSET $SG79039
	call	_wprintf
	add	esp, 8

; 655  : 		wprintf(
; 656  : 			L"Text:              %s\n",
; 657  : 			pAdl->TargDevVect[i].DeviceText );

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 1114				; 0000045aH
	mov	eax, DWORD PTR _pAdl$[ebp]
	lea	ecx, DWORD PTR [eax+edx+520]
	push	ecx
	push	OFFSET $SG79040
	call	_wprintf
	add	esp, 8

; 658  : 		wprintf(
; 659  : 			L"Device ID:         %s\n",
; 660  : 			pAdl->TargDevVect[i].DeviceId );

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 1114				; 0000045aH
	mov	eax, DWORD PTR _pAdl$[ebp]
	lea	ecx, DWORD PTR [eax+edx+318]
	push	ecx
	push	OFFSET $SG79041
	call	_wprintf
	add	esp, 8

; 661  : 		wprintf(
; 662  : 			L"Instance ID:       %s\n",
; 663  : 			pAdl->TargDevVect[i].InstanceId );

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 1114				; 0000045aH
	mov	eax, DWORD PTR _pAdl$[ebp]
	lea	ecx, DWORD PTR [eax+edx+924]
	push	ecx
	push	OFFSET $SG79042
	call	_wprintf
	add	esp, 8

; 664  : 		wprintf(
; 665  : 			L"Hardware IDs:      ");

	push	OFFSET $SG79043
	call	_wprintf
	add	esp, 4

; 666  : 		PrintMultiSz(pAdl->TargDevVect[i].HardwareIDs);

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 1114				; 0000045aH
	mov	eax, DWORD PTR _pAdl$[ebp]
	lea	ecx, DWORD PTR [eax+edx+722]
	push	ecx
	call	_PrintMultiSz
	add	esp, 4

; 667  : 		wprintf(L"\n");

	push	OFFSET $SG79044
	call	_wprintf
	add	esp, 4

; 668  : 		wprintf(
; 669  : 			L"Compatible IDs:    ");

	push	OFFSET $SG79045
	call	_wprintf
	add	esp, 4

; 670  : 		PrintMultiSz(pAdl->TargDevVect[i].CompatibleIDs);

	mov	edx, DWORD PTR _i$[ebp]
	imul	edx, 1114				; 0000045aH
	mov	eax, DWORD PTR _pAdl$[ebp]
	lea	ecx, DWORD PTR [eax+edx+116]
	push	ecx
	call	_PrintMultiSz
	add	esp, 4

; 671  : 		wprintf(L"\n");

	push	OFFSET $SG79046
	call	_wprintf
	add	esp, 4

; 672  : 	}

	jmp	$LN2@PrintAccDe
$LN1@PrintAccDe:

; 673  : 
; 674  : 	return FALSE;

	xor	eax, eax

; 675  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_PrintAccDevList ENDP
; Function compile flags: /Odtp
_PrintHelp PROC

; 681  : {

	push	ebp
	mov	ebp, esp

; 682  : 	wprintf(L"\n\nUsage:");

	push	OFFSET $SG79048
	call	_wprintf
	add	esp, 4

; 683  : 	wprintf(L"\n\n    List devices:");

	push	OFFSET $SG79049
	call	_wprintf
	add	esp, 4

; 684  : 	wprintf(L"\n\n        TestClt /l");

	push	OFFSET $SG79050
	call	_wprintf
	add	esp, 4

; 685  : 	wprintf(L"\n\n    Set flags for IRP major function code:");

	push	OFFSET $SG79051
	call	_wprintf
	add	esp, 4

; 686  : 	wprintf(L"\n\n        TestClt /c s major_function flags symbolic_link");

	push	OFFSET $SG79052
	call	_wprintf
	add	esp, 4

; 687  : 	wprintf(L"\n\n            major_function: IRP major function code in hex");

	push	OFFSET $SG79053
	call	_wprintf
	add	esp, 4

; 688  : 	wprintf(L"\n\n            flags         : flags value in hex");

	push	OFFSET $SG79054
	call	_wprintf
	add	esp, 4

; 689  : 	wprintf(L"\n\n            symbolic_link : sym link for the FA device");

	push	OFFSET $SG79055
	call	_wprintf
	add	esp, 4

; 690  : 	wprintf(L"\n\n    Get intercepted data:");

	push	OFFSET $SG79056
	call	_wprintf
	add	esp, 4

; 691  : 	wprintf(L"\n\n        TestClt /d archit osver symbolic_link");

	push	OFFSET $SG79057
	call	_wprintf
	add	esp, 4

; 692  : 	wprintf(L"\n\n            archit        : processor architecture (x86, x64)");

	push	OFFSET $SG79058
	call	_wprintf
	add	esp, 4

; 693  : 	wprintf(L"\n\n            osver         : windows version (wxp, vista, win7)");

	push	OFFSET $SG79059
	call	_wprintf
	add	esp, 4

; 694  : 	wprintf(L"\n\n            symbolic_link : sym link for the FA device");

	push	OFFSET $SG79060
	call	_wprintf
	add	esp, 4

; 695  : 	wprintf(L"\n");

	push	OFFSET $SG79061
	call	_wprintf
	add	esp, 4

; 696  : }

	pop	ebp
	ret	0
_PrintHelp ENDP
; Function compile flags: /Odtp
_StrLen$ = -4						; size = 4
_pwszMulti$ = 8						; size = 4
_PrintMultiSz PROC

; 703  : {

	push	ebp
	mov	ebp, esp
	push	ecx
$LN3@PrintMulti:

; 704  : 	SIZE_T StrLen;
; 705  : 
; 706  : 	for (;;) {
; 707  : 		wprintf(pwszMulti);

	mov	eax, DWORD PTR _pwszMulti$[ebp]
	push	eax
	call	_wprintf
	add	esp, 4

; 708  : 		StrLen = wcslen(pwszMulti);

	mov	ecx, DWORD PTR _pwszMulti$[ebp]
	push	ecx
	call	_wcslen
	add	esp, 4
	mov	DWORD PTR _StrLen$[ebp], eax

; 709  : 		pwszMulti += StrLen + 1;

	mov	edx, DWORD PTR _StrLen$[ebp]
	mov	eax, DWORD PTR _pwszMulti$[ebp]
	lea	ecx, DWORD PTR [eax+edx*2+2]
	mov	DWORD PTR _pwszMulti$[ebp], ecx

; 710  : 		if (*pwszMulti == L'\0') break;

	mov	edx, DWORD PTR _pwszMulti$[ebp]
	movzx	eax, WORD PTR [edx]
	test	eax, eax
	jne	SHORT $LN1@PrintMulti
	jmp	SHORT $LN4@PrintMulti
$LN1@PrintMulti:

; 711  : 		wprintf(L", ");

	push	OFFSET $SG79070
	call	_wprintf
	add	esp, 4

; 712  : 	} 

	jmp	SHORT $LN3@PrintMulti
$LN4@PrintMulti:

; 713  : 
; 714  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_PrintMultiSz ENDP
_TEXT	ENDS
EXTRN	__imp__DeviceIoControl@32:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_bResult$ = -8						; size = 4
_dwBytesRet$ = -4					; size = 4
_hDevice$ = 8						; size = 4
_code$ = 12						; size = 4
_lpInBuffer$ = 16					; size = 4
_inBufSize$ = 20					; size = 4
_lpOutBuffer$ = 24					; size = 4
_outBufSize$ = 28					; size = 4
_SendIoCtl PROC

; 726  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 727  : 	BOOL	bResult;
; 728  : 	DWORD	dwBytesRet;
; 729  : 
; 730  : 	bResult = DeviceIoControl(
; 731  : 		hDevice,
; 732  : 		code,
; 733  : 		lpInBuffer,
; 734  : 		inBufSize,
; 735  : 		lpOutBuffer,
; 736  : 		outBufSize,
; 737  : 		&dwBytesRet,
; 738  : 		NULL);

	push	0
	lea	eax, DWORD PTR _dwBytesRet$[ebp]
	push	eax
	mov	ecx, DWORD PTR _outBufSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _lpOutBuffer$[ebp]
	push	edx
	mov	eax, DWORD PTR _inBufSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _lpInBuffer$[ebp]
	push	ecx
	mov	edx, DWORD PTR _code$[ebp]
	push	edx
	mov	eax, DWORD PTR _hDevice$[ebp]
	push	eax
	call	DWORD PTR __imp__DeviceIoControl@32
	mov	DWORD PTR _bResult$[ebp], eax

; 739  : 
; 740  : 	if (!bResult) {

	cmp	DWORD PTR _bResult$[ebp], 0
	jne	SHORT $LN1@SendIoCtl

; 741  : 		_tprintf( TEXT("Failed to send IOCTL. Code: 0x%8x, GetLastError() = 0x%8x, (%i)"),
; 742  : 			code,
; 743  : 			GetLastError(),
; 744  : 			GetLastError() );

	call	DWORD PTR __imp__GetLastError@0
	push	eax
	call	DWORD PTR __imp__GetLastError@0
	push	eax
	mov	ecx, DWORD PTR _code$[ebp]
	push	ecx
	push	OFFSET $SG79088
	call	_wprintf
	add	esp, 16					; 00000010H

; 745  : 		return bResult;

	mov	eax, DWORD PTR _bResult$[ebp]
	jmp	SHORT $LN2@SendIoCtl
$LN1@SendIoCtl:

; 746  : 	}
; 747  : 
; 748  : 	return bResult;

	mov	eax, DWORD PTR _bResult$[ebp]
$LN2@SendIoCtl:

; 749  : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SendIoCtl ENDP
_TEXT	ENDS
END
